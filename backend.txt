
================================================================================
File: certs\ca.pem
Size: 1.56 kB
================================================================================

-----BEGIN CERTIFICATE-----
MIIEUDCCArigAwIBAgIUXdnCHH5nPdRt6/UZ3QkbxC2DC4YwDQYJKoZIhvcNAQEM
BQAwQDE+MDwGA1UEAww1OWUxNTRhZDQtOTRmNC00OTg0LWEwNjktMzI5MDBlYjVl
NjRmIEdFTiAxIFByb2plY3QgQ0EwHhcNMjUxMDA1MTIyODMwWhcNMzUxMDAzMTIy
ODMwWjBAMT4wPAYDVQQDDDU5ZTE1NGFkNC05NGY0LTQ5ODQtYTA2OS0zMjkwMGVi
NWU2NGYgR0VOIDEgUHJvamVjdCBDQTCCAaIwDQYJKoZIhvcNAQEBBQADggGPADCC
AYoCggGBAIwvKe3n2XzPzWSZXosWCC/rg1Sizlui5/CqjdKPVKq+FTjOLWmERKot
m3dgmgd+FSYHcgpV7N8x9YRn3qPTf1f7dwPmoAuOEFlUWi/HqyoehbpnQ/6+B570
1L5Wv7oabuNW/cbvdtxlIG4jjyBq+y7cUssXeyGWtva6L9Xm821iO9xj8EG+2ig4
5aI5mcaxge/Zqlf7sLmsy1nFMEiBnJTO7ZQkYeb4CJECSywspQ1mhBCokdOvI5Cn
0/vvt+FMmeXy8XXmICd9pKRgu8cKz/04apggCbcX17l1c/j9poi21ZD94uvAVB2b
qZZL0Q6BX3DiU+pZdqcOaIKb0JYw+ATx4xOBqp1amjqAOdMKam5lUhZRRAiCs6s3
b9ANDcOJo79q7s2vdQpbNyTFY+I9hVy2eAIGcPA7eVzsnGV6UAJ6UslmKGXMjsSO
mc/NcbZ8uDrb3M9GR/Ef1lRvuqYRF1XgMrKOFnyFzEHL97rGndr/6J9lmU/Rj7iY
SQdF0rJe2wIDAQABo0IwQDAdBgNVHQ4EFgQU1F3fyIp8qf2qGtbBuzX5uHyENQYw
EgYDVR0TAQH/BAgwBgEB/wIBADALBgNVHQ8EBAMCAQYwDQYJKoZIhvcNAQEMBQAD
ggGBAAdHQXAeLTeKxJVr0n26nh8Wxe+A9Yzr6pX7N5INr9TD0M/ToxZf9RSLFuiQ
2yaC4TdiQD2w44eJJ2sZvUu8h6k4AAaqJuixXOcVzGMuHUo3GxuICQ2A4hwrBphO
Nlevd35TT0IvCA9lOY89E+DrZ2F/l5BrrRzk/woLJIlgX6tYyZ0MX+4TfaIimEYE
/cVQItwOFRZRpIeilbwYD7dkn9qKXTWBnPpW+x71dZkWPrVQ5G2SoTGMC81jgBL/
15Rzjfphpi/jGGfS20Y0DM0DaX9/zS7Oa5MNBYRcGX+58qm3Umep766sxWho1gP+
SZ76Xv83ygFVQ6cxcGdR1DDBF87UMgYETd1Yflu2CTSLIqnAgYwSkZrzk2tmwbV7
yXrCsDTb6kxGEAR6f4VvdUKwqYTVu9JiDGj/B7Ktuk8yT3o8GWolmYuANfHJ1LpZ
utug2sb2NcNw0fFp6fWFvE8K2Et5RP66To0RQMJQmMvfWwgFFhWKHGlnrNy9TH4n
yVM//A==
-----END CERTIFICATE-----


================================================================================
File: config.json
Size: 562 B
================================================================================

{
    "database": {
        "host": "localhost",
        "port": 3306,
        "user": "root",
        "password": "root",
        "database": "IMP_db"
    },
    "secret": "THIS IS USED TO SIGN AND VERIFY JWT TOKENS, REPLACE IT WITH YOUR OWN SECRET, IT CAN BE ANY STRING", 
    "emailFrom": "info@node-mysql-signup-verification-api.com",
    "smtpOptions": {
        "host": "smtp.ethereal.email", 
        "port": 587,
        "auth": {
            "user":"samir.mohr@ethereal.email",
            "pass":"DybCr9vj2zAZtFeqcN"
        }
    }
}

================================================================================
File: notes.md
Size: 626 B
================================================================================

<!-- items should have this status: -->
    every room scanning status:
        used - in used item
        damage - damaged item
        misplaced item - item that is not belong to that room
    
    rooms status
        missing - missing item

    stockroom status:
        active - working item but not used
        inactive - out of stock/

<!-- roles should have -->
    super admin
    admin
    user

<!-- item category should have -->
    IT assets
    apparel assets
    admin assets

<!-- name casing -->
    pascal casing / TestTest : model name
    camel casing / testTest  : function name

================================================================================
File: package.json
Size: 1.04 kB
================================================================================

{
  "name": "imp",
  "version": "1.0.0",
  "description": "Inventory Management Project",
  "main": "server.js",
  "scripts": {
    "start": "node ./server.js",
    "start:dev": "nodemon ./server.js",
    "export:all": "folder2txt --output backend.txt C:/Users/Administrator/My Desktop/Inventory Monitoring/IMP --exclude node_modules"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcryptjs": "^3.0.2",
    "body-parser": "^1.20.3",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "crypto": "^1.0.1",
    "dotenv": "^17.2.3",
    "express": "^4.21.2",
    "express-jwt": "^8.5.1",
    "joi": "^17.13.3",
    "jsonwebtoken": "^9.0.2",
    "lodash": "^4.17.21",
    "multer": "^2.0.0",
    "mysql2": "^3.12.0",
    "ngrok": "^5.0.0-beta.2",
    "nodemailer": "^6.10.0",
    "pdfkit": "^0.17.2",
    "qrcode": "^1.5.4",
    "rootpath": "^0.1.2",
    "sequelize": "^6.37.5",
    "swagger-ui-express": "^5.0.1",
    "yamljs": "^0.3.0"
  },
  "devDependencies": {
    "folder2txt": "^1.0.2",
    "nodemon": "^3.1.9"
  }
}


================================================================================
File: README.md
Size: 37 B
================================================================================

# IMP
Inventory Management Project


================================================================================
File: scripts\write-ca.js
Size: 707 B
================================================================================

const fs = require('fs');
const path = require('path');

const outDir = path.join(__dirname, '..', 'certs');
const outPath = process.env.DB_CA_PATH || path.join(outDir, 'ca.pem');
const base64 = process.env.DB_CA_BASE64 || '';

if (!base64) {
  console.log('DB_CA_BASE64 not set — skipping writing CA file.');
  process.exit(0);
}

try {
  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });
  const buf = Buffer.from(base64, 'base64');
  fs.writeFileSync(outPath, buf, { mode: 0o600 }); // owner read/write only
  console.log(`Wrote DB CA to ${outPath}`);
  process.exit(0);
} catch (err) {
  console.error('Failed to write DB CA file:', err);
  process.exit(1);
}

================================================================================
File: server.js
Size: 4.87 kB
================================================================================

require('rootpath')();
const express         = require('express');
const app             = express();
const bodyParser      = require('body-parser');
const cookieParser    = require('cookie-parser');
const cors            = require('cors');
const errorHandler    = require('_middlewares/error-handler');
const path            = require('path');

// ─── JSON / URL-ENCODED PARSING ───────────────────────────────────────────────
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// ─── BODY-PARSER & COOKIE ───────────────────────────────────────────────────
app.use(bodyParser.urlencoded({extended: false }));
app.use(bodyParser.json()); 
app.use(cookieParser());

// ─── FRONTEND PORT ───────────────────────────────────────────────────
// const allowedOrigins = [
//   'http://localhost:4200',      // duplicated project
//   'http://localhost:4000',      // angularBoilerplate
//   'http://localhost:3000',      // nextjs frontend
//   'http://221.121.99.208:4200',    // your other device (keep or remove as needed)
//   'inventory-management-system-liard-eta.vercel.app'
// ];
// app.use(cors({
//   origin: function(origin, callback){
//     // allow requests with no origin (like mobile apps or curl)
//     if(!origin) return callback(null, true);
//     if(allowedOrigins.indexOf(origin) !== -1){
//       callback(null, true);
//     } else {
//       callback(new Error('CORS policy does not allow access from this origin'));
//     }
//   },
//   credentials: true
// }));

const allowedOrigins = [
  'http://localhost:4200',
  'http://localhost:3000',
  'https://inventory-management-system-liard-eta.vercel.app', // <-- frontend on Vercel (include https)
  'https://inventory-management-system-vy5y.onrender.com'     // <-- backend origin (if you need it)
];

app.use(cors({
  origin: function(origin, callback) {
    // allow requests with no origin (mobile apps, curl, server-to-server)
    if (!origin) return callback(null, true);
    if (allowedOrigins.includes(origin)) {
      return callback(null, true);
    }
    // reject other origins (CORS will fail on browser side)
    return callback(new Error('CORS policy does not allow access from this origin: ' + origin));
  },
  credentials: true,          // allow cookies (if needed)
  optionsSuccessStatus: 200   // some old browsers choke on 204 for preflight
}));

// ensure preflight OPTIONS are handled
app.options('*', cors({ origin: allowedOrigins, credentials: true }));

// ─── SERVE UPLOADS DIRECTORY ────────────────────────────────────────────────
app.use('/uploads', express.static(path.join(__dirname, '..', 'uploads')));
// ─── API ROUTES ────────────────────────────────────────────────
app.use('/rooms',       require('./_controllers/room.controller'));
app.use('/accounts',    require('./_controllers/account.controller'));
app.use('/qr',          require('./_controllers/qr.controller'));
app.use('/req-stock',   require('./_controllers/request.stock.controller'));
app.use('/req-item',    require('./_controllers/request.item.controller'));
app.use('/transfers',   require('./_controllers/transfer.controller'));
app.use('/borrows',     require('./_controllers/borrow.controller'));

// ─── SWAGGER DOCS ROUTES ────────────────────────────────────────────────
app.use('/api-docs',    require('./_helpers/swagger'));

// ─── GLOBAL ERROR HANDLER ────────────────────────────────────────────────
app.use(errorHandler);

// ─── START SERVER ────────────────────────────────────────────────
const port = process.env.NODE_ENV === 'production' ? (process.env.PORT || 10000): 5000;
app.listen(port, () => console.log('Server listening on port' + port));
// const PORT = process.env.PORT || 10000;
// app.listen(PORT, () => console.log(`Server listening on port ${PORT}`));
// const port = process.env.NODE_ENV === 'production' ? (process.env.PORT || 80) : 5000;
// app.listen(port, '0.0.0.0', () => console.log(`Server listening on 0.0.0.0:${port}`));

================================================================================
File: swagger.yaml
Size: 23.7 kB
================================================================================

openapi: 3.0.0
info:
  title: Node.js Sign-up and Verification API
  description: Node.js and MySQL - API with email sign-up, verification, authentication and forgot password
  version: 1.0.0

servers:
  - url: http://localhost:5000
    description: Local development server

paths:
  /accounts/authenticate:
    post:
      summary: Authenticate account credentials and return a JWT token and a cookie with a refresh token
      description: Accounts must be verified before authenticating.
      operationId: authenticate
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                email:
                  type: string
                  example: "jason@example.com"
                password:
                  type: string
                  example: "pass123"
              required:
                - email
                - password
      responses:
        "200":
          description: Account details, a JWT access token and a refresh token cookie
          headers:
            Set-Cookie:
              description: "`refreshToken`"
              schema:
                type: string
                example: refreshToken=51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550; Path=/; Expires=Tue, 16 Jun 2020 09:14:17 GMT; HttpOnly
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
                  isVerified:
                    type: boolean
                    example: true
                  jwtToken:
                    type: string
                    example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1ZWIxMmUxOTdlMDZhNzZjY2RlZmMxMjEiLCJpZCI6IjVlYjEyZTE5N2UwNmE3NmNjZGVmYzEyMSIsImlhdCI6MTU4ODc1ODE1N30.xR9H0STbFOpSkuGA9jHNZOJ6eS7umHHqKRhI807YT1Y"
        "400":
          description: The email or password is incorrect
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Email or password is incorrect"
  /accounts/refresh-token:
    post:
      summary: Use a refresh token to generate a new JWT token and a new refresh token
      description: The refresh token is sent and returned via cookies.
      operationId: refreshToken
      parameters:
        - in: cookie
          name: refreshToken
          description: The `refreshToken` cookie
          schema:
            type: string
            example: 51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550
      responses:
        "200":
          description: Account details, a JWT access token and a new refresh token cookie
          headers:
            Set-Cookie:
              description: "`refreshToken`"
              schema:
                type: string
                example: refreshToken=51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550; Path=/; Expires=Tue, 16 Jun 2020 09:14:17 GMT; HttpOnly
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
                  isVerified:
                    type: boolean
                    example: true
                  jwtToken:
                    type: string
                    example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1ZWIxMmUxOTdlMDZhNzZjY2RlZmMxMjEiLCJpZCI6IjVlYjEyZTE5N2UwNmE3NmNjZGVmYzEyMSIsImlhdCI6MTU4ODc1ODE1N30.xR9H0STbFOpSkuGA9jHNZOJ6eS7umHHqKRhI807YT1Y"
        "400":
          description: The refresh token is invalid, revoked or expired
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Invalid token"
  /accounts/revoke-token:
    post:
      summary: Revoke a refresh token
      description: Admin users can revoke the tokens of any account, regular users can only revoke their own tokens.
      operationId: revokeToken
      security:
        - bearerAuth: []
      parameters:
        - in: cookie
          name: refreshToken
          description: The refresh token can be sent in a cookie or the post body, if both are sent the token in the body is used.
          schema:
            type: string
            example: 51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                token:
                  type: string
                  example: "51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550"
      responses:
        "200":
          description: The refresh token was successfully revoked
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Token revoked"
        "400":
          description: The refresh token is invalid
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Invalid token"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
  /accounts/register:
    post:
      summary: Register a new user account and send a verification email
      description: The first account registered in the system is assigned the `Admin` role, other accounts are assigned the `User` role.
      operationId: register
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                title:
                  type: string
                  example: "Mr"
                firstName:
                  type: string
                  example: "Jason"
                lastName:
                  type: string
                  example: "Watmore"
                email:
                  type: string
                  example: "jason@example.com"
                password:
                  type: string
                  example: "pass123"
                confirmPassword:
                  type: string
                  example: "pass123"
                acceptTerms:
                  type: boolean
              required:
                - title
                - firstName
                - lastName
                - email
                - password
                - confirmPassword
                - acceptTerms
      responses:
        "200":
          description: The registration request was successful and a verification email has been sent to the specified email address
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Registration successful, please check your email for verification instructions"
  /accounts/verify-email:
    post:
      summary: Verify a new account with a verification token received by email after registration
      operationId: verifyEmail
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                token:
                  type: string
                  example: "3c7f8d9c4cb348ff95a0b74a1452aa24fc9611bb76768bb9eafeeb826ddae2935f1880bc7713318f"
              required:
                - token
      responses:
        "200":
          description: Verification was successful so you can now login to the account
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Verification successful, you can now login"
        "400":
          description: Verification failed due to an invalid token
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Verification failed"
  /accounts/forgot-password:
    post:
      summary: Submit email address to reset the password on an account
      operationId: forgotPassword
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                email:
                  type: string
                  example: "jason@example.com"
              required:
                - email
      responses:
        "200":
          description: The request was received and an email has been sent to the specified address with password reset instructions (if the email address is associated with an account)
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Please check your email for password reset instructions"
  /accounts/validate-reset-token:
    post:
      summary: Validate the reset password token received by email after submitting to the /accounts/forgot-password route
      operationId: validateResetToken
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                token:
                  type: string
                  example: "3c7f8d9c4cb348ff95a0b74a1452aa24fc9611bb76768bb9eafeeb826ddae2935f1880bc7713318f"
              required:
                - token
      responses:
        "200":
          description: Token is valid
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Token is valid"
        "400":
          description: Token is invalid
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Invalid token"
  /accounts/reset-password:
    post:
      summary: Reset the password for an account
      operationId: resetPassword
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                token:
                  type: string
                  example: "3c7f8d9c4cb348ff95a0b74a1452aa24fc9611bb76768bb9eafeeb826ddae2935f1880bc7713318f"
                password:
                  type: string
                  example: "newPass123"
                confirmPassword:
                  type: string
                  example: "newPass123"
              required:
                - token
                - password
                - confirmPassword
      responses:
        "200":
          description: Password reset was successful so you can now login to the account with the new password
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Password reset successful, you can now login"
        "400":
          description: Password reset failed due to an invalid token
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Invalid token"
  /accounts:
    get:
      summary: Get a list of all accounts
      description: Restricted to admin users.
      operationId: getAllAccounts
      security:
        - bearerAuth: []
      responses:
        "200":
          description: An array of all accounts
          content:
            application/json:
              schema:
                type: array
                items:
                  type: object
                  properties:
                    id:
                      type: string
                      example: "5eb12e197e06a76ccdefc121"
                    title:
                      type: string
                      example: "Mr"
                    firstName:
                      type: string
                      example: "Jason"
                    lastName:
                      type: string
                      example: "Watmore"
                    email:
                      type: string
                      example: "jason@example.com"
                    role:
                      type: string
                      example: "Admin"
                    created:
                      type: string
                      example: "2020-05-05T09:12:57.848Z"
                    updated:
                      type: string
                      example: "2020-05-08T03:11:21.553Z"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
    post:
      summary: Create a new account
      description: Restricted to admin users.
      operationId: createAccount
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                title:
                  type: string
                  example: "Mr"
                firstName:
                  type: string
                  example: "Jason"
                lastName:
                  type: string
                  example: "Watmore"
                email:
                  type: string
                  example: "jason@example.com"
                password:
                  type: string
                  example: "pass123"
                confirmPassword:
                  type: string
                  example: "pass123"
                role:
                  type: string
                  enum: [Admin, User]
              required:
                - title
                - firstName
                - lastName
                - email
                - password
                - confirmPassword
                - role
      responses:
        "200":
          description: Account created successfully, verification is not required for accounts created with this endpoint. The details of the new account are returned.
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
        "400":
          description: Email is already registered
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Email 'jason@example.com' is already registered"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
  /accounts/{id}:
    parameters:
      - in: path
        name: id
        description: Account id
        required: true
        example: "5eb12e197e06a76ccdefc121"
        schema:
          type: string
    get:
      summary: Get a single account by id
      description: Admin users can access any account, regular users are restricted to their own account.
      operationId: getAccountById
      security:
        - bearerAuth: []
      responses:
        "200":
          description: Details of the specified account
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
                  updated:
                    type: string
                    example: "2020-05-08T03:11:21.553Z"
        "404":
          $ref: "#/components/responses/NotFoundError"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
    put:
      summary: Update an account
      description: Admin users can update any account including role, regular users are restricted to their own account and cannot update role.
      operationId: updateAccount
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                title:
                  type: string
                  example: "Mr"
                firstName:
                  type: string
                  example: "Jason"
                lastName:
                  type: string
                  example: "Watmore"
                email:
                  type: string
                  example: "jason@example.com"
                password:
                  type: string
                  example: "pass123"
                confirmPassword:
                  type: string
                  example: "pass123"
                role:
                  type: string
                  enum: [Admin, User]
      responses:
        "200":
          description: Account updated successfully. The details of the updated account are returned.
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
                  updated:
                    type: string
                    example: "2020-05-08T03:11:21.553Z"
        "404":
          $ref: "#/components/responses/NotFoundError"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
    delete:
      summary: Delete an account
      description: Admin users can delete any account, regular users are restricted to their own account.
      operationId: deleteAccount
      security:
        - bearerAuth: []
      responses:
        "200":
          description: Account deleted successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Account deleted successfully"
        "404":
          $ref: "#/components/responses/NotFoundError"
        "401":
          $ref: "#/components/responses/UnauthorizedError"

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  responses:
    UnauthorizedError:
      description: Access token is missing or invalid, or the user does not have access to perform the action
      content:
        application/json:
          schema:
            type: object
            properties:
              message:
                type: string
                example: "Unauthorized"
    NotFoundError:
      description: Not Found
      content:
        application/json:
          schema:
            type: object
            properties:
              message:
                type: string
                example: "Not Found"

================================================================================
File: _controllers\account.controller.js
Size: 12.99 kB
================================================================================

// main functions of account controller
const express   = require('express');
const router    = express. Router(); 
const Joi       = require('joi');

const validateRequest   = require('_middlewares/validate-request'); 
const authorize         = require('_middlewares/authorize');
const Role              = require('_helpers/role');
const accountService    = require('_services/account.service');
const db                = require('_helpers/db-handler');

router.post('/register',                registerSchema, register);
router.post('/authenticate',            authenticateSchema, authenticate);
router.post('/refresh-token',           refreshToken);
router.post('/revoke-token',            authorize(), revokeTokenSchema, revokeToken); 
router.post('/verify-email',            verifyEmailSchema, verifyEmail);
router.post('/forgot-password',         forgotPasswordSchema, forgotPassword);
router.post('/validate-reset-token',    validateResetTokenSchema, validateResetToken);
router.post('/reset-password',          resetPasswordSchema, resetPassword);

router.post('/:accountId/activity',     authorize(), getActivities);
router.get('/activity-logs',            authorize(Role.SuperAdmin), getAllActivityLogs);
router.get('/exists',                   existsAccount);

router.post('/create-user',             authorize (Role.SuperAdmin), createSchema, create);
router.post('/create-array',            authorize (Role.SuperAdmin), createAsArraySchema, createAsArray);
router.get('/',                         authorize (Role.SuperAdmin), getAll);
router.get('/:accountId',               authorize(), getById);
router.put('/:accountId',               authorize(Role.SuperAdmin), updateSchema, update);

router.delete('/:accountId',            authorize(Role.SuperAdmin), _delete);

module.exports = router;

function authenticateSchema(req, res, next) { 
    const schema = Joi.object({
        email: Joi.string().required(),
        password: Joi.string().required()
    });

    validateRequest(req, next, schema);
}
async function authenticate(req, res, next) {
try {
    const { email, password } = req.body;
    const ipAddress = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
    const browserInfo = req.headers['user-agent'] || 'Unknown Browser';

    const account = await accountService.authenticate({ email, password, ipAddress, browserInfo });

    if (account.status === 'deactivated') {
      return res.status(403).json({ message: 'Account is deactivated. Contact administrator.' });
    }

    res.cookie('token', account.jwtToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 60 * 1000, // 1h
    });

    setTokenCookie(res, account.refreshToken);

    return res.json(account);
} catch (err) {
    next(err);
}
}
//===================Logging Function=======================================
function getActivities(req, res, next) {
    const filters = {
        actionType: req.query.actionType,
        startDate: req.query.startDate,
        endDate: req.query.endDate
    };
    accountService.getAccountActivities(req.params.id, filters)
        .then(activities => res.json(activities))
        .catch(next);
}
function getAllActivityLogs(req, res, next) {
    const filters = {
        actionType: req.query.actionType,
        startDate: req.query.startDate,
        endDate: req.query.endDate,
        userId: req.query.userId
    };
    
    accountService.getAllActivityLogs(filters)
        .then(logs => res.json({
            success: true,
            data: logs
        }))
        .catch(next);
}
async function refreshToken(req, res, next) {
    try {
      const token =
        (req.cookies && req.cookies.refreshToken) ||
        req.body?.token ||
        req.get('x-refresh-token') ||
        req.headers['x-refresh-token'];
  
      if (!token) {
        return res.status(204).end();
      }
  
      let accountPayload;
      try {
        accountPayload = await accountService.refreshToken({ token, ipAddress: req.ip });
      } catch (serviceErr) {
        if (serviceErr && serviceErr.message && serviceErr.message.toLowerCase().includes('invalid')) {
          return res.status(401).json({ message: 'Invalid or expired refresh token' });
        }
        console.error('refreshToken service error:', serviceErr);
        return res.status(500).json({ message: 'Internal error while refreshing token' });
      }
  
      if (!accountPayload) {
        return res.status(401).json({ message: 'Invalid or expired refresh token' });
      }
  
      return res.json(accountPayload);
    } catch (err) {
      console.error('refreshToken handler unexpected error:', err);
      return res.status(500).json({ message: 'Unexpected server error' });
    }
}
function revokeTokenSchema(req, res, next) { 
    const schema = Joi.object({
        token: Joi.string().empty('')
    });
    validateRequest(req, next, schema);
}
async function revokeToken (req, res, next) {
    try {
        const token = req.body.token || req.cookies.refreshToken;
        const ipAddress = req.ip;

        if (!token) return res.status(400).json({ message: 'Token is required' });

        const refreshToken = await db.RefreshToken.findOne({ where: { token } });
        if (!refreshToken || !refreshToken.isActive) {
            return res.status(400).json({ message: 'Invalid token' });
        }

        if (refreshToken.accountId !== req.user.accountId && req.user.role !== Role.SuperAdmin) {
            return res.status(401).json({ message: 'Unauthorized' });
        }

        await accountService.revokeToken({ token, ipAddress });
        return res.json({ message: 'Token revoked' });
    } catch (err) {
        next(err);
    }
}
function registerSchema(req, res, next) {
    const schema = Joi.object({
        title: Joi.string().required(),
        firstName: Joi.string().required(), 
        lastName: Joi.string().required(),
        email: Joi.string().email().required(),
        password: Joi.string().min(6).required(),
        confirmPassword: Joi.string().valid(Joi.ref('password')).required(), 
    });
    validateRequest(req, next, schema);
}
function register(req, res, next) {
    accountService.register(req.body, req.get('origin'))
        .then(() => res.json({ message: 'Registration successful, please check your email for verification instructions' })) 
        .catch(next);
}
async function existsAccount(req, res, next) {
    try {
      const total = await db.Account.count();
      const exists = (total && total > 0);
      return res.json({ exists });
    } catch (err) {
      console.error('accounts.exists error:', err && err.stack ? err.stack : err);
      return res.status(500).json({ message: 'Internal server error' });
    }
}
function verifyEmailSchema(req, res, next) {
    const schema = Joi.object({
        token: Joi.string().required()
    });
    validateRequest(req, next, schema);
}
function verifyEmail(req, res, next) {
    accountService.verifyEmail(req.body)
        .then(() => res.json({ message: 'Verification successful, you can now login' })) 
        .catch(next);
}
function forgotPasswordSchema(req, res, next) {
    const schema = Joi.object({
        email: Joi.string().email().required()
    });
    validateRequest(req, next, schema);
}
function forgotPassword(req, res, next) {
    accountService.forgotPassword(req.body, req.get('origin'))
        .then(() => res.json({ message: 'Please check your email for password reset instructions' })) 
        .catch(next);
}
function validateResetTokenSchema(req, res, next) {
    const schema = Joi.object({
        token: Joi.string().required()
    });
    validateRequest(req, next, schema);
}
function validateResetToken(req, res, next) {
    accountService.validateResetToken(req.body)
        .then(() => res.json({ message: 'Token is valid' }))
        .catch(next);
}
function resetPasswordSchema(req, res, next) {
    const schema = Joi.object({
        token: Joi.string().required(),
        password: Joi.string().min(6).required(),
        confirmPassword: Joi.string().valid(Joi.ref('password')).required()
    });
    validateRequest(req, next, schema);
}
function resetPassword(req, res, next) {
    const { token, password } = req.body;
    const ipAddress = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
    const browserInfo = req.headers['user-agent'] || 'Unknown Browser';
  
    accountService.resetPassword({ token, password }, ipAddress, browserInfo)
      .then(() => {
        res.json({ message: 'Password reset successful, you can now login' });
      })
      .catch(next);
}
function getAll(req, res, next) {
    accountService.getAll()
        .then (account => res.json (account))
        .catch(next);
}
function getById(req, res, next) {
    accountService.getById(req.params.accountId)
        .then(account => account ? res.json(account) : res.sendStatus(404)) 
        .catch(next);
}
function createSchema (req, res, next) {
    const schema = Joi.object({
        title: Joi.string().required(), 
        firstName: Joi.string().required(), 
        lastName: Joi.string().required(), 
        email: Joi.string().email().required(),
        password: Joi.string().min(6).required(), 
        confirmPassword: Joi.string().valid(Joi.ref('password')).required(),
        role: Joi.string().valid(Role. SuperAdmin, Role.Admin, Role.User, Role.StockroomAdmin, Role.Teacher).required(),
        status: Joi.string().valid('active','deactivated').optional(),
    });
    validateRequest(req, next, schema);
}
function create(req, res, next) {
    accountService.create(req.body) 
    .then (account => res.json (account)) 
    .catch(next);
}
function updateSchema(req, res, next) { 
    const schema = Joi.object({
        title: Joi.string().empty(''), 
        firstName: Joi.string().empty(''), 
        lastName: Joi.string().empty(''),
        email: Joi.string().email().empty(''),
        password: Joi.string().min(6).empty(''),
        confirmPassword: Joi.string().valid(Joi.ref('password')).empty(''),
        status: Joi.string().valid('active', 'deactivated').empty(''),
        role: Joi.string().valid(Role. SuperAdmin, Role.Admin, Role.User, Role.StockroomAdmin, Role.Teacher).empty('')
    });
    validateRequest(req, next, schema);
}
function update(req, res, next) {
  
    const ipAddress = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
    const browserInfo = req.headers['user-agent'] || 'Unknown Browser';
  
    accountService.update(req.params.accountId, req.body, ipAddress, browserInfo)
      .then(account => {
        res.json({
          success: true,
          message: 'Account updated successfully',
          account: account
        });
      })
      .catch(next);
}
async function _delete(req, res, next) {
    try {
      const accountId = parseInt(req.params.accountId || req.params.accountId, 10);
      if (Number.isNaN(accountId)) return res.status(400).json({ message: 'Invalid id' });
  
      await accountService.update(accountId, { status: 'deactivated' });
      res.json({ message: 'Account deactivated' });
    } catch (err) {
      next(err);
    }
}
function setTokenCookie(res, token) {
  const cookieOptions = {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    expires: new Date(Date.now() + 7*24*60*60*1000)
  };
  res.cookie('refreshToken', token, cookieOptions);
}

//===================Lazy Style Methods=======================================
function createAsArraySchema(req, res, next) {
    const accountSchema = Joi.object({
      title: Joi.string().empty(''),
      firstName: Joi.string().empty(''),
      lastName: Joi.string().empty(''),
      email: Joi.string().email().empty(''),
      password: Joi.string().min(6).empty(''),
      confirmPassword: Joi.string().valid(Joi.ref('password')).empty(''),
      status: Joi.string().valid('active', 'deactivated').empty(''),
      role: Joi.string().valid(Role.SuperAdmin, Role.Admin, Role.User, Role.StockroomAdmin, Role.Teacher).empty('')
    });
  
    const schema = Joi.alternatives().try(
      accountSchema,
      Joi.array().items(accountSchema)
    );
  
    validateRequest(req, next, schema);
}
async function createAsArray(req, res, next) {
    try {
      if (Array.isArray(req.body)) {
        const accounts = await Promise.all(req.body.map(data => accountService.create(data)));
        return res.json(accounts);
      }
  
      const account = await accountService.create(req.body);
      res.json(account);
    } catch (err) {
      next(err);
    }
}

================================================================================
File: _controllers\borrow.controller.js
Size: 5.19 kB
================================================================================

const express = require('express');
const router = express.Router();
const Joi = require('joi');

const borrowService = require('_services/borrow.service');
const validateRequest = require('_middlewares/validate-request');
const authorize = require('_middlewares/authorize');
const Role = require('_helpers/role');

router.post('/', authorize(), createSchema, createBorrow);
router.get('/', authorize(), listBorrows);
router.get('/:id', authorize(), getById);

router.post('/:id/approve', authorize(), approveBorrow);
router.post('/:id/decline', authorize(), declineBorrow);
router.post('/:id/cancel', authorize(), cancelBorrow);
router.post('/:id/acquire', authorize(), acquireBorrow);
router.post('/:id/return', authorize(), returnBorrow);
router.post('/:id/accept-return', authorize(), acceptReturnHandler);


module.exports = router;

// Schema for create
function createSchema(req, res, next) {
  const schema = Joi.object({
    roomId: Joi.number().integer().required(),
    itemId: Joi.number().integer().optional().allow(null),
    quantity: Joi.number().integer().min(1).required(),
    note: Joi.string().max(500).optional().allow(null)
  });
  validateRequest(req, next, schema);
}

// handlers
async function createBorrow(req, res, next) {
  try {
    const payload = req.body;
    const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
    const browserInfo = req.headers['user-agent'] || '';

    payload.requesterId = req.user.accountId;
    const created = await borrowService.createBorrow(payload, ipAddress, browserInfo);
    res.status(201).json({ success: true, data: created });
  } catch (err) { next(err); }
}
async function listBorrows(req, res, next) {
  try {
    const where = {};
    if (req.query.status) where.status = req.query.status;
    if (req.query.requesterId) where.requesterId = req.query.requesterId;
    if (req.query.roomId) where.roomId = req.query.roomId;

    const rows = await borrowService.listBorrows({ where });
    res.json({ success: true, data: rows });
  } catch (err) { next(err); }
}
async function getById(req, res, next) {
  try {
    const id = parseInt(req.params.id, 10);
    const r = await borrowService.getById(id);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}

async function cancelBorrow(req, res, next) {
  try {
    const id = Number(req.params.id);
    const user = req.user;
    const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
    const browserInfo = req.headers['user-agent'] || '';

    const updated = await borrowService.cancelBorrow(id, user, ipAddress, browserInfo);
    res.json({ success: true, data: updated });
  } catch (err) {
    next(err);
  }
}

async function approveBorrow(req, res, next) {
  try {
    const id = Number(req.params.id);
    const user = req.user;
    const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
    const browserInfo = req.headers['user-agent'] || '';

    const updated = await borrowService.approveBorrow(id, user, ipAddress, browserInfo);
    res.json({ success: true, data: updated });
  } catch (err) {
    next(err);
  }
}
async function declineBorrow(req, res, next) {
  try {
    const id = Number(req.params.id);
    const user = req.user;
    const { reason } = req.body || {};
    const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
    const browserInfo = req.headers['user-agent'] || '';

    const updated = await borrowService.declineBorrow(id, user, { reason }, ipAddress, browserInfo);
    res.json({ success: true, data: updated });
  } catch (err) {
    next(err);
  }
}

async function acquireBorrow(req, res, next) {
  try {
    const id = Number(req.params.id);
    const user = req.user;
    const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
    const browserInfo = req.headers['user-agent'] || '';

    const updated = await borrowService.acquireBorrow(id, user, ipAddress, browserInfo);
    res.json({ success: true, data: updated });
  } catch (err) {
    next(err);
  }
}
async function returnBorrow(req, res, next) {
  try {
    const id = Number(req.params.id);
    const user = req.user;
    const { note } = req.body || {};
    const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
    const browserInfo = req.headers['user-agent'] || '';

    const updated = await borrowService.returnBorrow(id, user, { note }, ipAddress, browserInfo);
    res.json({ success: true, data: updated });
  } catch (err) {
    next(err);
  }
}

async function acceptReturnHandler(req, res, next) {
  try {
    const id = Number(req.params.id);
    const user = req.user;
    const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
    const browserInfo = req.headers['user-agent'] || '';

    const updated = await borrowService.acceptReturn(id, user, ipAddress, browserInfo);
    res.json({ success: true, data: updated });
  } catch (err) {
    next(err);
  }
}


================================================================================
File: _controllers\qr.controller.js
Size: 13.12 kB
================================================================================

const PDFDocument = require('pdfkit');
const fs          = require('fs');
const express     = require('express');
const router      = express.Router();

const qrService   = require('_services/qr.service'); 
const db          = require('_helpers/db-handler');
const validateRequest   = require('_middlewares/validate-request');
const authorize         = require('_middlewares/authorize');
const Role              = require('_helpers/role');

router.post('/scan',                               authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), scanItem);
router.post('/:stockroomType/unit/:unitId/release', releaseUnit);

router.get('/:stockroomType/:inventoryId/qrcode', getBatchQr);
router.get('/:stockroomType/unit/:unitId/qrcode', qrGeneratorUnit);

router.get('/:stockroomType/room/:roomId/pdf-all', generateAllPdf);
router.get('/:stockroomType/room/:roomId/pdf-units', generateAllUnitsPdf);

router.put('/:stockroomType/unit/:unitId/status', updateUnitStatus);

module.exports = router;

async function getBatchQr(req, res, next) {
  try {
    const stockroomType = String(req.params.stockroomType || '').toLowerCase();
    const inventoryId = Number(req.params.inventoryId);

    const out = await qrService.generateBatchQR({ stockroomType, inventoryId });
    const pngPath = out && (out.absolutePath || out.path || out.filepath);
    if (!pngPath || !fs.existsSync(pngPath)) return res.status(404).json({ message: 'QR not found' });

    res.sendFile(pngPath);
  } catch (err) {
    next(err);
  }
}

async function qrGeneratorUnit(req, res, next) {
  try {
    const stockroomType = req.params.stockroomType; 
    const unitId = parseInt(req.params.unitId, 10);
    if (!stockroomType || Number.isNaN(unitId)) return res.status(400).json({ message: 'Invalid params' });

    const { filename, absolutePath } = await qrService.generateUnitQR({ stockroomType, unitId });
    const buffer = await fs.promises.readFile(absolutePath);
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.type('png').send(buffer);
  } catch (err) { next(err); }
}
async function scanItem(req, res, next) {
  try {
    const { qrId } = req.body;
    const item = await qrService.scanItem(qrId);
    return res.json({ item });
  } catch (err) {
    next(err);
  }
}
async function releaseUnit(req, res, next) {
  try {
    const stockroomType = String(req.params.stockroomType || '').toLowerCase();
    const unitId = parseInt(req.params.unitId, 10);
    const actorId = req.body?.actorId;

    if (!stockroomType || Number.isNaN(unitId)) return res.status(400).json({ message: 'Invalid params' });

    const result = await qrService.releaseUnit(stockroomType, unitId, { actorId });
    return res.json(result);
  } catch (err) { next(err); }
}
async function generateAllPdf(req, res, next) {
  try {
    const stockroomType = String(req.params.stockroomType || '').toLowerCase();
    const roomId = parseInt(req.params.roomId, 10);
    if (!stockroomType || Number.isNaN(roomId)) return res.status(400).json({ message: 'Invalid params' });

    let inventory = [];
    if (stockroomType === 'apparel') {
      inventory = await db.ApparelInventory.findAll({ where: { roomId } });
    } else if (stockroomType === 'supply') {
      inventory = await db.AdminSupplyInventory.findAll({ where: { roomId } });
    } else if (stockroomType === 'genitem' || stockroomType === 'it' || stockroomType === 'maintenance') {
      inventory = await db.GenItemInventory.findAll({ where: { roomId } });
    } else {
      const modelName = stockroomType + 'Inventory';
      if (db[modelName]) inventory = await db[modelName].findAll({ where: { roomId } });
    }

    if (!inventory || inventory.length === 0) {
      return res.status(404).json({ message: 'No inventory found for this room/type' });
    }

    function tryFields(obj, ...keys) {
      if (!obj) return null;
      for (const k of keys) {
        if (obj[k] !== undefined && obj[k] !== null) return obj[k];
        if (obj.dataValues && obj.dataValues[k] !== undefined && obj.dataValues[k] !== null) return obj.dataValues[k];
      }
      return null;
    }

    const qrItems = [];
    for (let idx = 0; idx < inventory.length; idx++) {
      const inv = inventory[idx];
      const invId = tryFields(inv,
        'receiveApparelId', 'apparelInventoryId', 'adminSupplyInventoryId', 'genItemInventoryId', 'id'
      );

      const out = await qrService.generateBatchQR({ stockroomType, inventoryId: invId });
      const pngPath = out && (out.absolutePath || out.path || out.filepath);

      const labelCandidate = tryFields(inv,
        'sku', 'code', 'itemCode', 'apparelSku', 'adminSupplyCode', 'genItemSku',
        'name', 'title', 'apparelName', 'supplyName', 'genItemName', 'itemName',
        'description', 'serialNumber'
      );

      const label = labelCandidate !== null && labelCandidate !== undefined
        ? String(labelCandidate)
        : (invId !== undefined && invId !== null ? String(invId) : `Item #${idx + 1}`);

      if (pngPath) {
        qrItems.push({ imgPath: pngPath, label, invId });
      } else {
        qrItems.push({ imgPath: null, label, invId });
      }
    }

    if (!qrItems.length) {
      return res.status(404).json({ message: 'No QR images generated' });
    }

    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="qrcodes-${stockroomType}-room-${roomId}.pdf"`);

    const doc = new PDFDocument({ autoFirstPage: false, size: 'LETTER', margin: 0 });
    doc.pipe(res);

    const POINTS_PER_INCH = 72;
    const PAGE_WIDTH = 8.5 * POINTS_PER_INCH;
    const PAGE_HEIGHT = 11 * POINTS_PER_INCH;
    const MARGIN = 0.5 * POINTS_PER_INCH;
    const QR_SIDE = 1 * POINTS_PER_INCH;
    const LABEL_HEIGHT = 12;
    const CELL_HEIGHT = QR_SIDE + LABEL_HEIGHT;

    const usableWidth = PAGE_WIDTH - 2 * MARGIN;
    const usableHeight = PAGE_HEIGHT - 2 * MARGIN;

    const cols = Math.max(1, Math.floor(usableWidth / QR_SIDE));
    const rows = Math.max(1, Math.floor(usableHeight / CELL_HEIGHT));
    const perPage = cols * rows;

    const gapX = (usableWidth - cols * QR_SIDE) / (cols + 1);
    const gapY = (usableHeight - rows * CELL_HEIGHT) / (rows + 1);
    const hGap = Math.max(0, gapX);
    const vGap = Math.max(0, gapY);

    doc.font('Helvetica');

    for (let i = 0; i < qrItems.length; i++) {
      const indexInPage = i % perPage;
      if (indexInPage === 0) {
        doc.addPage({ size: 'LETTER', margin: 0 });
      }

      const col = indexInPage % cols;
      const row = Math.floor(indexInPage / cols);

      const x = MARGIN + hGap + col * (QR_SIDE + hGap);
      const y = MARGIN + vGap + row * (CELL_HEIGHT + vGap);

      const { imgPath, label } = qrItems[i];

      if (imgPath && fs.existsSync(imgPath)) {
        try {
          doc.image(imgPath, x, y, { width: QR_SIDE, height: QR_SIDE, align: 'center', valign: 'center' });
        } catch (imgErr) {
          doc.fontSize(8).text('QR image load error', x, y + QR_SIDE / 2 - 4, { width: QR_SIDE, align: 'center' });
        }
      } else {
        doc.fontSize(8).text('QR missing', x, y + QR_SIDE / 2 - 4, { width: QR_SIDE, align: 'center' });
      }

      const labelY = y + QR_SIDE + 4;
      doc.fontSize(10);
      doc.text(label, x, labelY, { width: QR_SIDE, align: 'center' });
    }

    doc.end();
  } catch (err) {
    console.error('generateAllPdf error:', err && err.stack ? err.stack : err);
    return res.status(500).json({ message: 'Internal server error while generating PDF' });
  }
}
async function generateAllUnitsPdf(req, res, next) {
  try {
    const stockroomType = String(req.params.stockroomType || '').toLowerCase();
    const roomId = parseInt(req.params.roomId, 10);
    if (!stockroomType || Number.isNaN(roomId)) return res.status(400).json({ message: 'Invalid params' });

    // load unit rows for room depending on type
    let units = [];
    if (stockroomType === 'apparel') {
      units = await db.Apparel.findAll({ where: { roomId } });
    } else if (stockroomType === 'supply') {
      units = await db.AdminSupply.findAll({ where: { roomId } });
    } else if (stockroomType === 'genitem' || stockroomType === 'it' || stockroomType === 'maintenance') {
      units = await db.GenItem.findAll({ where: { roomId } });
    } else {
      // try generic model name (singular)
      const modelName = stockroomType.charAt(0).toUpperCase() + stockroomType.slice(1);
      if (db[modelName]) units = await db[modelName].findAll({ where: { roomId } });
    }

    if (!units || units.length === 0) return res.status(404).json({ message: 'No units found for this room/type' });

    // small helper to pick candidate label fields
    const tryFields = (obj, ...keys) => {
      if (!obj) return null;
      for (const k of keys) {
        if (obj[k] !== undefined && obj[k] !== null) return obj[k];
        if (obj.dataValues && obj.dataValues[k] !== undefined && obj.dataValues[k] !== null) return obj.dataValues[k];
      }
      return null;
    };

    // build QR item list (generate per-unit PNG if needed)
    const qrItems = [];
    for (let u of units) {
      const unitId = tryFields(u, 'id', 'apparelId', 'adminSupplyId', 'genItemId') || null;
      if (!unitId) continue;
      const out = await qrService.generateUnitQR({ stockroomType, unitId });
      const pngPath = out && (out.absolutePath || out.path || out.filepath) || null;

      const labelCandidate = tryFields(u,
        'name','apparelName','supplyName','genItemName','sku','code','serialNumber','description'
      );
      const label = labelCandidate ? String(labelCandidate) : `Unit #${unitId}`;

      qrItems.push({ imgPath: pngPath, label, unitId });
    }

    if (!qrItems.length) return res.status(404).json({ message: 'No QR images generated' });

    // --- PDF layout (same simple grid used in generateAllPdf) ---
    const doc = new PDFDocument({ autoFirstPage: false, size: 'LETTER', margin: 0 });
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="qrcodes-${stockroomType}-room-${roomId}-units.pdf"`);
    doc.pipe(res);

    const POINTS_PER_INCH = 72;
    const PAGE_WIDTH = 8.5 * POINTS_PER_INCH;
    const PAGE_HEIGHT = 11 * POINTS_PER_INCH;
    const MARGIN = 0.5 * POINTS_PER_INCH;
    const QR_SIDE = 1 * POINTS_PER_INCH;
    const LABEL_HEIGHT = 12;
    const CELL_HEIGHT = QR_SIDE + LABEL_HEIGHT;

    const usableWidth = PAGE_WIDTH - 2 * MARGIN;
    const usableHeight = PAGE_HEIGHT - 2 * MARGIN;

    const cols = Math.max(1, Math.floor(usableWidth / QR_SIDE));
    const rows = Math.max(1, Math.floor(usableHeight / CELL_HEIGHT));
    const perPage = cols * rows;

    const gapX = (usableWidth - cols * QR_SIDE) / (cols + 1);
    const gapY = (usableHeight - rows * CELL_HEIGHT) / (rows + 1);
    const hGap = Math.max(0, gapX);
    const vGap = Math.max(0, gapY);

    doc.font('Helvetica');

    for (let i = 0; i < qrItems.length; i++) {
      const indexInPage = i % perPage;
      if (indexInPage === 0) doc.addPage({ size: 'LETTER', margin: 0 });

      const col = indexInPage % cols;
      const row = Math.floor(indexInPage / cols);
      const x = MARGIN + hGap + col * (QR_SIDE + hGap);
      const y = MARGIN + vGap + row * (CELL_HEIGHT + vGap);

      const { imgPath, label } = qrItems[i];

      if (imgPath && fs.existsSync(imgPath)) {
        try { doc.image(imgPath, x, y, { width: QR_SIDE, height: QR_SIDE }); }
        catch (imgErr) { doc.fontSize(8).text('QR image load error', x, y + QR_SIDE / 2 - 4, { width: QR_SIDE, align: 'center' }); }
      } else {
        doc.fontSize(8).text('QR missing', x, y + QR_SIDE / 2 - 4, { width: QR_SIDE, align: 'center' });
      }

      const labelY = y + QR_SIDE + 4;
      doc.fontSize(10).text(label, x, labelY, { width: QR_SIDE, align: 'center' });
    }

    doc.end();
  } catch (err) {
    console.error('generateAllUnitsPdf error:', err && err.stack ? err.stack : err);
    return res.status(500).json({ message: 'Internal server error while generating units PDF' });
  }
}


async function updateUnitStatus(req, res, next) {
  try {
    const stockroomType = String(req.params.stockroomType || '').toLowerCase();
    const unitId = parseInt(req.params.unitId, 10);
    const { status } = req.body;
    const actorId = req.body?.actorId || null;

    if (!stockroomType || Number.isNaN(unitId)) return res.status(400).json({ message: 'Invalid params' });
    if (!status) return res.status(400).json({ message: 'Missing status in body' });

    const result = await qrService.updateItemStatus(stockroomType, Number(unitId), status, { actorId });
    return res.json({ success: true, result });
  } catch (err) {
    next(err);
  }
}

================================================================================
File: _controllers\request.item.controller.js
Size: 7.65 kB
================================================================================

const express = require('express');
const router  = express.Router();
const Joi     = require('joi');

const itemRequestService  = require('_services/request.item.service');
const validateRequest     = require('_middlewares/validate-request');
const authorize           = require('_middlewares/authorize');
const Role                = require('_helpers/role');

router.post('/', authorize([Role.SuperAdmin, Role.Teacher, Role.User]), createSchema, createRequest);

router.get('/',     authorize([Role.SuperAdmin, Role.StockroomAdmin, Role.Teacher, Role.User]), listRequests);
router.get('/:id',  authorize([Role.SuperAdmin, Role.StockroomAdmin, Role.Teacher, Role.User]), getRequestById);

router.post('/:id/accept',  authorize([Role.SuperAdmin, Role.StockroomAdmin]), acceptRequest);
router.post('/:id/decline', authorize([Role.SuperAdmin, Role.StockroomAdmin]), declineRequest);
router.post('/:id/release', authorize([Role.SuperAdmin, Role.StockroomAdmin]), releaseRequest);

router.post('/:id/fulfill', authorize([Role.SuperAdmin, Role.Teacher, Role.User]), fulfillRequest);

module.exports = router;

function _extractIpAndBrowser(req) {
  const ipAddress = req.headers['x-forwarded-for'] || req.connection?.remoteAddress || req.ip || 'Unknown IP';
  const browserInfo = req.headers['user-agent'] || 'Unknown Browser';
  return { ipAddress, browserInfo };
}

// Schemas
function createSchema(req, res, next) {
  const schema = Joi.object({
    requesterRoomId: Joi.number().integer().required(),
    requestToRoomId: Joi.number().integer().required(),
    itemId: Joi.number().integer().required(),
    quantity: Joi.number().integer().min(1).required(),
    note: Joi.string().max(500).allow('', null).optional()
  });
  validateRequest(req, next, schema);
}

// Handlers
function isUserInCharge(room, accountId) {
  if (!room || !accountId) return false;
  const possibleFields = ['inChargeId','inChargeUserId','roomInCharge','managerId','accountId','createdBy'];
  for (const f of possibleFields) {
    if (typeof room[f] !== 'undefined' && String(room[f]) === String(accountId)) return true;
  }
  // also allow an array of users in charge stored as 'inChargeUsers' (comma-separated or array)
  if (room.inChargeUsers) {
    if (Array.isArray(room.inChargeUsers) && room.inChargeUsers.map(String).includes(String(accountId))) return true;
    if (typeof room.inChargeUsers === 'string' && room.inChargeUsers.split(',').map(s => s.trim()).includes(String(accountId))) return true;
  }
  return false;
}
async function createRequest(req, res) {
  try {
    const payload = req.body || {};
    const { ipAddress, browserInfo } = _extractIpAndBrowser(req);

    const accountId = req.user && req.user.accountId;
    if (!accountId) return res.status(401).json({ message: 'Unauthenticated' });

    // ensure the requesterRoom exists
    const requesterRoom = await db.Room.findByPk(payload.requesterRoomId);
    if (!requesterRoom) return res.status(400).json({ message: 'Invalid requesterRoomId' });

    // user must be in charge of the requesterRoom
    if (!isUserInCharge(requesterRoom, accountId)) {
      return res.status(403).json({ message: 'You are not authorized as requester for the selected room' });
    }

    // ensure the requestToRoom exists
    const requestToRoom = await db.Room.findByPk(payload.requestToRoomId);
    if (!requestToRoom) return res.status(400).json({ message: 'Invalid requestToRoomId' });

    // NEW: only allow requestToRoom whose roomType is 'stockroom' or 'substockroom'
    const rt = String(requestToRoom.roomType || '').toLowerCase();
    if (!['stockroom', 'substockroom'].includes(rt)) {
      return res.status(403).json({ message: 'You can only request from rooms with roomType \"stockroom\" or \"substockroom\"' });
    }

    // delegate to service — service will validate item belongs to requestToRoom, infer itemType, create record
    const created = await itemRequestService.createItemRequest({
      accountId,
      requesterRoomId: Number(payload.requesterRoomId),
      requestToRoomId: Number(payload.requestToRoomId),
      itemId: Number(payload.itemId),
      quantity: Number(payload.quantity),
      note: payload.note || null,
      ipAddress, browserInfo
    });

    return res.status(201).json({ success: true, data: created });
  } catch (err) {
    console.error('createItemRequestHandler error', err);
    const status = (err && err.status) || 500;
    const message = (err && err.message) || 'Server error';
    return res.status(status).json({ message });
  }
}

async function listRequests(req, res, next) {
  try {
    const where = {};
    if (req.query.status) where.status = req.query.status;
    if (req.query.accountId) where.accountId = req.query.accountId;
    const rows = await itemRequestService.listItemRequests({ where });
    res.json({ success: true, data: rows });
  } catch (err) { next(err); }
}
async function getRequestById(req, res, next) {
  try {
    const r = await itemRequestService.getItemRequestById(parseInt(req.params.id, 10));
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}
async function acceptRequest(req, res, next) {
  try {
    const { ipAddress, browserInfo } = _extractIpAndBrowser(req);

    const r = await itemRequestService.acceptItemRequest(parseInt(req.params.id, 10), req.user.accountId, ipAddress, browserInfo);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}
async function declineRequest(req, res, next) {
  try {
    const reason = req.body.reason || null;
    const { ipAddress, browserInfo } = _extractIpAndBrowser(req);

    const r = await itemRequestService.declineItemRequest(parseInt(req.params.id, 10), req.user.accountId, reason, ipAddress, browserInfo);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}
// async function releaseRequest(req, res, next) {
//   try {
//     const releaserId = req.user && req.user.accountId;
//     const { ipAddress, browserInfo } = _extractIpAndBrowser(req);

//     if (!releaserId) return res.status(401).json({ success: false, message: 'Unauthenticated' });
//     const id = parseInt(req.params.id, 10);
//     const result = await itemRequestService.releaseItemRequest(id, releaserId, ipAddress, browserInfo);
//     res.json({ success: true, data: result });
//   } catch (err) { next(err); }
// }
// async function fulfillRequest(req, res, next) {
//   try {
//     const { ipAddress, browserInfo } = _extractIpAndBrowser(req);

//     const r = await itemRequestService.fulfillItemRequest(parseInt(req.params.id, 10), req.user.accountId, ipAddress, browserInfo);
//     res.json({ success: true, data: r });
//   } catch (err) { next(err); }
// }
async function releaseRequest(req, res, next) {
  try {
    const id = req.params.id;
    const ip = req.headers['x-forwarded-for'] || req.ip || req.socket?.remoteAddress || '';
    const browser = req.get('User-Agent') || '';
    const result = await itemRequestService.releaseItemRequest(id, req.user, ip, browser);
    res.json(result);
  } catch (err) {
    next(err);
  }
}

async function fulfillRequest(req, res, next) {
  try {
    const id = req.params.id;
    const ip = req.headers['x-forwarded-for'] || req.ip || req.socket?.remoteAddress || '';
    const browser = req.get('User-Agent') || '';
    const result = await itemRequestService.fulfillItemRequest(id, req.user, ip, browser);
    res.json(result);
  } catch (err) {
    next(err);
  }
}


================================================================================
File: _controllers\request.stock.controller.js
Size: 5.18 kB
================================================================================

const express = require('express');
const router  = express.Router();
const Joi     = require('joi');

const validateRequest = require('_middlewares/validate-request');
const authorize       = require('_middlewares/authorize');
const Role            = require('_helpers/role');
const stockService    = require('_services/request.stock.service');
const roomService     = require('_services/room.service');

router.post('/',  authorize([Role.SuperAdmin, Role.StockroomAdmin]),              createSchema, createStockRequestHandler);
router.get('/',   authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]),  listRequests);

router.get('/:stockRequestId',  authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getRequestById);

router.post('/:id/approve',     authorize([Role.SuperAdmin, Role.Admin]),           approveRequest);
router.post('/:id/disapprove',  authorize([Role.SuperAdmin, Role.Admin]),           disapproveRequest);
router.post('/:id/fulfill',     authorize([Role.SuperAdmin, Role.StockroomAdmin]),  fulfillRequest);

module.exports = router;

function _extractIpAndBrowser(req) {
  const ipAddress = req.headers['x-forwarded-for'] || req.connection?.remoteAddress || req.ip || 'Unknown IP';
  const browserInfo = req.headers['user-agent'] || 'Unknown Browser';
  return { ipAddress, browserInfo };
}

function createSchema(req, res, next) {
  // accountId and itemType removed from client payload
  const schema = Joi.object({
    requesterRoomId: Joi.number().integer().required(),
    itemId: Joi.number().integer().required(),
    quantity: Joi.number().integer().min(1).required(),
    note: Joi.string().max(500).allow('', null).optional(),
  });
  validateRequest(req, next, schema);
}
async function createStockRequestHandler(req, res) {
  try {
    // take accountId from logged-in user
    const payload = req.body || {};
    payload.accountId = req.user && req.user.accountId;

    // basic presence check (validateRequest already checked requesterRoomId is a number)
    if (!payload.accountId) return res.status(401).json({ message: 'Unauthenticated' });

    // verify requesterRoomId exists and is a stockroom (only stockroom-type rooms can create stock requests)
    const room = await db.Room.findByPk(payload.requesterRoomId);
    if (!room) return res.status(400).json({ message: 'Invalid requesterRoomId' });

    // normalize roomType (some of your code uses roomType fields like 'stockroom' / 'substockroom' / 'room')
    if (String(room.roomType || '').toLowerCase() !== 'stockroom') {
      return res.status(403).json({ message: 'Only rooms with roomType \"stockroom\" can create stock requests' });
    }

    const { ipAddress, browserInfo } = _extractIpAndBrowser(req);

    // delegate to service (service will infer itemType from itemId)
    const created = await stockService.createStockRequest(payload, ipAddress, browserInfo);
    return res.status(201).json({ success: true, data: created });
  } catch (err) {
    console.error('Error in createStockRequestHandler:', err && err.stack ? err.stack : err);
    const status = (err && err.status) || 500;
    const message = (err && (err.message || err.error || err.toString())) || 'Server error';
    return res.status(status).json({ message, details: process.env.NODE_ENV === 'development' ? (err && err.stack ? err.stack : err) : undefined });
  }
}

async function listRequests(req, res, next) {
  try {
    const where = {};
    if (req.query.status) where.status = req.query.status;
    if (req.query.accountId) where.accountId = req.query.accountId;
    const rows = await stockService.listStockRequests({ where });
    res.json({ success: true, data: rows });
  } catch (err) { next(err); }
}
async function getRequestById(req, res, next) {
  try {
    const stockRequestId = parseInt(req.params.stockRequestId, 10);
    const r = await stockService.getStockRequestById(stockRequestId);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}
async function approveRequest(req, res, next) {
  try {
    const id = parseInt(req.params.id, 10);
    const { ipAddress, browserInfo } = _extractIpAndBrowser(req);

    const r = await stockService.approveStockRequest(id, req.user?.accountId, ipAddress, browserInfo);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}
async function disapproveRequest(req, res, next) {
  try {
    const id = parseInt(req.params.id, 10);
    const reason = req.body.reason || null;
    const { ipAddress, browserInfo } = _extractIpAndBrowser(req);

    const r = await stockService.disapproveStockRequest(id, req.user?.accountId, reason, ipAddress, browserInfo);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}
async function fulfillRequest(req, res, next) {
  try {
    const id = parseInt(req.params.id, 10);
    const { ipAddress, browserInfo } = _extractIpAndBrowser(req);

    const r = await stockService.fulfillStockRequest(id, req.user?.accountId, ipAddress, browserInfo);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}

================================================================================
File: _controllers\room.controller.js
Size: 23.27 kB
================================================================================

const express   = require('express');
const router    = express.Router();
const Joi       = require('joi');
const fs        = require('fs');
const path      = require('path');

const roomService       = require('_services/room.service');
const validateRequest   = require('_middlewares/validate-request');
const authorize         = require('_middlewares/authorize');
const Role              = require('_helpers/role');

// POST -------------------------------------------------------------------------------------
router.post('/create-room',               authorize(Role.SuperAdmin), createRoomschema, createRoom);
router.post('/create-array',               authorize(Role.SuperAdmin), createAsArraySchema, createAsArray);
router.post('/:roomId/receive/apparel',   authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), receiveApparelSchema,      receiveApparel);
router.post('/:roomId/receive/supply',    authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), receiveAdminSupplySchema,  receiveAdminSupply);
router.post('/:roomId/receive/item',      authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), receiveGenItemSchema,      receiveGenItem);

router.post('/:roomId/release/apparel',   authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), releaseApparel);
router.post('/:roomId/release/supply',    authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), releaseAdminSupply);
router.post('/:roomId/release/item',      authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), releaseGenItem);
router.post('/:roomId/release',           authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), releaseInStockroom);

// GET & POST ------------------------------------------------------------------------------
router.get('/:roomId/qr/apparel/batch/:inventoryId',      authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getApparelBatchQr);
router.get('/:roomId/qr/admin-supply/batch/:inventoryId', authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getAdminSupplyBatchQr);
router.get('/:roomId/qr/general-item/batch/:inventoryId', authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getGenItemBatchQr);

router.get('/:roomId/qr/apparel/unit/:unitId',            authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getApparelUnitQr);
router.get('/:roomId/qr/admin-supply/unit/:unitId',       authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getAdminSupplyUnitQr);

// GET -------------------------------------------------------------------------------------
router.get('/',         authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin, Role.Teacher, Role.User]), getRooms);
router.get('/list',     listRooms);
router.get('/:roomId/all-units', authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin, Role.Teacher, Role.User]), getAllUnits);
router.get('/:roomId/all-units',
  authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin, Role.Teacher, Role.User]),
  getAllUnits);
router.get('/:roomId',  authorize(), getRoomById);
// Apparel
router.get('/:roomId/receive-apparels',   authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getReceiveApparels);
router.get('/:roomId/apparels',           authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin, Role.Teacher, Role.User]), getApparelUnits);
router.get('/:roomId/apparel-inventory',  authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getApparelInventory);
router.get('/:roomId/release-apparels',   authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getReleaseApparels);
// Admin Supply
router.get('/:roomId/receive-supply',     authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getReceiveAdminSupply);
router.get('/:roomId/supply',             authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin, Role.Teacher, Role.User]), getAdminSupplyUnits);
router.get('/:roomId/supply-inventory',   authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getAdminSupplyInventory);
router.get('/:roomId/release-supply',     authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getReleasedBatchAdminSupply);
// General Items
router.get('/:roomId/receive-items',      authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getReceiveGenItem);
router.get('/:roomId/items',              authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin, Role.Teacher, Role.User]), getGenItemUnits);
router.get('/:roomId/items-inventory',    authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getGenItemInventory);
router.get('/:roomId/release-items',      authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getReleasedGenItems);

// PUT -------------------------------------------------------------------------------------
router.put('/:roomId',  authorize(Role.SuperAdmin),  updateRoomSchema, updateRoom);
router.put('/:roomId/apparel/unit/:unitId', authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), updateApparelUnit);

function resolveQrFilePath(result) {
  if (!result) return null;
  if (result.absolutePath && fs.existsSync(result.absolutePath)) return path.resolve(result.absolutePath);

  const projectRoot = path.join(__dirname, '../uploads');
  const try1 = path.join(projectRoot, 'uploads', 'qrcodes', result.filename || '');
  if (fs.existsSync(try1)) return try1;

  const try2 = path.join(projectRoot, 'uploads', result.filename || '');
  if (fs.existsSync(try2)) return try2;

  return null;
}

module.exports = router;

// Schema's part
function createRoomschema(req, res, next) {
  const schema = Joi.object({
      roomName: Joi.string().required().min(1).max(30),
      roomFloor: Joi.string().required().min(1).max(5),
      roomType: Joi.string().valid('stockroom','subStockroom','office','classroom', 'openarea').required(),
      stockroomType: Joi.string().valid('apparel','supply','general').allow(null).optional(),
      roomInCharge: Joi.number().integer().min(0)
  });
  validateRequest(req, next, schema);
}
function updateRoomSchema(req, res, next) {
  const schema = Joi.object({
    roomName: Joi.string().min(1).max(30).empty(),
    roomFloor: Joi.string().min(1).max(5).empty(),
    roomType: Joi.string().valid('stockroom','subStockroom','office','classroom', 'openarea').empty(''),
    stockroomType: Joi.string().valid('apparel','supply','general').allow(null).empty(),
    roomInCharge: Joi.number().integer().min(0).empty()
  });
  validateRequest(req, next, schema);
}
function receiveApparelSchema(req, res, next) {
  const paramsSchema = Joi.object({
    roomId: Joi.number().integer().min(1).required()
  });

  const bodySchema = Joi.object({
    apparelName:      Joi.string().trim().min(1).max(200).required(),
    apparelLevel:     Joi.string().trim().max(50).allow('pre', 'elem', '7', '8', '9', '10', 'sh', 'it', 'hs', 'educ', 'teachers').required(),
    apparelType:      Joi.string().trim().max(50).allow('uniform', 'pe').required(),
    apparelFor:       Joi.string().trim().max(50).allow('boys', 'girls').required(),
    apparelSize:      Joi.string().trim().max(50).allow(
                        '2', '4', '6', '8', '10', 
                        '12', '14', '16', '18', '20', 
                        'xs', 's', 'm', 'l', 'xl', 
                        '2xl', '3xl').required(),
    apparelQuantity:  Joi.number().integer().min(1).required(),

    receivedFrom:     Joi.string().trim().min(1).max(200).required(),
    receivedBy:       Joi.number().integer().min(1).required(),
    
    notes:            Joi.string().trim().allow('', null).optional()
  });

  // validate params first
  const { error: paramsErr } = paramsSchema.validate(req.params);
  if (paramsErr) return next(paramsErr);

  // validate body
  validateRequest(req, next, bodySchema);
}
function receiveAdminSupplySchema(req, res, next) {
  const paramsSchema = Joi.object({
    roomId: Joi.number().integer().min(1).required()
  });

  const bodySchema = Joi.object({
    supplyName:     Joi.string().trim().min(1).max(200).required(),
    supplyQuantity: Joi.number().integer().min(1).required(),
    supplyMeasure:  Joi.string().trim().max(50).allow(
                      'pc', 'box', 'bottle', 'pack', 'ream', 
                      'meter', 'roll', 'gallon', 'unit', 'educ', 
                      'teachers').required(),
    receivedFrom:   Joi.string().trim().min(1).max(200).required(),
    receivedBy:     Joi.number().integer().min(1).required(),

    notes:          Joi.string().trim().allow('', null).optional()
  });

  const { error: paramsErr } = paramsSchema.validate(req.params);
  if (paramsErr) return next(paramsErr);

  validateRequest(req, next, bodySchema);
}
function receiveGenItemSchema(req, res, next) {
  const paramsSchema = Joi.object({
    roomId: Joi.number().integer().min(1).required()
  });

  const bodySchema = Joi.object({
    genItemName:      Joi.string().trim().min(1).max(200).required(),
    genItemSize:      Joi.string().trim().max(50).allow('', null).optional(),
    genItemQuantity:  Joi.number().integer().min(1).required(),
    genItemType:      Joi.string().lowercase().valid('it','maintenance','unknownType').required(),

    receivedFrom:     Joi.string().trim().min(1).max(200).required(),
    receivedBy:       Joi.number().integer().min(1).required(),
    
    notes:            Joi.string().trim().allow('', null).optional()
  });

  const { error: paramsErr } = paramsSchema.validate(req.params);
  if (paramsErr) return next(paramsErr);

  validateRequest(req, next, bodySchema);
}

// Management part
function createRoom(req, res, next) {
  const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
  const browserInfo = req.headers['user-agent'] || '';

  roomService.createRoomHandler(req.body, req.user, ipAddress, browserInfo)
    .then(created => res.status(201).json(created))
    .catch(next);
}
function updateRoom(req, res, next) {
  const roomId = Number(req.params.roomId);
  const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
  const browserInfo = req.headers['user-agent'] || '';

  roomService.updateRoomHandler(roomId, req.body, req.user, ipAddress, browserInfo)
    .then(updated => res.json(updated))
    .catch(next);
}
function getRooms(req, res, next) {
  roomService.getRoomsHandler(req.user)
    .then(rooms => res.json(rooms))
    .catch(next);
}
function getRoomById(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getRoomByIdHandler(roomId, req.user)
    .then(room => res.json(room))
    .catch(next);
}

// Receive part
async function receiveApparel(req, res, next) {
  try {
    const roomId = parseInt(req.params.roomId, 10);
    const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
    const browserInfo = req.headers['user-agent'] || '';

    const result = await roomService.receiveApparelInRoomHandler(roomId, req.body, req.user, ipAddress, browserInfo);
    res.status(201).json(result);
  } catch (err) { next(err); }
}
async function receiveAdminSupply(req, res, next) {
  try {
    const roomId = parseInt(req.params.roomId, 10);
    const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
    const browserInfo = req.headers['user-agent'] || '';

    const result = await roomService.receiveAdminSupplyInRoomHandler(roomId, req.body, req.user, ipAddress, browserInfo);
    res.status(201).json(result);
  } catch (err) { next(err); }
}
async function receiveGenItem(req, res, next) {
  try {
    const roomId = parseInt(req.params.roomId, 10);
    const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
    const browserInfo = req.headers['user-agent'] || '';

    const result = await roomService.receiveGenItemInRoomHandler(roomId, req.body, req.user, ipAddress, browserInfo);
    res.status(201).json(result);
  } catch (err) { next(err); }
}

// Release part
async function releaseInStockroom(req, res, next) {
  try {
    const roomId = parseInt(req.params.roomId, 10);
    if (req.body.releaseQuantity != null && req.body.releaseApparelQuantity == null) {
      req.body.releaseApparelQuantity = req.body.releaseQuantity;
    }
    if (req.body.claimedBy == null) {
      req.body.claimedBy = req.user?.id ? String(req.user.id) : '';
    }
    const result = await roomService.releaseInStockroomHandler(roomId, req.body);
    res.status(201).json(result);
  } catch (err) { next(err); }
}
async function releaseApparel(req, res, next) {
  try {
    const roomId = parseInt(req.params.roomId, 10);
    const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
    const browserInfo = req.headers['user-agent'] || '';

    if (req.body.releaseQuantity != null && req.body.releaseApparelQuantity == null) {
      req.body.releaseApparelQuantity = req.body.releaseQuantity;
    }

    if (req.body.claimedBy == null) {
      req.body.claimedBy = req.user?.id ? String(req.user.id) : '';
    }
    if (req.body.releasedBy == null) {
      req.body.releasedBy = req.user?.id ? String(req.user.id) : '';
    }

    const result = await roomService.releaseApparelInRoomHandler(roomId, req.body, req.user, ipAddress, browserInfo);
    res.status(201).json(result);
  } catch (err) {
    next(err);
  }
}
async function releaseAdminSupply(req, res, next) {
  try {
    const roomId = parseInt(req.params.roomId, 10);
    const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
    const browserInfo = req.headers['user-agent'] || '';

    if (req.body.releaseQuantity != null && req.body.releaseAdminSupplyQuantity == null) {
      req.body.releaseAdminSupplyQuantity = req.body.releaseQuantity;
    }

    if (req.body.claimedBy == null) {
      req.body.claimedBy = req.user?.id ? String(req.user.id) : '';
    }
    if (req.body.releasedBy == null) {
      req.body.releasedBy = req.user?.id ? String(req.user.id) : '';
    }

    const result = await roomService.releaseAdminSupplyInRoomHandler(roomId, req.body, req.user, ipAddress, browserInfo);
    res.status(201).json(result);
  } catch (err) {
    next(err);
  }
}
async function releaseGenItem(req, res, next) {
  try {
    const roomId = parseInt(req.params.roomId, 10);
    const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
    const browserInfo = req.headers['user-agent'] || '';

    if (req.body.releaseQuantity != null && req.body.releaseItemQuantity == null) {
      req.body.releaseItemQuantity = req.body.releaseQuantity;
    }

    if (req.body.claimedBy == null) {
      req.body.claimedBy = req.user?.id ? String(req.user.id) : '';
    }
    if (req.body.releasedBy == null) {
      req.body.releasedBy = req.user?.id ? String(req.user.id) : '';
    }

    const result = await roomService.releaseGenItemInRoomHandler(roomId, req.body, req.user, ipAddress, browserInfo);
    res.status(201).json(result);
  } catch (err) {
    next(err);
  }
}

// Get Received part
function getReceiveApparels(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getReceiveApparelsByRoomHandler(roomId)
    .then(batches => res.json(batches))
    .catch(next);
}
function getApparelUnits(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getApparelUnitsByRoomHandler(roomId)
    .then(units => res.json(units))
    .catch(next);
}
function getApparelInventory(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getApparelInventoryByRoomHandler(roomId)
    .then(inventory => res.json(inventory))
    .catch(next);
}

function getReceiveAdminSupply(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getReceiveAdminSupplyByRoomHandler(roomId)
    .then(batches => res.json(batches))
    .catch(next);
}
function getAdminSupplyUnits(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getAdminSupplyUnitsByRoomHandler(roomId)
    .then(units => res.json(units))
    .catch(next);
}
function getAdminSupplyInventory(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getAdminSupplyInventoryByRoomHandler(roomId)
    .then(inventory => res.json(inventory))
    .catch(next);
}

function getReceiveGenItem(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getReceiveGenItemByRoomHandler(roomId)
    .then(batches => res.json(batches))
    .catch(next);
}
function getGenItemUnits(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getGenItemUnitsByRoomHandler(roomId)
    .then(units => res.json(units))
    .catch(next);
}
function getGenItemInventory(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getGenItemInventoryByRoomHandler(roomId)
    .then(inventory => res.json(inventory))
    .catch(next);
}

// Get Relesed Apparels part
function getReleaseApparels(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getReleaseApparelsByRoomHandler(roomId)
    .then(batches => res.json(batches))
    .catch(next);
}
function getReleasedBatchAdminSupply(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getReleasedBatchAdminSupplyByRoomHandler(roomId)
    .then(batches => res.json(batches))
    .catch(next);
}
function getReleasedGenItems(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getReleasedGenItemByRoomHandler(roomId)
    .then(batches => res.json(batches))
    .catch(next);
}

// Generate and Get QR Code part
async function getApparelBatchQr(req, res, next) {
  try {
    const roomId = req.params.roomId;
    const inventoryId = req.params.inventoryId;

    const result = await roomService.generateApparelBatchForRoom(roomId, inventoryId);

    const absolute = resolveQrFilePath(result);
    if (!absolute) return res.status(404).json({ message: 'QR file not found' });

    return res.type('png').sendFile(absolute);
  } catch (err) {
    if (err && err.status && err.message)
      return res.status(err.status).json({ message: err.message });
    next(err);
  }
}
async function getAdminSupplyBatchQr(req, res, next) {
  try {
    const roomId = req.params.roomId;
    const inventoryId = req.params.inventoryId;

    const result = await roomService.generateAdminSupplyBatchForRoom(roomId, inventoryId);

    const absolute = resolveQrFilePath(result);
    if (!absolute) return res.status(404).json({ message: 'QR file not found' });

    return res.type('png').sendFile(absolute);
  } catch (err) {
    if (err && err.status && err.message)
      return res.status(err.status).json({ message: err.message });
    next(err);
  }
}
async function getGenItemBatchQr(req, res, next) {
  try {
    const roomId = req.params.roomId;
    const inventoryId = req.params.inventoryId;

    const result = await roomService.generateGenItemBatchForRoom(roomId, inventoryId);

    const absolute = resolveQrFilePath(result);
    if (!absolute) return res.status(404).json({ message: 'QR file not found' });

    return res.type('png').sendFile(absolute);
  } catch (err) {
    if (err && err.status && err.message)
      return res.status(err.status).json({ message: err.message });
    next(err);
  }
}


async function getApparelUnitQr(req, res, next) {
  try {
    const roomId = req.params.roomId;
    const unitId = req.params.unitId;

    const result = await roomService.generateApparelUnitForRoom(roomId, unitId);

    const absolute = resolveQrFilePath(result);
    if (!absolute) return res.status(404).json({ message: 'QR file not found' });

    return res.type('png').sendFile(absolute);
  } catch (err) {
    if (err && err.status && err.message)
      return res.status(err.status).json({ message: err.message });
    next(err);
  }
}
async function getAdminSupplyUnitQr(req, res, next) {
  try {
    const roomId = req.params.roomId;
    const unitId = req.params.unitId;

    const result = await roomService.generateAdminSupplyUnitForRoom(roomId, unitId);

    const absolute = resolveQrFilePath(result);
    if (!absolute) return res.status(404).json({ message: 'QR file not found' });

    return res.type('png').sendFile(absolute);
  } catch (err) {
    if (err && err.status && err.message)
      return res.status(err.status).json({ message: err.message });
    next(err);
  }
}

//===================Lazy Style Methods=======================================
function createAsArraySchema(req, res, next) {
  const roomSchema = Joi.object({
    roomName: Joi.string().required().min(1).max(30),
    roomFloor: Joi.string().required().min(1).max(5),
    roomType: Joi.string()
      .valid('stockroom', 'subStockroom', 'office', 'classroom', 'openarea')
      .required(),
    stockroomType: Joi.string()
      .valid('apparel', 'supply', 'general')
      .allow(null)
      .optional(),
    roomInCharge: Joi.number().integer().min(0),
    description: Joi.string().allow('', null)
  });

  const schema = Joi.alternatives().try(
    roomSchema,
    Joi.array().items(roomSchema)
  );

  validateRequest(req, next, schema);
}
async function createAsArray(req, res, next) {
  try {
    if (Array.isArray(req.body)) {
      const createdRooms = await Promise.all(
        req.body.map(room => roomService.createRoomHandler(room, req.user))
      );
      return res.status(201).json(createdRooms);
    }

    const created = await roomService.createRoomHandler(req.body, req.user);
    res.status(201).json(created);
  } catch (err) {
    next(err);
  }
}

function listRooms(req, res, next) {
  roomService.listRoomsHandler()
    .then(rooms => res.json(rooms))
    .catch(next);
}
function getItemsByRoom(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getItemsByRoomHandler(roomId)
    .then(rows => res.json(rows))
    .catch(next);
}


async function updateApparelUnit(req, res, next) {
  try {
    const roomId = parseInt(req.params.roomId, 10);
    const unitId = parseInt(req.params.unitId, 10);
    const { description, status } = req.body;

    if (!Number.isFinite(roomId) || !Number.isFinite(unitId)) {
      return res.status(400).json({ message: 'Invalid params' });
    }

    // delegate to service (keeps controller thin)
    const updated = await roomService.updateApparelUnitByRoomHandler(roomId, unitId, { description, status }, req.user);
    return res.json({ success: true, data: updated });
  } catch (err) {
    next(err);
  }
}

function getAllUnits(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getAllUnitsByRoomHandler(roomId)
    .then(units => res.json(units))
    .catch(next);
}

================================================================================
File: _controllers\transfer.controller.js
Size: 5.33 kB
================================================================================

const express = require('express');
const router  = express.Router();
const Joi     = require('joi');

const transferService = require('_services/transfer.service');
const validateRequest = require('_middlewares/validate-request');
const authorize       = require('_middlewares/authorize');
const Role            = require('_helpers/role');

router.post('/', authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin, Role.Teacher]), createSchema, createTransfer);

router.get('/',     authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin, Role.Teacher]), listTransfers);
router.get('/:id',  authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin, Role.Teacher]), getById);

router.post('/:id/accept', authorize(), acceptTransfer);

module.exports = router;

// Schemas
function createSchema(req, res, next) {
  const schema = Joi.object({
    fromRoomId: Joi.number().integer().required(),
    toRoomId: Joi.number().integer().required(),
    itemId: Joi.number().integer().required(),
    quantity: Joi.number().integer().min(1).required(),
    note: Joi.string().max(500).allow('', null).optional()
  });
  validateRequest(req, next, schema);
}

// Handlers
async function createTransfer(req, res) {
  try {
    const payload = req.body || {};
    const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
    const browserInfo = req.headers['user-agent'] || '';

    const createdBy = req.user && req.user.accountId;
    if (!createdBy) return res.status(401).json({ message: 'Unauthenticated' });

    // ensure fromRoom exists
    const fromRoom = await db.Room.findByPk(payload.fromRoomId);
    if (!fromRoom) return res.status(400).json({ message: 'Invalid fromRoomId' });

    // requester must be in charge of fromRoom
    if (!isUserInCharge(fromRoom, createdBy)) {
      return res.status(403).json({ message: 'You are not authorized to transfer from the selected room' });
    }

    // ensure toRoom exists
    const toRoom = await db.Room.findByPk(payload.toRoomId);
    if (!toRoom) return res.status(400).json({ message: 'Invalid toRoomId' });

    // NEW: only allow toRoom whose roomType is 'stockroom' or 'substockroom'
    const tr = String(toRoom.roomType || '').toLowerCase();
    if (!['stockroom', 'substockroom'].includes(tr)) {
      return res.status(403).json({ message: 'Transfers are allowed only to rooms with type \"stockroom\" or \"substockroom\"' });
    }

    // delegate to service
    const created = await transferService.createTransfer({
      createdBy,
      fromRoomId: Number(payload.fromRoomId),
      toRoomId: Number(payload.toRoomId),
      itemId: Number(payload.itemId),
      quantity: Number(payload.quantity),
      note: payload.note || null,
      ipAddress, browserInfo
    });

    return res.status(201).json({ success: true, data: created });
  } catch (err) {
    console.error('createTransferHandler error', err);
    const status = (err && err.status) || 500;
    const message = (err && err.message) || 'Server error';
    return res.status(status).json({ message });
  }
}
function isUserInCharge(room, accountId) {
  if (!room || !accountId) return false;
  const possibleFields = ['inChargeId','inChargeUserId','roomInCharge','managerId','accountId','createdBy'];
  for (const f of possibleFields) {
    if (typeof room[f] !== 'undefined' && String(room[f]) === String(accountId)) return true;
  }
  if (room.inChargeUsers) {
    if (Array.isArray(room.inChargeUsers) && room.inChargeUsers.map(String).includes(String(accountId))) return true;
    if (typeof room.inChargeUsers === 'string' && room.inChargeUsers.split(',').map(s => s.trim()).includes(String(accountId))) return true;
  }
  return false;
}
async function listTransfers(req, res, next) {
  try {
    const where = {};
    if (req.query.status) where.status = req.query.status;
    const rows = await transferService.listTransfers({ where });
    res.json({ success: true, data: rows });
  } catch (err) { next(err); }
}
async function getById(req, res, next) {
  try {
    const tr = await transferService.getById(parseInt(req.params.id, 10));
    res.json({ success: true, data: tr });
  } catch (err) { next(err); }
}
// async function acceptTransfer(req, res, next) {
//   try {
//     const id = parseInt(req.params.id, 10);
//     const ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || '';
//     const browserInfo = req.headers['user-agent'] || '';

//     // pass both accountId and role so service can decide authorization
//     const r = await transferService.acceptTransfer(id, req.user.accountId, req.user.role, ipAddress, browserInfo);
//     res.json({ success: true, data: r });
//   } catch (err) { next(err); }
// }
async function acceptTransfer(req, res, next) {
  try {
    const id = parseInt(req.params.id, 10);
    // pass ip and user-agent for logging
    const ipAddress = req.ip || (req.headers && req.headers['x-forwarded-for']) || '';
    const browserInfo = req.headers?.['user-agent'] || '';
    const r = await transferService.acceptTransfer(id, req.user.accountId, req.user.role, ipAddress, browserInfo);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}

================================================================================
File: _helpers\db-handler.js
Size: 15.58 kB
================================================================================

// const config            = require('config.json');
// const mysql             = require('mysql2/promise');
// const { Sequelize }     = require('sequelize');

// const fs = require('fs');
// const path = require('path');

// module.exports = db = {};

// initialize();
// async function initialize() { 
//     // const { host, port, user, password, database } = config.database;
//     // const connection = await mysql.createConnection({ host, port, user, password });
//     // await connection.query(`CREATE DATABASE IF NOT EXISTS \`${database}\`;`);
//     // await connection.end();
//     // const sequelize = new Sequelize(database, user, password, { host: 'localhost', dialect: 'mysql' });

const config = require('config.json');
const mysql = require('mysql2/promise');
const { Sequelize } = require('sequelize');

module.exports = db = {};

// Environment-aware DB config (env vars override config.json for deployment)
const DB_HOST = process.env.DB_HOST || (config.database && config.database.host) || 'localhost';
const DB_PORT = process.env.DB_PORT ? parseInt(process.env.DB_PORT, 10) : (config.database && config.database.port) || 3306;
const DB_USER = process.env.DB_USER || (config.database && config.database.user) || 'root';
const DB_PASSWORD = process.env.DB_PASSWORD || (config.database && config.database.password) || 'root';
const DB_NAME = process.env.DB_NAME || (config.database && config.database.database) || 'IMP_db';

let sequelize; // declared in module scope so it's available after initialization

initialize();

async function initialize() {
  try {
    const connOptions = {
      host: DB_HOST,
      port: DB_PORT,
      user: DB_USER,
      password: DB_PASSWORD,
    };

    if (process.env.DB_CA) {
      connOptions.ssl = { ca: process.env.DB_CA };
    }

    console.log(`Attempting MySQL connection to ${DB_HOST}:${DB_PORT} as ${DB_USER}`);

    const connection = await mysql.createConnection(connOptions);

    await connection.query(`CREATE DATABASE IF NOT EXISTS \`${DB_NAME}\`;`);
    await connection.end();

    const sequelizeOptions = {
      host: DB_HOST,
      dialect: 'mysql',
      port: DB_PORT,
      logging: false,
    };

    if (process.env.DB_CA) {
      sequelizeOptions.dialectOptions = { ssl: { ca: process.env.DB_CA } };
    }

    sequelize = new Sequelize(DB_NAME, DB_USER, DB_PASSWORD, sequelizeOptions);

    db.sequelize = sequelize;
    db.Sequelize = Sequelize;

// Initialize models and add them to the exported `db` object
db.Room             = require('../_models/room.model')(sequelize);
db.Account          = require('../_models/account.model')(sequelize);
db.ActivityLog      = require('../_models/activitylog.model')(sequelize);
db.RefreshToken     = require('../_models/refresh-token.model')(sequelize);

// Apparel models
db.Apparel            = require('../_models/apparel/apparel.model')(sequelize);
db.ReceiveApparel     = require('../_models/apparel/receiveApparel.model')(sequelize);
db.ReleaseApparel     = require('../_models/apparel/releaseApparel.model')(sequelize);
db.ApparelInventory   = require('../_models/apparel/apparelInventory.model')(sequelize);

// Admin Supply models
db.AdminSupply              = require('../_models/adminSupply/adminSupply.model')(sequelize);
db.ReceiveAdminSupply       = require('../_models/adminSupply/receiveAdminSupply.model')(sequelize);
db.ReleaseAdminSupply      = require('../_models/adminSupply/releaseAdminSupply.model')(sequelize);
db.AdminSupplyInventory     = require('../_models/adminSupply/adminSupplyInventory.model')(sequelize);

// Item models
db.GenItem            = require('../_models/genItem/genItem.model')(sequelize);
db.ReceiveGenItem     = require('../_models/genItem/receiveGenItem.model')(sequelize);
db.ReleaseGenItem     = require('../_models/genItem/releaseGenItem.model')(sequelize);
db.GenItemInventory   = require('../_models/genItem/genItemInventory.model')(sequelize);

// Qr code models
db.Qr = require('../_models/qr.model')(sequelize);

// Request models
db.StockRequest = require('../_models/request/stock.request.model')(sequelize);
db.ItemRequest  = require('../_models/request/item.request.model')(sequelize);

// Transfer models
db.Transfer = require('../_models/transfer.model')(sequelize);
db.Borrow = require('../_models/borrow.model')(sequelize);

    // If any models define associations, call them now
    Object.keys(db).forEach((modelName) => {
      if (db[modelName] && typeof db[modelName].associate === 'function') {
        db[modelName].associate(db);
      }
    });

    // Sync models to DB when in non-production for convenience.
    // WARNING: avoid alter:true in real production; prefer migrations.
    if (process.env.NODE_ENV !== 'production') {
      await sequelize.sync({ alter: true });
      console.log('Sequelize sync finished (alter: true).');
    }

    console.log('Database initialized successfully.');
  } catch (err) {
    console.error('Database initialization FAILED:', err && err.stack ? err.stack : err);
    // Fail fast so deploy logs show the error. Change to retry logic if desired.
    process.exit(1);
  }

dbAssociations();

    await sequelize.sync({ alter: true }); 
    console.log('Sequelize synced.');
}  

function dbAssociations() {
  // ---------------- Account / Auth ----------------
  // Account -> RefreshToken : store JWT refresh tokens for an account (cascade delete)
  db.Account.hasMany(db.RefreshToken, { onDelete: 'CASCADE' });
  db.RefreshToken.belongsTo(db.Account);

  // ---------------- Account / Room ----------------
  // [Label] Account (roomInCharge) -> Room : which account is in charge of a room
  db.Account.hasMany(db.Room, { foreignKey: 'roomInCharge' });
  db.Room.belongsTo(db.Account, { foreignKey: 'roomInCharge' });

  // ---------- APPAREL / BATCH / ROOM associations ----------
  // ReceiveApparel -> Apparel (per-unit), keep alias 'apparel' (matches prior code)
  db.ReceiveApparel.hasMany(db.Apparel, { foreignKey: 'receiveApparelId' });
  db.Apparel.belongsTo(db.ReceiveApparel, { foreignKey: 'receiveApparelId' });

  // ReceiveApparel -> Room (batch belongs to room) and Room -> ReceiveApparel
  db.ReceiveApparel.belongsTo(db.Room, { foreignKey: 'roomId' });
  db.Room.hasMany(db.ReceiveApparel, { foreignKey: 'roomId' });

  // Apparel may optionally belong to a Room directly (if your model has roomId)
  // Keep these so code that queries by Apparel.roomId keeps working if the attribute exists.
  db.Apparel.belongsTo(db.Room, { foreignKey: 'roomId' });
  db.Room.hasMany(db.Apparel, { foreignKey: 'roomId' });

  // ApparelInventory (aggregate) belongs to Room and Room has many ApparelInventory rows
  db.Room.hasMany(db.ApparelInventory, { foreignKey: 'roomId' });
  db.ApparelInventory.belongsTo(db.Room, { foreignKey: 'roomId' });

  // ApparelInventory <-> ReleaseApparel
  db.ApparelInventory.hasMany(db.ReleaseApparel, { foreignKey: 'apparelInventoryId' });
  db.ReleaseApparel.belongsTo(db.ApparelInventory, { foreignKey: 'apparelInventoryId'  });

  // ApparelInventory -> Apparel (optional relation if your model uses apparelInventoryId)
  db.ApparelInventory.hasMany(db.Apparel, { foreignKey: 'apparelInventoryId' });
  db.Apparel.belongsTo(db.ApparelInventory, { foreignKey: 'apparelInventoryId' });

  db.Account.hasMany(db.ReceiveApparel, { foreignKey: 'accountId'});
  db.ReceiveApparel.belongsTo(db.Account, { foreignKey: 'accountId'});

  db.Account.hasMany(db.ReleaseApparel, { foreignKey: 'accountId'});
  db.ReleaseApparel.belongsTo(db.Account, { foreignKey: 'accountId'});

  db.ReleaseApparel.belongsTo(db.Room, { foreignKey: 'roomId' });
  db.Room.hasMany(db.ReleaseApparel, { foreignKey: 'roomId' });

// ---------- ADMIN SUPPLY / BATCH / ROOM associations ----------
  // ReceiveApparel -> Apparel (per-unit), keep alias 'apparel' (matches prior code)
  db.ReceiveAdminSupply.hasMany(db.AdminSupply, { foreignKey: 'receiveAdminSupplyId' });
  db.AdminSupply.belongsTo(db.ReceiveAdminSupply, { foreignKey: 'receiveAdminSupplyId' });

  // ReceiveApparel -> Room (batch belongs to room) and Room -> ReceiveApparel
  db.ReceiveAdminSupply.belongsTo(db.Room, { foreignKey: 'roomId' });
  db.Room.hasMany(db.ReceiveAdminSupply, { foreignKey: 'roomId' });

  // Apparel may optionally belong to a Room directly (if your model has roomId)
  // Keep these so code that queries by Apparel.roomId keeps working if the attribute exists.
  db.AdminSupply.belongsTo(db.Room, { foreignKey: 'roomId' });
  db.Room.hasMany(db.AdminSupply, { foreignKey: 'roomId' });

  // ApparelInventory (aggregate) belongs to Room and Room has many ApparelInventory rows
  db.Room.hasMany(db.AdminSupplyInventory, { foreignKey: 'roomId' });
  db.AdminSupplyInventory.belongsTo(db.Room, { foreignKey: 'roomId' });

  // ApparelInventory <-> ReleaseApparel
  db.AdminSupplyInventory.hasMany(db.ReceiveAdminSupply, { foreignKey: 'adminSupplyInventoryId' });
  db.ReceiveAdminSupply.belongsTo(db.AdminSupplyInventory, { foreignKey: 'adminSupplyInventoryId'  });

  // ApparelInventory -> Apparel (optional relation if your model uses apparelInventoryId)
  db.AdminSupplyInventory.hasMany(db.AdminSupply, { foreignKey: 'adminSupplyInventoryId' });
  db.AdminSupply.belongsTo(db.AdminSupplyInventory, { foreignKey: 'adminSupplyInventoryId' });

  db.Account.hasMany(db.ReceiveAdminSupply, { foreignKey: 'accountId'});
  db.ReceiveAdminSupply.belongsTo(db.Account, { foreignKey: 'accountId'});

  db.Account.hasMany(db.ReleaseAdminSupply, { foreignKey: 'accountId'});
  db.ReleaseAdminSupply.belongsTo(db.Account, { foreignKey: 'accountId'});

  db.ReleaseAdminSupply.belongsTo(db.Room, { foreignKey: 'roomId' });
  db.Room.hasMany(db.ReleaseAdminSupply, { foreignKey: 'roomId' });
















  // ---------- ADMIN SUPPLY associations ----------
  // db.ReceiveAdminSupply.hasMany(db.AdminSupply, { foreignKey: 'receiveAdminSupplyId' });
  // db.AdminSupply.belongsTo(db.ReceiveAdminSupply, { foreignKey: 'receiveAdminSupplyId' });

  // db.Account.hasMany(db.ReceiveAdminSupply, { foreignKey: 'accountId'});
  // db.ReceiveAdminSupply.belongsTo(db.Account, { foreignKey: 'accountId'});

  db.Account.hasMany(db.ReceiveGenItem, { foreignKey: 'accountId'});
  db.ReceiveGenItem.belongsTo(db.Account, { foreignKey: 'accountId'});

  db.ReceiveGenItem.hasMany(db.GenItem, { foreignKey: 'receiveGenItemId' });
  db.GenItem.belongsTo(db.ReceiveGenItem, { foreignKey: 'receiveGenItemId' });

  // db.AdminSupply.belongsTo(db.Room, { foreignKey: 'roomId' });
  // db.Room.hasMany(db.AdminSupply, { foreignKey: 'roomId' });



  // ---------------- STOCK REQUEST associations ----------------
  // StockRequest -> Account (who requested)
  db.Account.hasMany(db.StockRequest, { foreignKey: 'accountId' });
  db.StockRequest.belongsTo(db.Account, { foreignKey: 'accountId' });

  // StockRequest -> Room (which room/stockroom requested it)
  db.Room.hasMany(db.StockRequest, { foreignKey: 'requesterRoomId' });
  db.StockRequest.belongsTo(db.Room, { foreignKey: 'requesterRoomId' });

  db.StockRequest.belongsTo(db.ApparelInventory, { foreignKey: 'itemId', constraints: false });
  db.ApparelInventory.hasMany(db.StockRequest, { foreignKey: 'itemId', constraints: false });

  db.StockRequest.belongsTo(db.AdminSupplyInventory, { foreignKey: 'itemId', constraints: false });
  db.AdminSupplyInventory.hasMany(db.StockRequest, { foreignKey: 'itemId', constraints: false });

  db.StockRequest.belongsTo(db.GenItemInventory, { foreignKey: 'itemId', constraints: false });
  db.GenItemInventory.hasMany(db.StockRequest, { foreignKey: 'itemId', constraints: false });


  
  // ---------- ITEM REQUEST associations ----------
  db.Account.hasMany(db.ItemRequest, { foreignKey: 'accountId' });
  db.ItemRequest.belongsTo(db.Account, { foreignKey: 'accountId' });

  db.Room.hasMany(db.ItemRequest, { foreignKey: 'requesterRoomId' });
  db.ItemRequest.belongsTo(db.Room, { foreignKey: 'requesterRoomId' });

  // Polymorphic-ish itemId (no FK constraints since itemId may map to different tables)
  db.ItemRequest.belongsTo(db.ApparelInventory, { foreignKey: 'itemId', constraints: false });
  db.ApparelInventory.hasMany(db.ItemRequest, { foreignKey: 'itemId', constraints: false });

  db.ItemRequest.belongsTo(db.AdminSupplyInventory, { foreignKey: 'itemId', constraints: false });
  db.AdminSupplyInventory.hasMany(db.ItemRequest, { foreignKey: 'itemId', constraints: false });

  db.ItemRequest.belongsTo(db.GenItemInventory, { foreignKey: 'itemId', constraints: false });
  db.GenItemInventory.hasMany(db.ItemRequest, { foreignKey: 'itemId', constraints: false });



  // ---------- TRANSFER associations ----------
  db.Transfer.belongsTo(db.Account, { foreignKey: 'createdBy' });
  db.Transfer.belongsTo(db.Account, { foreignKey: 'acceptedBy' });    // who accepted transfer
  db.Transfer.belongsTo(db.Account, { foreignKey: 'returningBy' });   // who initiated return

  // Transfer <> Room (rooms)
  db.Transfer.belongsTo(db.Room, { foreignKey: 'fromRoomId', as: 'fromRoom' });
  db.Transfer.belongsTo(db.Room, { foreignKey: 'toRoomId', as: 'toRoom' });

  db.Transfer.belongsTo(db.ApparelInventory, { foreignKey: 'itemId', constraints: false });
  db.Transfer.belongsTo(db.AdminSupplyInventory, { foreignKey: 'itemId', constraints: false });
  db.Transfer.belongsTo(db.GenItemInventory, { foreignKey: 'itemId', constraints: false });



  // ---------- BORROW associations ----------
  // requester -> Borrow
  db.Account.hasMany(db.Borrow, { foreignKey: 'requesterId' });
  db.Borrow.belongsTo(db.Account, { foreignKey: 'requesterId', as: 'requester' });

  db.Account.hasMany(db.Borrow, { foreignKey: 'approvedBy' });
  db.Borrow.belongsTo(db.Account, { foreignKey: 'approvedBy', as: 'approver' });

  db.Account.hasMany(db.Borrow, { foreignKey: 'declinedBy' });
  db.Borrow.belongsTo(db.Account, { foreignKey: 'declinedBy', as: 'decliner' });

  db.Account.hasMany(db.Borrow, { foreignKey: 'cancelledBy' });
  db.Borrow.belongsTo(db.Account, { foreignKey: 'cancelledBy', as: 'canceller' });

  db.Account.hasMany(db.Borrow, { foreignKey: 'acquiredBy' });
  db.Borrow.belongsTo(db.Account, { foreignKey: 'acquiredBy', as: 'acquirer' });

  db.Account.hasMany(db.Borrow, { foreignKey: 'returnedBy' });
  db.Borrow.belongsTo(db.Account, { foreignKey: 'returnedBy', as: 'returner' });

  db.Account.hasMany(db.Borrow, { foreignKey: 'acceptedBy' });
  db.Borrow.belongsTo(db.Account, { foreignKey: 'acceptedBy', as: 'acceptor' });

  // room -> Borrow (owner room)
  db.Room.hasMany(db.Borrow, { foreignKey: 'roomId' });
  db.Borrow.belongsTo(db.Room, { foreignKey: 'roomId', as: 'room' });

  // polymorphic item joins (no FK constraints)
  db.Borrow.belongsTo(db.ApparelInventory, { foreignKey: 'itemId', constraints: false });
  db.ApparelInventory.hasMany(db.Borrow, { foreignKey: 'itemId', constraints: false });

  db.Borrow.belongsTo(db.AdminSupplyInventory, { foreignKey: 'itemId', constraints: false });
  db.AdminSupplyInventory.hasMany(db.Borrow, { foreignKey: 'itemId', constraints: false });

  db.Borrow.belongsTo(db.GenItemInventory, { foreignKey: 'itemId', constraints: false });
  db.GenItemInventory.hasMany(db.Borrow, { foreignKey: 'itemId', constraints: false });
}

================================================================================
File: _helpers\role.js
Size: 156 B
================================================================================

module.exports = {
    SuperAdmin: 'superAdmin',
    Admin: 'admin',
    StockroomAdmin: 'stockroomAdmin',
    Teacher: 'teacher',
    User: 'user',
}

================================================================================
File: _helpers\send-email.js
Size: 1.14 kB
================================================================================

const nodemailer    = require('nodemailer');
const config        = require('config.json');

module.exports = sendEmail;

async function sendEmail({ to, subject, html, from = config.emailFrom }) {
    let transporter;
    if (config.smtpOptions && config.smtpOptions.auth && config.smtpOptions.auth.user && config.smtpOptions.auth.pass) {
      transporter = nodemailer.createTransport(config.smtpOptions);
    } else {
      const testAccount = await nodemailer.createTestAccount();
      transporter = nodemailer.createTransport({
        host: 'smtp.ethereal.email',
        port: 587,
        secure: false,
        auth: {
          user: testAccount.user,
          pass: testAccount.pass,
        },
      });
      console.log('Using dynamic Ethereal test account. Preview emails at URL logged below.');
    }
  
    const info = await transporter.sendMail({ from, to, subject, html });
  
    // If this is a test transport (Ethereal), log the preview URL
    const previewUrl = nodemailer.getTestMessageUrl(info);
    if (previewUrl) console.log('Preview URL: %s', previewUrl);
  
    return info;
  }

================================================================================
File: _helpers\swagger.js
Size: 369 B
================================================================================

const express               = require('express');
const router                = express.Router();
const swaggerUi             = require('swagger-ui-express');
const YAML                  = require('yamljs');
const swaggerDocument       = YAML.load('./swagger.yaml');

router.use('/', swaggerUi.serve, swaggerUi.setup(swaggerDocument));

module.exports = router;

================================================================================
File: _middlewares\authorize.js
Size: 1.36 kB
================================================================================

const { expressjwt: jwt }   = require('express-jwt');
const { secret }            = require('config.json');
const db                    = require('_helpers/db-handler');
const Role                  = require('_helpers/role');

module.exports = authorize;

function authorize(roles = []) {
    if (typeof roles === 'string') {
        roles = [roles];
    }

    return [
        jwt({ secret, algorithms: ['HS256'], requestProperty: 'auth' }),

        async (req, res, next) => {
            try {
                const account = await db.Account.findByPk(req.auth.accountId);
                if (!account) {
                    return res.status(401).json({ message: 'Account no longer exists' });
                }

                if (roles.length && !roles.includes(account.role)) {
                    return res.status(403).json({ message: 'Forbidden: insufficient permissions' });
                }

                req.user = { 
                    accountId: account.accountId, 
                    email: account.email, 
                    role: account.role };
                next();
            } catch (error) {
                console.error('Authorization error:', error);
                res.status(500).json({ message: 'Internal server error during authorization' });
            }
        }
    ];
}

================================================================================
File: _middlewares\error-handler.js
Size: 561 B
================================================================================

//main
module.exports = errorHandler;

function errorHandler(err, req, res, next) {
    switch (true) {
        case typeof err === 'string':
            const is404 = err.toLowerCase().endsWith('not found');
            const statusCode = is404 ? 404 : 400;
            return res.status(statusCode).json({ message: err });
        case err.name === 'UnauthorizedError':
            return res.status(401).json({ message: 'Unauthorized error-handler' });
        default:
            return res.status(500).json({ message: err.message });
    }
}

================================================================================
File: _middlewares\validate-request.js
Size: 436 B
================================================================================

module.exports = validateRequest;

function validateRequest(req, next, schema) {
    const options = {
        abortEarly: false,
        allowUnknown: true,
        stripUnknown: true
    };
    const { error, value } = schema.validate(req.body, options);
    if (error) {
        next(`Validation error: ${error.details.map(x => x.message).join(', ')}`);
    } else {
        req.body = value;
        next();
    }
}


================================================================================
File: _models\account.model.js
Size: 1.81 kB
================================================================================

const { DataTypes } = require('sequelize');

module.exports = model;

function model(sequelize) {
    const attributes = {
        accountId:          { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },

        email:              { type: DataTypes.STRING,   allowNull: false }, 
        passwordHash:       { type: DataTypes.STRING,   allowNull: false }, 
        title:              { type: DataTypes.STRING,   allowNull: false }, 
        firstName:          { type: DataTypes.STRING,   allowNull: false }, 
        lastName:           { type: DataTypes.STRING,   allowNull: false },
        role:               { type: DataTypes.STRING,   allowNull: true }, 
        status:             { type: DataTypes.ENUM(
                                'active', 'deactivated'
                            ), allowNull: false, defaultValue: 'active'},

        verificationToken:  { type: DataTypes.STRING },
        verified:           { type: DataTypes.DATE },
        resetToken:         { type: DataTypes.STRING },
        resetTokenExpires:  { type: DataTypes.DATE },
        passwordReset:      { type: DataTypes.DATE},
        created:            { type: DataTypes.DATE,     allowNull: false, defaultValue: DataTypes.NOW }, 
        updated:            { type: DataTypes.DATE },
        isVerified:         { type: DataTypes.VIRTUAL,
                                get() { return !!(this.verified || this.passwordReset); }
                            },
    };

    const options = { 
        timestamps: false,
        defaultScope: {
            attributes: {exclude: ['passwordHash'] }
        },
        scopes: {
            withHash: { attributes: {}, }
        }
    };

    return sequelize.define('Account', attributes, options);
    
}

================================================================================
File: _models\activitylog.model.js
Size: 673 B
================================================================================

const { DataTypes } = require('sequelize');

module.exports = model;

function model(sequelize) {
    const attributes = {
        activityLogId:  { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        accountId:      { type: DataTypes.INTEGER,  allowNull: false },
        actionType:     { type: DataTypes.STRING,   allowNull: false },
        actionDetails:  { type: DataTypes.TEXT,     allowNull: true },
        timestamp:      { type: DataTypes.DATE,     defaultValue: DataTypes.NOW },
    };

    const options = {
        timestamps: false 
        
    };

    return sequelize.define('ActivityLog', attributes, options);
}

================================================================================
File: _models\adminSupply\adminSupply.model.js
Size: 948 B
================================================================================

const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {

    const attributes = {
        adminSupplyId:          { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:                 { type: DataTypes.INTEGER,  allowNull: false },
        receiveAdminSupplyId:   { type: DataTypes.INTEGER,  allowNull: false },
        // status:                 { type: DataTypes.STRING,   allowNull: false, defaultValue: 'in_stock' },
        status: {
            type: DataTypes.ENUM('good', 'working', 'damage'),
            allowNull: false,
            defaultValue: 'good'
          },
        description:        { type: DataTypes.TEXT, allowNull: true, defaultValue: null },
        adminSupplyInventoryId: { type: DataTypes.INTEGER,  allowNull: false },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('AdminSupply', attributes);
};

================================================================================
File: _models\adminSupply\adminSupplyInventory.model.js
Size: 1.52 kB
================================================================================

/* 
    - this model will be the innventory of admin supply.
    - it will store all the received bathes of admin supply items but if the received item is the same to the existing item, only the total quantity will be change
    - ex.: if db.ReceiveAdminSupply received 5 quantities of one specific item and received again that kind of item but only 3 quantities, 
        the total quantity of that item will change by adding the new quantity into the existing.
    - this model will not store duplicate items but the total quantity will update. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
    adminSupplyInventoryId: { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
    roomId:                 { type: DataTypes.INTEGER,  allowNull: false },
    supplyName:             { type: DataTypes.STRING,   allowNull: false },
    supplyMeasure:          { type: DataTypes.ENUM(
                                'pc', 'box', 'bottle', 'pack', 'ream', 
                                'meter', 'roll', 'gallon', 'unit', 'educ', 
                                'teachers'
                                ), 
                                allowNull: false 
                            },
    totalQuantity:          { type: DataTypes.INTEGER, allowNull: false, defaultValue: 0 },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('AdminSupplyInventory', attributes);
};

================================================================================
File: _models\adminSupply\receiveAdminSupply.model.js
Size: 1.31 kB
================================================================================

const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
        receiveAdminSupplyId:   { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:                 { type: DataTypes.INTEGER,  allowNull: false },
        receivedFrom:           { type: DataTypes.STRING,   allowNull: false },
        receivedBy:             { type: DataTypes.INTEGER,  allowNull: false },
        supplyName:             { type: DataTypes.STRING,   allowNull: false },
        supplyQuantity:         { type: DataTypes.INTEGER,  allowNull: false },
        supplyMeasure:          { type: DataTypes.ENUM(
                                    'pc', 'box', 'bottle', 'pack', 'ream', 
                                    'meter', 'roll', 'gallon', 'unit', 'educ', 
                                    'teachers'
                                    ), 
                                    allowNull: false 
                                },
        receivedAt:             { type: DataTypes.DATE, allowNull: false, defaultValue: DataTypes.NOW },
        updated:                { type: DataTypes.DATE },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('ReceiveAdminSupply', attributes);
};

================================================================================
File: _models\adminSupply\releaseAdminSupply.model.js
Size: 1.08 kB
================================================================================

/* 
    - this model will store all the released of apprels.
    - its like as receave but this one is for release feature.
    - this model will store 1 row per released item. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
        releaseAdminSupplyId:       { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:                     { type: DataTypes.INTEGER,  allowNull: false },
        adminSupplyInventoryId:     { type: DataTypes.INTEGER,  allowNull:  false },
        releasedBy:                 { type: DataTypes.STRING,   allowNull:  false },
        claimedBy:                  { type: DataTypes.STRING,   allowNull:  false },
        releaseAdminSupplyQuantity: { type: DataTypes.INTEGER,  allowNull:  false },
        releasedAt:                 { type: DataTypes.DATE,     allowNull:  false, defaultValue: DataTypes.NOW },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('ReleaseAdminSupply', attributes);
};

================================================================================
File: _models\apparel\apparel.model.js
Size: 1.14 kB
================================================================================

/* 
    - this model will store all the received bathes of apprel items into rows
    - ex.: if db.ReceiveApprel received 5 quantitys of one specific item and will store as one row.
    - this model will store the 5 quantities into 5 rows. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {

    const attributes = {
        apparelId:          { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:             { type: DataTypes.INTEGER,  allowNull: false },
        receiveApparelId:   { type: DataTypes.INTEGER,  allowNull: false },
        status:             { type: DataTypes.ENUM(
                                'good','working',
                                'damage',
                                ), defaultValue: 'good'
                            },
        description:        { type: DataTypes.TEXT, allowNull: true, defaultValue: null },
        apparelInventoryId: { type: DataTypes.INTEGER, allowNull: false },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('Apparel', attributes);
};

================================================================================
File: _models\apparel\apparelInventory.model.js
Size: 2.2 kB
================================================================================

/* 
    - this model will be the innventory of apparel.
    - it will store all the received bathes of apprel items but if the received item is the same to the existing item, only the total quantity will be change
    - ex.: if db.ReceiveApprel received 5 quantities of one specific item and received again that kind of item but only 3 quantities, 
        the total quantity of that item will change by adding the new quantity into the existing.
    - this model will not store duplicate items but the total quantity will update. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
    apparelInventoryId: { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
    roomId:             { type: DataTypes.INTEGER,  allowNull: false },
    apparelName:        { type: DataTypes.STRING,   allowNull: false },
    apparelLevel:       { type: DataTypes.ENUM(
                            'pre','elem',
                            '7','8','9','10',
                            'sh','it','hs','educ',
                            'teachers'
                            ), 
                            allowNull: false },
    apparelType:        { type: DataTypes.ENUM('uniform','pe'), allowNull: false },
    apparelFor:         { type: DataTypes.ENUM('boys','girls'), allowNull: false },
    apparelSize:        { type: DataTypes.ENUM(
                            '2', '4', '6', '8', '10', 
                            '12', '14', '16', '18', '20', 
                            'xs', 's', 'm', 'l', 'xl', 
                            '2xl', '3xl'
                            ), 
                            allowNull: false  
                        },
    totalQuantity:      { type: DataTypes.INTEGER, allowNull: false, defaultValue: 0 },
    status:             { type: DataTypes.ENUM('out_of_stock','low_stock','high_stock'), allowNull: false, defaultValue: 'out_of_stock' },
    qrStatus:            { type: DataTypes.BOOLEAN, allowNull: false, defaultValue: false }
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('ApparelInventory', attributes);
};

================================================================================
File: _models\apparel\receiveApparel.model.js
Size: 2.37 kB
================================================================================

/* 
    - this model will store all the received bathes of apprel one row per batch.
    - ex.: if db.ReceiveApprel received 5 quantitys of one specific item and will store as one row, 
    - this model will store the 5 quantities into 1 row. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
        receiveApparelId:   { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:             { type: DataTypes.INTEGER,  allowNull: false },
        receivedFrom:       { type: DataTypes.STRING,   allowNull: false },
        receivedBy:         { type: DataTypes.INTEGER,  allowNull: false },
        apparelName:        { type: DataTypes.STRING,   allowNull: false },
        apparelLevel:       { type: DataTypes.ENUM(
                                'pre', 'elem', 
                                '7', '8', '9', '10', 
                                'sh', 'it', 'hs', 'educ', 
                                'teachers'
                                ), 
                                allowNull: false 
                            },
        apparelType:        { type: DataTypes.ENUM(
                                'uniform', 'pe'
                                ), 
                                allowNull: false 
                            },
        apparelFor:         { type: DataTypes.ENUM(
                                'boys', 'girls'
                                ), 
                                allowNull: false 
                            },
        apparelSize:        { type: DataTypes.ENUM(
                                '2', '4', '6', '8', '10', 
                                '12', '14', '16', '18', '20', 
                                'xs', 's', 'm', 'l', 'xl', 
                                '2xl', '3xl'
                                ), 
                                allowNull: false  
                            },
        apparelQuantity:    { type: DataTypes.INTEGER,  allowNull: false },
        receivedAt:         { type: DataTypes.DATE,     allowNull: false, defaultValue: DataTypes.NOW },
        updated:            { type: DataTypes.DATE },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('ReceiveApparel', attributes);
};

================================================================================
File: _models\apparel\releaseApparel.model.js
Size: 1.09 kB
================================================================================

/* 
    - this model will store all the released of apprels.
    - its like as receave but this one is for release feature.
    - this model will store 1 row per released item. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
        releaseApparelId:           { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:                     { type: DataTypes.INTEGER,  allowNull: false },
        apparelInventoryId:         { type: DataTypes.INTEGER,  allowNull:  false },
        releasedBy:                 { type: DataTypes.STRING,   allowNull:  false },
        claimedBy:                  { type: DataTypes.STRING,   allowNull:  false },
        releaseApparelQuantity:     { type: DataTypes.INTEGER,  allowNull:  false },
        releasedAt:                 { type: DataTypes.DATE,     allowNull:  false, defaultValue: DataTypes.NOW },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('ReleaseApparel', attributes, options);
};

================================================================================
File: _models\borrow.model.js
Size: 2.22 kB
================================================================================

const { DataTypes } = require('sequelize');

module.exports = model;

function model(sequelize) {
  const attributes = {
    borrowId:        { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
    requesterId:     { type: DataTypes.INTEGER, allowNull: false },
    roomId:          { type: DataTypes.INTEGER, allowNull: false },

    // item info
    itemId:          { type: DataTypes.INTEGER, allowNull: true },  // inventory id (nullable)
    itemType:        { 
      type: DataTypes.ENUM('apparel','supply','genItem'), 
      allowNull: true 
    },

    quantity:        { type: DataTypes.INTEGER, allowNull: false, defaultValue: 1 },

    // workflow statuses
    status: {
      type: DataTypes.ENUM(
        'waiting_for_approval',
        'approved',
        'declined',
        'acquired',
        'cancelled',
        'in_return',
        'return_accepted'
      ),
      allowNull: false,
      defaultValue: 'waiting_for_approval'
    },

    // approvals (owner actions)
    approvedBy:      { type: DataTypes.INTEGER, allowNull: true },
    approvedAt:      { type: DataTypes.DATE, allowNull: true },

    declinedBy:      { type: DataTypes.INTEGER, allowNull: true },
    declinedAt:      { type: DataTypes.DATE, allowNull: true },
    declineReason:   { type: DataTypes.TEXT, allowNull: true },

    // borrower actions
    acquiredBy:      { type: DataTypes.INTEGER, allowNull: true },
    acquiredAt:      { type: DataTypes.DATE, allowNull: true },

    cancelledBy:     { type: DataTypes.INTEGER, allowNull: true },
    cancelledAt:     { type: DataTypes.DATE, allowNull: true },

    returnedBy:      { type: DataTypes.INTEGER, allowNull: true }, // borrower marked as returned
    returnedAt:      { type: DataTypes.DATE, allowNull: true },

    // owner accepts returned items
    acceptedBy:      { type: DataTypes.INTEGER, allowNull: true },
    acceptedAt:      { type: DataTypes.DATE, allowNull: true },

    // generic note field
    note:            { type: DataTypes.TEXT, allowNull: true }
  };

  const options = {
    timestamps: true,
  };

  return sequelize.define('Borrow', attributes, options);
}

================================================================================
File: _models\genItem\genItem.model.js
Size: 1.17 kB
================================================================================

/* 
    - this model will store all the received bathes of apprel items into rows
    - ex.: if db.ReceiveApprel received 5 quantitys of one specific item and will store as one row.
    - this model will store the 5 quantities into 5 rows. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {

    const attributes = {
        genItemId:          { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:             { type: DataTypes.INTEGER,  allowNull: false },
        receiveGenItemId:   { type: DataTypes.INTEGER,  allowNull: false },
        // status:             { type: DataTypes.STRING,   allowNull: false, defaultValue: 'in_stock' },
        status: {
            type: DataTypes.ENUM('good', 'working', 'damage'),
            allowNull: false,
            defaultValue: 'good'
          },
        description:        { type: DataTypes.TEXT, allowNull: true, defaultValue: null },
        genItemInventoryId: { type: DataTypes.INTEGER,  allowNull: false },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('GenItem', attributes);
};

================================================================================
File: _models\genItem\genItemInventory.model.js
Size: 1.41 kB
================================================================================

/* 
    - this model will be the innventory of apparel.
    - it will store all the received bathes of apprel items but if the received item is the same to the existing item, only the total quantity will be change
    - ex.: if db.ReceiveApprel received 5 quantities of one specific item and received again that kind of item but only 3 quantities, 
        the total quantity of that item will change by adding the new quantity into the existing.
    - this model will not store duplicate items but the total quantity will update. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
    genItemInventoryId: { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
    roomId:             { type: DataTypes.INTEGER,  allowNull: false },
    genItemName:        { type: DataTypes.STRING,   allowNull: false },
    genItemSize:        { type: DataTypes.STRING,   allowNull: true },
    genItemType:        { type: DataTypes.ENUM(
                            'it', 'maintenance', 'unknownType'
                            ), 
                            allowNull: false 
                        },
    totalQuantity:      { type: DataTypes.INTEGER,  allowNull: false, defaultValue: 0 },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('GenItemInventory', attributes);
};

================================================================================
File: _models\genItem\receiveGenItem.model.js
Size: 1.45 kB
================================================================================

/* 
    - this model will store all the received bathes of apprel one row per batch.
    - ex.: if db.ReceiveApprel received 5 quantitys of one specific item and will store as one row, 
    - this model will store the 5 quantities into 1 row. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
        receiveGenItemId:   { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:             { type: DataTypes.INTEGER,  allowNull: false },
        receivedFrom:       { type: DataTypes.STRING,   allowNull: false },
        receivedBy:         { type: DataTypes.INTEGER,  allowNull: false },
        genItemName:        { type: DataTypes.STRING,   allowNull: false },
        genItemSize:        { type: DataTypes.STRING,   allowNull: true },
        genItemQuantity:    { type: DataTypes.INTEGER,  allowNull: false },
        genItemType:        { type: DataTypes.ENUM(
                                'it', 'maintenance', 'unknownType'
                                ), 
                                allowNull: false 
                            },
        receivedAt:         { type: DataTypes.DATE,     allowNull: false, defaultValue: DataTypes.NOW },
        updated:            { type: DataTypes.DATE },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('ReceiveGenItem', attributes);
};

================================================================================
File: _models\genItem\releaseGenItem.model.js
Size: 1.32 kB
================================================================================

/* 
    - this model will store all the released of apprels.
    - its like as receave but this one is for release feature.
    - this model will store 1 row per released item. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
        releaseGenItemId:       { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:                 { type: DataTypes.INTEGER,  allowNull: false },
        genItemInventoryId:     { type: DataTypes.INTEGER,  allowNull:  false },
        releasedBy:             { type: DataTypes.STRING,   allowNull:  false },
        claimedBy:              { type: DataTypes.STRING,   allowNull:  false },
        releaseItemQuantity:    { type: DataTypes.INTEGER,  allowNull:  false },
        genItemType:            { type: DataTypes.ENUM(
                                    'it', 'maintenance', 'unknownType'
                                    ), 
                                    allowNull: false 
                                },
        releasedAt:             { type: DataTypes.DATE,     allowNull:  false, defaultValue: DataTypes.NOW },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('ReleaseGenItem', attributes, options);
};

================================================================================
File: _models\qr.model.js
Size: 723 B
================================================================================

const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const attributes = {
    qrId:         { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true }, 
    itemType:     { type: DataTypes.STRING,   allowNull: false },
    batchId:      { type: DataTypes.INTEGER,  allowNull: true },
    unitId:       { type: DataTypes.INTEGER,  allowNull: true },
    qrFilePath:   { type: DataTypes.TEXT,     allowNull: false },
    qrCodePath:   { type: DataTypes.STRING,   allowNull: true },
    createdAt:    { type: DataTypes.DATE,     defaultValue: DataTypes.NOW }
  };

  const options = {
    timestamps: false
  };

  return sequelize.define('Qr', attributes, options);
};


================================================================================
File: _models\refresh-token.model.js
Size: 1.23 kB
================================================================================

const { DataTypes } = require('sequelize');

module.exports = model;

function model(sequelize) {
    const attributes = {
        refreshTokenId:     { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        token:              { type: DataTypes.STRING },
        expires:            { type: DataTypes.DATE },
        created:            { type: DataTypes.DATE,     allowNull: false, defaultValue: DataTypes.NOW }, 
        createdByIp:        { type: DataTypes.STRING },
        revoked:            { type: DataTypes.DATE },
        revokedByIp:        { type: DataTypes.STRING },
        replacedByToken:    { type: DataTypes.STRING }, 
        accountId:          { type: DataTypes.INTEGER,  allowNull: false },
        isExpired:          { type: DataTypes.VIRTUAL,
                                get() { return Date.now() >= this.expires; }
                            },
        isActive:           { type: DataTypes.VIRTUAL, 
                                get() { return !this.revoked && !this.isExpired; }
                            }
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('RefreshToken', attributes, options);
}

================================================================================
File: _models\request\item.request.model.js
Size: 1.13 kB
================================================================================

const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const attributes = {
    itemRequestId: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
    accountId:     { type: DataTypes.INTEGER, allowNull: false },
    requestToRoomId:{ type: DataTypes.INTEGER, allowNull: true },
    requesterRoomId:{ type: DataTypes.INTEGER, allowNull: true },
    itemId:        { type: DataTypes.INTEGER, allowNull: true },
    quantity:      { type: DataTypes.INTEGER, defaultValue: 1 },
    status:        {
      type: DataTypes.ENUM('pending','accepted','released','declined','out_of_stock','fulfilled'),
      defaultValue: 'pending'
    },
    note:          { type: DataTypes.STRING(500), allowNull: true },
    acceptedBy:    { type: DataTypes.INTEGER, allowNull: true },
    acceptedAt:    { type: DataTypes.DATE, allowNull: true },
    fulfilledBy:   { type: DataTypes.INTEGER, allowNull: true },
    fulfilledAt:   { type: DataTypes.DATE, allowNull: true }
  }

  const options = {
    timestamps: false
  };

  return sequelize.define('ItemRequest', attributes);
};

================================================================================
File: _models\request\stock.request.model.js
Size: 776 B
================================================================================

const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const attributes = {
    stockRequestId: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
    accountId: { type: DataTypes.INTEGER, allowNull: false },
    requesterRoomId: { type: DataTypes.INTEGER, allowNull: true },
    itemId: { type: DataTypes.INTEGER, allowNull: true },
    quantity: { type: DataTypes.INTEGER, defaultValue: 1 },
    status: { 
      type: DataTypes.ENUM('pending','approved','failed_request','disapproved','fulfilled'),
      defaultValue: 'pending'
    },
    note: { type: DataTypes.STRING(500), allowNull: true },
  };  

  const options = {
    timestamps: false
  };

  return sequelize.define('StockRequest', attributes);
};

================================================================================
File: _models\room.model.js
Size: 890 B
================================================================================

const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const attributes = {
    roomId:         { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
    roomName:       { type: DataTypes.STRING,   allowNull: false },
    roomFloor:      { type: DataTypes.STRING,   allowNull: false },
    roomType:       { type: DataTypes.ENUM(
                        'stockroom', 'subStockroom', 
                        'office', 'classroom', 'openarea'
                        ), 
                      allowNull: false, defaultValue: 'classroom' },
    stockroomType:  { type: DataTypes.ENUM(
                        'apparel', 'supply', 'general'
                        ), 
                      allowNull: true },
    roomInCharge:   { type: DataTypes.INTEGER,  allowNull: false }
  };

  return sequelize.define('Room', attributes);
};

================================================================================
File: _models\transfer.model.js
Size: 1.27 kB
================================================================================

const { DataTypes } = require('sequelize');

module.exports = model;

function model(sequelize) {
    const attributes = {
        transferId:      { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
        fromRoomId:      { type: DataTypes.INTEGER, allowNull: false },
        toRoomId:        { type: DataTypes.INTEGER, allowNull: false },
        createdBy:       { type: DataTypes.INTEGER, allowNull: false },
        itemId:          { type: DataTypes.INTEGER, allowNull: true },
        quantity:        { type: DataTypes.INTEGER, allowNull: false, defaultValue: 1 },

        status:          { type: DataTypes.STRING, allowNull: false, defaultValue: 'in_transfer' },
        acceptedBy:      { type: DataTypes.INTEGER, allowNull: true },
        acceptedAt:      { type: DataTypes.DATE, allowNull: true },

        returningBy:     { type: DataTypes.INTEGER, allowNull: true },
        returnedAt:      { type: DataTypes.DATE, allowNull: true },

        note:            { type: DataTypes.TEXT, allowNull: true },

        updatedAt:       { type: DataTypes.DATE, allowNull: true }
    };

    const options = { 
        timestamps: false
    };

    return sequelize.define('Transfer', attributes, options);
    
}

================================================================================
File: _services\account.service.js
Size: 15.55 kB
================================================================================

const config    = require('config.json'); 
const jwt       = require('jsonwebtoken'); 
const bcrypt    = require('bcryptjs'); 
const crypto    = require("crypto"); 
const { Op}     = require('sequelize');

const sendEmail   = require('_helpers/send-email'); 
const db          = require('_helpers/db-handler');
const Role        = require('_helpers/role');

module.exports = { 
    authenticate,
    refreshToken,
    revokeToken,
    register,
    verifyEmail,
    forgotPassword,
    validateResetToken,
    resetPassword, 
    getAll,
    getById,
    create,
    logActivity,
    getAccountActivities,
    getAllActivityLogs,
    update,
    delete: _delete,
};

async function authenticate({ email, password, ipAddress, browserInfo }) {
    const account = await db.Account.scope('withHash').findOne({ where: { email } });
  
    if (!account || !account.isVerified || !(await bcrypt.compare(password, account.passwordHash))) {
      throw 'Email or password is incorrect';
    }

    // if (!user.isActive) {
    //   return res.status(401).json({ message: 'Account is deactivated. Please contact an administrator.' });
    // }
  
    const jwtToken = generateJwtToken(account);
    const refreshToken = generateRefreshToken(account, ipAddress);
  
    await refreshToken.save();
  
    try {
      await logActivity(account.accountId, 'login', ipAddress, browserInfo);
    } catch (error) {
      console.error('Error logging activity:', error);
    }
  
    return {
      ...basicDetails(account),
      jwtToken,
      refreshToken: refreshToken.token
    };
}
async function logActivity(accountId, actionType, ipAddress, browserInfo, updateDetails = '') {
    try {
      // Create a new log entry in the 'activity_log' table
      await db.ActivityLog.create({
        accountId,
        actionType,
        actionDetails: `IP Address: ${ipAddress}, Browser Info: ${browserInfo}, Details: ${updateDetails}`,
        timestamp: new Date()
      });
  
      // Count the number of logs for the user
      const logCount = await db.ActivityLog.count({ where: { accountId } });
  
      if (logCount > 10) {
        // Find and delete the oldest logs
        const logsToDelete = await db.ActivityLog.findAll({
          where: { accountId },
          order: [['timestamp', 'ASC']],
          limit: logCount - 10
        });
  
        if (logsToDelete.length > 0) {
          const logIdsToDelete = logsToDelete.map(log => log.activityLogId);
  
          await db.ActivityLog.destroy({
            where: {
              activityLogId: {
                [Op.in]: logIdsToDelete
              }
            }
          });
          console.log(`Deleted ${logIdsToDelete.length} oldest log(s) for user ${accountId}.`);
        }
      }
    } catch (error) {
      console.error('Error logging activity:', error);
      throw error;
    }
}
async function getAllActivityLogs(filters = {}) {
  try {
      let whereClause = {};
      
      // Apply filters
      if (filters.actionType) {
          whereClause.actionType = { [Op.like]: `%${filters.actionType}%` };
      }
      
      if (filters.userId) {
          whereClause.accountId = filters.userId;
      }
      
      if (filters.startDate || filters.endDate) {
          const startDate = filters.startDate ? new Date(filters.startDate) : new Date(0);
          const endDate = filters.endDate ? new Date(filters.endDate) : new Date();
          whereClause.timestamp = { [Op.between]: [startDate, endDate] };
      }

      // Get all activity logs with user details
      const logs = await db.ActivityLog.findAll({
          where: whereClause,
          include: [{
              model: db.Account,
              attributes: ['email', 'firstName', 'lastName', 'role'],
              required: true
          }],
          order: [['timestamp', 'DESC']]
      });

      // Format the response
      return logs.map(log => {
          const formattedDate = new Intl.DateTimeFormat('en-US', {
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              hour12: true
          }).format(new Date(log.timestamp));

          return {
              activityLogId: log.activityLogId,
              userId: log.accountId,
              userEmail: log.Account.email,
              userRole: log.Account.role,
              userName: `${log.Account.firstName} ${log.Account.lastName}`,
              actionType: log.actionType,
              actionDetails: log.actionDetails,
              timestamp: formattedDate
          };
      });
  } catch (error) {
      console.error('Error retrieving all activity logs:', error);
      throw new Error('Error retrieving activity logs');
  }
}
async function getAccountActivities(accountId, filters = {}) {
  const account = await getAccount(accountId);
  if (!account) throw new Error('User not found');

  let whereClause = { accountId };

  // Apply optional filters such as action type and timestamp range
  if (filters.actionType) {
    whereClause.actionType = { [Op.like]: `%${filters.actionType}%` };
  }
  if (filters.startDate || filters.endDate) {
    const startDate = filters.startDate ? new Date(filters.startDate) : new Date(0);
    const endDate = filters.endDate ? new Date(filters.endDate) : new Date();
    whereClause.timestamp = { [Op.between]: [startDate, endDate] };
  }

  try {
    const activities = await db.ActivityLog.findAll({ where: whereClause });
    return activities.map(activity => {
      const formattedDate = new Intl.DateTimeFormat('en-US', {
          year: '2-digit',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          hour12: true
      }).format(new Date(activity.timestamp));

      return {
          activityLogId: activity.activityLogId,
          accountId: activity.accountId,
          actionType: activity.actionType,
          actionDetails: activity.actionDetails,
          timestamp: formattedDate
      };
  });
  } catch (error) {
    console.error('Error retrieving activities:', error);
    throw new Error('Error retrieving activities');
  }
}
async function refreshToken({ token, ipAddress }) { 
    const refreshToken = await getRefreshToken(token); 
    const account = await refreshToken.getAccount();

    const newRefreshToken = generateRefreshToken (account, ipAddress); 
    refreshToken.revoked = Date.now();
    refreshToken.revokedByIp = ipAddress;
    refreshToken.replacedByToken = newRefreshToken.token;
    await refreshToken.save();
    await newRefreshToken.save();
    
    const jwtToken = generateJwtToken(account);
    
    return {
        ...basicDetails (account),
        jwtToken,
        refreshToken: newRefreshToken.token
    };
}
async function revokeToken({ token, ipAddress }) { 
    const refreshToken = await getRefreshToken (token);
    
    refreshToken.revoked = Date.now();
    refreshToken.revokedByIp = ipAddress; 
    await refreshToken.save();
}
async function register(params, origin) {
    if (await db.Account.findOne({ where: { email: params.email } })) {
        return await sendAlreadyRegisteredEmail (params.email, origin);
    }
    
    const account = new db.Account (params);

    const isFirstAccount = (await db.Account.count()) === 0; 
    account.role = isFirstAccount? Role.SuperAdmin: Role.Admin; 
    account.verificationToken = randomTokenString();
    
    account.passwordHash = await hash (params.password);
    
    await account.save();
    await sendVerificationEmail (account, origin);
}
async function verifyEmail({token}) {
    const account = await db.Account.findOne({ where: { verificationToken: token} });

    if (!account) throw 'Verification failed';

    account.verified = Date.now();
    account.verificationToken = null; 
    await account.save();
}
async function forgotPassword({ email }, origin) {
    const account = await db.Account.findOne({ where: { email } });

    if (!account) return;
    
    account.resetToken = randomTokenString();
    account.resetTokenExpires= new Date(Date.now() + 24*60*60*1000);
    await account.save();

    await sendPasswordResetEmail (account, origin);
}
async function validateResetToken({token}) { 
    const account = await db.Account.findOne({ 
        where: {
            resetToken: token,
            resetTokenExpires: { [Op.gt]: Date.now() }
        }
    });

    if (!account) throw 'Invalid token';

    return account;
}
async function resetPassword({ token, password }, ipAddress, browserInfo) {
    const account = await validateResetToken({ token });
  
     // Add password validation if needed
     if (password.length < 6) {
      throw 'Password must be at least 6 characters';
  }
    account.passwordHash = await hash(password);
    account.passwordReset = Date.now();
    account.resetToken = null;
    account.resetTokenExpires = null; // Clear the expiry
    await account.save();
  
    try {
      await logActivity(account.accountId, 'password_reset', ipAddress, browserInfo);
    } catch (error) {
      console.error('Error logging activity:', error);
    }
  
    return;
}
async function getAll() {

    const account =  await db.Account.findAll({
      attributes: ['accountId', 'title', 'email', 'firstName', 'lastName', 'email', 'role', 'status']
    });

    return account;
}
async function getById(accountId) {
    const account = await db.Account.findByPk(accountId);
    return account;
}
async function create(params) {
  // Check if the email is already registered
  const existingAccount = await db.Account.findOne({ where: { email: params.email } });
  if (existingAccount) {
      throw `Email "${params.email}" is already registered`;
  }

  const account = new db.Account(params);
  account.verified = Date.now();
  account.passwordHash = await hash(params.password);

  // Save the account
  await account.save();
  return account;
}
async function update(accountId, params, ipAddress, browserInfo) {
  const account = await getAccount(accountId);
  const oldData = account.toJSON();
  const updatedFields = [];
  const nonUserFields = ['ipAddress', 'browserInfo'];

  // Check if any meaningful changes are being made
  const hasChanges = Object.keys(params).some(key => 
    !nonUserFields.includes(key) && 
    params[key] !== undefined && 
    params[key] !== oldData[key]
  );

  if (!hasChanges) {
    return basicDetails(account);
  }

  if (params.email && account.email !== params.email && await db.Account.findOne({ where: { email: params.email } })) { 
      throw 'Email "' + params.email + '" is already taken';
  }

  if (params.password) {
      params.passwordHash = await hash(params.password);
  }

  for (const key in params) {
    if (params.hasOwnProperty(key) && !nonUserFields.includes(key)) {
        if (oldData[key] !== params[key]) {
            updatedFields.push(`${key}: ${oldData[key]} -> ${params[key]}`);
        }
    }
  }

  Object.assign(account, params); 
  account.updated = Date.now(); 

  try {
      await account.save();

      // Log activity with updated fields
      const updateDetails = updatedFields.length > 0 
          ? `Updated fields: ${updatedFields.join(', ')}` 
          : 'No fields changed';

      await logActivity(account.accountId, 'profile update', ipAddress || 'Unknown IP', browserInfo || 'Unknown Browser', updateDetails);
  } catch (error) {
      console.error('Error logging activity:', error);
  }

  return basicDetails(account);
}
async function _delete(accountId) {
    const account = await getAccount(accountId);
    await account.status === 'deactivated';
}
async function getAccount (accountId) {
    const account = await db.Account.findByPk(accountId); 
    if (!account) throw 'Account not found';
    return account;
}
async function getRefreshToken(token) {
    const refreshToken = await db.RefreshToken.findOne({ where: {token} });
    if (!refreshToken || !refreshToken.isActive) throw 'Invalid token'; 
    return refreshToken;
}
async function hash (password) {
    return await bcrypt.hash (password, 10);
}
function generateJwtToken(account) {
    return jwt.sign({ sub: account.accountId, accountId: account.accountId}, config.secret, { expiresIn: '1h' });
}
function generateRefreshToken(account, ipAddress) {
    return new db.RefreshToken({
        accountId: account.accountId,
        token: randomTokenString(),
        expires: new Date(Date.now() + 7*24*60*60*1000), 
        createdByIp: ipAddress
    });
}
function randomTokenString() {
    return crypto.randomBytes (40).toString('hex');
}
function basicDetails(account) {
    const { accountId, title, firstName, lastName, email, phoneNumber, role, created, updated, isVerified } = account; 
    return { accountId, title, firstName, lastName, email, phoneNumber, role, created, updated, isVerified };
}
async function sendVerificationEmail(account, origin) {
    let message;
    if (origin) {
        const verifyUrl = `${origin}/account/verify-email?token=${account.verificationToken}`; 
        message = `<p>Please click the below link to verify your email address:</p>;
                   <p><a href="${verifyUrl}">${verifyUrl}</a></p>`;
    } else {
        message = `<p>Please use the below token to verify your email address with the <code>/account/verify-email</code> api route:</p> 
                   <p><code>${account.verificationToken}</code></p>`;
    }
    
    await sendEmail({
    to: account.email,
    subject: 'Sign-up Verification API - Verify Email',
    html: `<h4>Verify Email</h4>
          <p>Thanks for registering!</p> 
          ${message}`
    });
}
async function sendAlreadyRegisteredEmail(email, origin) {
    let message; 
    if (origin) {
        message = `
        <p>If you don't know your password please visit the <a href="${origin}/account/forgot-password">forgot password</a> page.</p>`; 
    } else { message = `
        <p>If you don't know your password you can reset it via the <code>/account/forgot-password</code> api route.</p>`;
    }

    await sendEmail({
        to: email,
        subject: 'Sign-up Verification API - Email Already Registered',
        html: `<h4>Email Already Registered</h4>
        <p>Your email <strong>${email}</strong> is already registered.</p> ${message}`
    });
}
async function sendPasswordResetEmail (account, origin) {
    let message;
    if (origin) {
        const resetUrl = `${origin}/account/reset-password?token=${account.resetToken}`;
        message = `<p>Please click the below link to reset your password, the link will be valid for 1 day:</p>
                   <p><a href="${resetUrl}">${resetUrl}</a></p>`;
    } else {
        message = `<p>Please use the below token to reset your password with the <code>/account/reset-password</code> api route:</p> 
                   <p><code>${account.resetToken}</code></p>`;
    }
    
    await sendEmail({
    to: account.email,
    subject: 'Sign-up Verification API - Reset Password',
    html: `<h4>Reset Password Email</h4>
          ${message}`
    });
}

================================================================================
File: _services\borrow.service.js
Size: 17.91 kB
================================================================================

const db = require('_helpers/db-handler');
const Role = require('_helpers/role');
const accountService = require('./account.service');

module.exports = {
  createBorrow,
  listBorrows,
  getById,
  cancelBorrow,
  approveBorrow,
  declineBorrow,
  acquireBorrow,
  returnBorrow,
  acceptReturn,
};

async function createBorrow(payload, ipAddress, browserInfo) {
  const { requesterId, roomId, quantity = 1 } = payload;
  if (!requesterId || !roomId) throw { status: 400, message: 'Missing required fields' };
  const q = parseInt(quantity, 10);
  if (!Number.isInteger(q) || q <= 0) throw { status: 400, message: 'quantity must be positive' };

  const created = await db.Borrow.create({
    requesterId,
    roomId,
    itemId: payload.itemId || null,
    quantity: q,
    note: payload.note || null,
    status: 'waiting_for_approval'
  });

  try {
    await accountService.logActivity(String(requesterId), 'borrow_create', ipAddress, browserInfo, `borrowId:${created.borrowId}`);
  } catch (err) {
    console.error('activity log failed (createBorrow)', err);
  }

  return created;
}
async function listBorrows({ where = {}, limit = 200, offset = 0 } = {}) {
  const rows = await db.Borrow.findAll({
    where,
    order: [['borrowId', 'DESC']],
    limit,
    offset,
    include: [
      { model: db.Account, as: 'requester', attributes: ['accountId', 'firstName', 'lastName'], required: false },
      // { model: db.Room, foreignKey: 'roomId' },
      { model: db.Room, as: 'room', attributes: ['roomId', 'roomName', 'roomInCharge'], required: false },

      // polymorphic-ish item relations (no FK constraints)
      // { model: db.ApparelInventory, foreignKey: 'itemId', constraints: false },
      // { model: db.AdminSupplyInventory, foreignKey: 'itemId', constraints: false },
      // { model: db.GenItemInventory, foreignKey: 'itemId', constraints: false },
    ]
  });

  return rows;
}
async function getById(id) {
  if (!id) throw { status: 400, message: 'id required' };
  const n = parseInt(id, 10);
  if (!Number.isInteger(n) || n <= 0) throw { status: 400, message: 'invalid id' };

  const r = await db.Borrow.findByPk(n, {
    include: [
      { model: db.Account, as: 'requester', foreignKey: 'requesterId' },
      { model: db.Room, as: 'room', foreignKey: 'roomId' },
      { model: db.ApparelInventory, foreignKey: 'itemId', as: 'apparel', constraints: false },
      { model: db.AdminSupplyInventory, foreignKey: 'itemId', as: 'adminSupply', constraints: false },
      { model: db.GenItemInventory, foreignKey: 'itemId', as: 'generalItem', constraints: false },
    ]
  });

  if (!r) throw { status: 404, message: 'Borrow not found' };
  return r;
}

async function _getCallerId(user) {
  // flexible - return the first available id-like property as string
  const id = user?.accountId ?? user?.id ?? user?.userId ?? null;
  return id == null ? null : String(id);
}
async function getInventoryModelForItemId(db, id, transaction) {
  if (!id) return null;

  // Try each model; return the first that contains a row with this PK.
  const models = [
    { key: 'apparel', model: db.ApparelInventory },
    { key: 'supply',  model: db.AdminSupplyInventory },
    { key: 'genitem', model: db.GenItemInventory }
  ];

  for (const m of models) {
    if (!m.model) continue;
    // use transaction and lock if provided
    const opts = transaction ? { transaction, lock: transaction.LOCK.UPDATE } : {};
    const row = await m.model.findByPk(id, opts);
    if (row) {
      return { key: m.key, model: m.model, row };
    }
  }
  return null;
}
async function cancelBorrow(borrowId, user, ipAddress, browserInfo) {
  const n = Number(borrowId);
  if (!Number.isFinite(n) || n <= 0) throw { status: 400, message: 'Invalid id' };

  const b = await db.Borrow.findByPk(n, { include: [{ model: db.Room }] });
  if (!b) throw { status: 404, message: 'Borrow not found' };

  // only requester can cancel
  if (String(b.requesterId) !== String(user.accountId)) {
    throw { status: 403, message: 'Only requester can cancel this borrow' };
  }

  // allow cancel only in these states (adjust if you want more)
  if (!['waiting_for_approval', 'approved'].includes(b.status)) {
    throw { status: 400, message: `Cannot cancel borrow in status '${b.status}'` };
  }

  b.status = 'cancelled';
  b.cancelledBy = user.accountId;
  b.cancelledAt = new Date();

  await b.save();

  try {
    await accountService.logActivity(String(user.accountId), 'borrow_cancel', ipAddress, browserInfo, `borrowId:${b.borrowId}`);
  } catch (err) {
    console.error('activity log failed (cancelBorrow)', err);
  }

  return b;
}

async function approveBorrow(borrowId, user, ipAddress, browserInfo) {
  const n = Number(borrowId);
  if (!Number.isFinite(n) || n <= 0) throw { status: 400, message: 'Invalid id' };

  // load borrow (no includes required)
  const b = await db.Borrow.findByPk(n);
  if (!b) throw { status: 404, message: 'Borrow not found' };

  if (b.status !== 'waiting_for_approval') {
    throw { status: 400, message: 'Only requests waiting for approval can be approved' };
  }

  // requester cannot approve
  if (String(b.requesterId) === String((user?.accountId ?? user?.id ?? user?.userId))) {
    throw { status: 403, message: 'Requester cannot approve their own borrow' };
  }

  // get caller id reliably
  const callerId = await _getCallerId(user);
  if (!callerId) throw { status: 401, message: 'Invalid user identity' };

  // only superadmin OR the room in-charge (by ID) can approve
  const userRole = String(user.role ?? '').toLowerCase();
  const isSuperAdmin = userRole === 'superadmin';

  // fetch room explicitly to ensure roomInCharge is available (avoids include/as mismatch)
  const room = await db.Room.findByPk(b.roomId);
  if (!room) throw { status: 500, message: 'Associated room not found for this borrow' };

  const roomInChargeId = room.roomInCharge == null ? null : String(room.roomInCharge);

  if (!isSuperAdmin && callerId !== roomInChargeId) {
    throw { status: 403, message: 'Not authorized to approve this borrow' };
  }

  b.status = 'approved';
  b.approvedBy = callerId;
  b.approvedAt = new Date();

  await b.save();

  try {
    await accountService.logActivity(String(callerId), 'borrow_approve', ipAddress, browserInfo, `borrowId:${b.borrowId}`);
  } catch (err) {
    console.error('activity log failed (approveBorrow)', err);
  }

  return b;
}
async function declineBorrow(borrowId, user, opts = {}, ipAddress, browserInfo) {
  const reason = opts.reason ?? null;
  const n = Number(borrowId);
  if (!Number.isFinite(n) || n <= 0) throw { status: 400, message: 'Invalid id' };

  const b = await db.Borrow.findByPk(n);
  if (!b) throw { status: 404, message: 'Borrow not found' };

  if (b.status !== 'waiting_for_approval') {
    throw { status: 400, message: 'Only requests waiting for approval can be declined' };
  }

  // requester cannot decline
  if (String(b.requesterId) === String((user?.accountId ?? user?.id ?? user?.userId))) {
    throw { status: 403, message: 'Requester cannot decline their own borrow' };
  }

  const callerId = await _getCallerId(user);
  if (!callerId) throw { status: 401, message: 'Invalid user identity' };

  const userRole = String(user.role ?? '').toLowerCase();
  const isSuperAdmin = userRole === 'superadmin';

  // fetch room explicitly
  const room = await db.Room.findByPk(b.roomId);
  if (!room) throw { status: 500, message: 'Associated room not found for this borrow' };

  const roomInChargeId = room.roomInCharge == null ? null : String(room.roomInCharge);

  if (!isSuperAdmin && callerId !== roomInChargeId) {
    throw { status: 403, message: 'Not authorized to decline this borrow' };
  }

  b.status = 'declined';
  b.declinedBy = callerId;
  b.declinedAt = new Date();
  b.declineReason = reason;

  await b.save();

  try {
    await accountService.logActivity(String(callerId), 'borrow_decline', ipAddress, browserInfo, `borrowId:${b.borrowId}${reason ? `, reason:${reason}` : ''}`);
  } catch (err) {
    console.error('activity log failed (declineBorrow)', err);
  }

  return b;
}

// async function acquireBorrow(borrowId, user) {
//   const n = Number(borrowId);
//   if (!Number.isFinite(n) || n <= 0) throw { status: 400, message: 'Invalid id' };

//   return await db.sequelize.transaction(async (t) => {
//     const borrow = await db.Borrow.findByPk(n, { transaction: t, lock: t.LOCK.UPDATE });
//     if (!borrow) throw { status: 404, message: 'Borrow not found' };

//     if (borrow.status !== 'approved') throw { status: 400, message: "Only 'approved' borrows can be acquired" };

//     const callerId = (user?.accountId ?? user?.id ?? user?.userId);
//     if (!callerId) throw { status: 401, message: 'Invalid user identity' };
//     if (String(borrow.requesterId) !== String(callerId)) throw { status: 403, message: 'Only the requester can acquire this borrow' };

//     const itemId = borrow.itemId;
//     if (!itemId) throw { status: 400, message: 'Borrow has no itemId' };

//     const invInfo = await getInventoryModelForItemId(db, itemId, t);
//     if (!invInfo) throw { status: 400, message: 'Inventory item not found in any inventory table' };

//     const inv = invInfo.row;
//     const qty = Number(borrow.quantity || 0);
//     if (!Number.isFinite(qty) || qty <= 0) throw { status: 400, message: 'Invalid borrow quantity' };

//     const available = Number(inv.totalQuantity || 0);
//     if (available < qty) throw { status: 400, message: `Insufficient stock: available ${available}, required ${qty}` };

//     inv.totalQuantity = Math.max(0, available - qty);
//     await inv.save({ transaction: t });

//     borrow.status = 'acquired';
//     borrow.acquiredBy = String(callerId);
//     borrow.acquiredAt = new Date();
//     await borrow.save({ transaction: t });

//     return borrow;
//   });
// }
async function acquireBorrow(borrowId, user, ipAddress, browserInfo) {
  const n = Number(borrowId);
  if (!Number.isFinite(n) || n <= 0) throw { status: 400, message: 'Invalid id' };

  const result = await db.sequelize.transaction(async (t) => {
    const borrow = await db.Borrow.findByPk(n, { transaction: t, lock: t.LOCK.UPDATE });
    if (!borrow) throw { status: 404, message: 'Borrow not found' };
    if (borrow.status !== 'approved') throw { status: 400, message: "Only 'approved' borrows can be acquired" };

    const callerId = (user?.accountId ?? user?.id ?? user?.userId);
    if (!callerId) throw { status: 401, message: 'Invalid user identity' };
    if (String(borrow.requesterId) !== String(callerId)) throw { status: 403, message: 'Only the requester can acquire this borrow' };

    const itemId = borrow.itemId;
    if (!itemId) throw { status: 400, message: 'Borrow has no itemId' };

    const invInfo = await getInventoryModelForItemId(db, itemId, t);
    if (!invInfo) throw { status: 400, message: 'Inventory item not found in any inventory table' };

    const inv = invInfo.row;
    const qty = Number(borrow.quantity || 0);
    if (!Number.isFinite(qty) || qty <= 0) throw { status: 400, message: 'Invalid borrow quantity' };

    const available = Number(inv.totalQuantity || 0);
    if (available < qty) throw { status: 400, message: `Insufficient stock: available ${available}, required ${qty}` };

    inv.totalQuantity = Math.max(0, available - qty);
    await inv.save({ transaction: t });

    borrow.status = 'acquired';
    borrow.acquiredBy = String(callerId);
    borrow.acquiredAt = new Date();
    await borrow.save({ transaction: t });

    return borrow;
  });

  // log activity (best-effort) — use acquiredBy from result
  try {
    await accountService.logActivity(String(result.acquiredBy), 'borrow_acquire', ipAddress, browserInfo, `borrowId:${result.borrowId}`);
  } catch (err) {
    console.error('activity log failed (acquireBorrow)', err);
  }

  return result;
}
async function returnBorrow(borrowId, user, opts = {}, ipAddress, browserInfo) {
  const note = opts.note ?? null;
  const n = Number(borrowId);
  if (!Number.isFinite(n) || n <= 0) throw { status: 400, message: 'Invalid id' };

  // load borrow
  const b = await db.Borrow.findByPk(n);
  if (!b) throw { status: 404, message: 'Borrow not found' };

  // only allow return when it was acquired
  if (b.status !== 'acquired') {
    throw { status: 400, message: "Only 'acquired' borrows can be returned" };
  }

  // get caller id
  const callerId = await _getCallerId(user);
  if (!callerId) throw { status: 401, message: 'Invalid user identity' };

  // allow only requester OR the one who acquired (acquiredBy)
  const isRequester = String(b.requesterId) === String(callerId);
  const isAcquirer  = b.acquiredBy != null && String(b.acquiredBy) === String(callerId);

  if (!isRequester && !isAcquirer) {
    throw { status: 403, message: 'Only the requester or the acquirer can return this borrow' };
  }

  // perform return update
  b.status = 'in_return';
  b.returnedBy = callerId;
  b.returnedAt = new Date();
  if (note) b.returnNote = String(note).slice(0, 1000); // limit note size

  await b.save();

  try {
    await accountService.logActivity(String(callerId), 'borrow_return', ipAddress, browserInfo, `borrowId:${b.borrowId}${note ? `, note:${note}` : ''}`);
  } catch (err) {
    console.error('activity log failed (returnBorrow)', err);
  }

  return b;
}

// async function acceptReturn(borrowId, user, ipAddress, browserInfo) {
//   const n = Number(borrowId);
//   if (!Number.isFinite(n) || n <= 0) throw { status: 400, message: 'Invalid id' };

//   return await db.sequelize.transaction(async (t) => {
//     const borrow = await db.Borrow.findByPk(n, { transaction: t, lock: t.LOCK.UPDATE });
//     if (!borrow) throw { status: 404, message: 'Borrow not found' };

//     if (borrow.status !== 'in_return') throw { status: 400, message: "Only 'in_return' borrows can be accepted" };

//     const callerId = (user?.accountId ?? user?.id ?? user?.userId);
//     if (!callerId) throw { status: 401, message: 'Invalid user identity' };

//     // verify room in-charge, same as before
//     const room = await db.Room.findByPk(borrow.roomId, { transaction: t, lock: t.LOCK.UPDATE });
//     if (!room) throw { status: 500, message: 'Associated room not found' };
//     if (String(room.roomInCharge) !== String(callerId)) throw { status: 403, message: 'Only the room in charge can accept returned items' };

//     const itemId = borrow.itemId;
//     if (!itemId) throw { status: 400, message: 'Borrow has no itemId' };

//     const invInfo = await getInventoryModelForItemId(db, itemId, t);
//     if (!invInfo) throw { status: 400, message: 'Inventory item not found in any inventory table' };

//     const inv = invInfo.row;
//     const qty = Number(borrow.quantity || 0);
//     if (!Number.isFinite(qty) || qty <= 0) throw { status: 400, message: 'Invalid borrow quantity' };

//     inv.totalQuantity = (Number(inv.totalQuantity || 0) + qty);
//     await inv.save({ transaction: t });

//     borrow.status = 'return_accepted';
//     borrow.acceptedBy = String(callerId);
//     borrow.acceptedAt = new Date();
//     await borrow.save({ transaction: t });

//     try {
//       await accountService.logActivity(String(result.acceptedBy), 'borrow_accept_return', '', '', `borrowId:${result.borrowId}`);
//     } catch (err) {
//       console.error('activity log failed (acceptReturn)', err);
//     }

//     return borrow;
//   });
// }
async function acceptReturn(borrowId, user, ipAddress, browserInfo) {
  const n = Number(borrowId);
  if (!Number.isFinite(n) || n <= 0) throw { status: 400, message: 'Invalid id' };

  const result = await db.sequelize.transaction(async (t) => {
    const borrow = await db.Borrow.findByPk(n, { transaction: t, lock: t.LOCK.UPDATE });
    if (!borrow) throw { status: 404, message: 'Borrow not found' };
    if (borrow.status !== 'in_return') throw { status: 400, message: "Only 'in_return' borrows can be accepted" };

    const callerId = (user?.accountId ?? user?.id ?? user?.userId);
    if (!callerId) throw { status: 401, message: 'Invalid user identity' };

    const room = await db.Room.findByPk(borrow.roomId, { transaction: t, lock: t.LOCK.UPDATE });
    if (!room) throw { status: 500, message: 'Associated room not found' };
    if (String(room.roomInCharge) !== String(callerId)) throw { status: 403, message: 'Only the room in charge can accept returned items' };

    const itemId = borrow.itemId;
    if (!itemId) throw { status: 400, message: 'Borrow has no itemId' };

    const invInfo = await getInventoryModelForItemId(db, itemId, t);
    if (!invInfo) throw { status: 400, message: 'Inventory item not found in any inventory table' };

    const inv = invInfo.row;
    const qty = Number(borrow.quantity || 0);
    if (!Number.isFinite(qty) || qty <= 0) throw { status: 400, message: 'Invalid borrow quantity' };

    inv.totalQuantity = (Number(inv.totalQuantity || 0) + qty);
    await inv.save({ transaction: t });

    borrow.status = 'return_accepted';
    borrow.acceptedBy = String(callerId);
    borrow.acceptedAt = new Date();
    await borrow.save({ transaction: t });

    return borrow;
  });

  try {
    await accountService.logActivity(String(result.acceptedBy), 'borrow_accept_return', ipAddress, browserInfo, `borrowId:${result.borrowId}`);
  } catch (err) {
    console.error('activity log failed (acceptReturn)', err);
  }

  return result;
}


================================================================================
File: _services\qr.service.js
Size: 13.71 kB
================================================================================

const fs      = require('fs');
const path    = require('path');
const crypto  = require('crypto');
const QRCode  = require('qrcode');
const db      = require('_helpers/db-handler');

const UPLOADS_DIR = path.join(__dirname, '../uploads');
if (!fs.existsSync(UPLOADS_DIR)) fs.mkdirSync(UPLOADS_DIR, { recursive: true });

function filenameFromPayload(stockroomType, payload) {
  const hash = crypto.createHash('sha256').update(payload).digest('hex').slice(0, 20);
  return `qr-${stockroomType}-${hash}.png`;
}

module.exports = {
  generateBatchQR,
  generateUnitQR,

  scanItem,
  releaseUnit,
  updateItemStatus,

  markInventoryQrGenerated,
};

function pickFirst(obj, ...keys) {
  if (!obj) return null;
  for (const k of keys) {
    if (obj[k] !== undefined && obj[k] !== null) return obj[k];
    if (obj.dataValues && obj.dataValues[k] !== undefined && obj.dataValues[k] !== null) return obj.dataValues[k];
  }
  return null;
}
async function loadBatchRecord(stockroomType, id) {
  if (!stockroomType || !id) return null;

  stockroomType = String(stockroomType).toLowerCase();

  // apparel
  if (stockroomType === 'apparel') {
    // try apparelInventory by PK
    if (db.ApparelInventory) {
      const inv = await db.ApparelInventory.findByPk(id);
      if (inv) return inv;
    }
    // then try receive apparel batch by PK
    if (db.ReceiveApparel) {
      const recv = await db.ReceiveApparel.findByPk(id);
      if (recv) return recv;
    }
    return null;
  }

  // adminSupply
  if (stockroomType === 'supply') {
    if (db.AdminSupplyInventory) {
      const inv = await db.AdminSupplyInventory.findByPk(id);
      if (inv) return inv;
    }
    if (db.ReceiveAdminSupply) {
      const recv = await db.ReceiveAdminSupply.findByPk(id);
      if (recv) return recv;
    }
    return null;
  }

  // generalitem
  if (stockroomType === 'it' || stockroomType === 'maintenance') {
    if (db.GenItemInventory) {
      const inv = await db.GenItemInventory.findByPk(id);
      if (inv) return inv;
    }
    if (db.ReceiveGenItem) {
      const recv = await db.ReceiveGenItem.findByPk(id);
      if (recv) return recv;
    }
    return null;
  }

  // generic pattern: try <type>Inventory then <type> table
  const inventoryModel = db[stockroomType + 'Inventory'] || db[stockroomType + '_inventory'];
  if (inventoryModel) {
    const inv = await inventoryModel.findByPk(id);
    if (inv) return inv;
  }
  if (db[stockroomType]) {
    const row = await db[stockroomType].findByPk(id);
    if (row) return row;
  }
  return null;
}
async function loadUnitRecord(stockroomType, id) {
  if (!stockroomType || !id) return null;

  stockroomType = String(stockroomType).toLowerCase();

  if (stockroomType === 'apparel') {
    if (db.Apparel) {
      const u = await db.Apparel.findByPk(id);
      if (u) return u;
    }
    // older naming possibilities
    if (db.ApparelUnit) {
      const u2 = await db.ApparelUnit.findByPk(id);
      if (u2) return u2;
    }
    return null;
  }

  if (stockroomType === 'supply') {
    if (db.AdminSupply) {
      const u = await db.AdminSupply.findByPk(id);
      if (u) return u;
    }
    return null;
  }

  if (db[stockroomType]) {
    const u = await db[stockroomType].findByPk(id);
    if (u) return u;
  }
  return null;
}
function buildBatchPayloadObject(stockroomType, batch) {
  if (!batch) return { stockroomType };

  // Common fields we want in every QR
  const id = pickFirst(batch,
    // inventory primary keys in different patterns
    'id', 'apparelInventoryId', 'adminSupplyInventoryId', 'genItemInventoryId',
    'receiveApparelId', 'receiveAdminSupplyId', 'receiveGenItemId'
  );

  const name = pickFirst(batch,
    'sku', 'code', 'itemCode', 'apparelSku', 'adminSupplyCode', 'genItemSku',
    'name', 'title', 'apparelName', 'supplyName', 'genItemName', 'itemName', 'description'
  );

  // Status (inventory-level)
  const status = pickFirst(batch, 'status', 'itemStatus', 'apparelStatus', 'adminSupplyStatus');

  // totalQuantity fallbacks
  const totalQuantity = pickFirst(batch,
    'totalQuantity', 'quantity', 'qty',
    'apparelQuantity', 'supplyQuantity', 'genItemQuantity',
    'remainingQuantity', 'availableQuantity'
  );

  const roomId = pickFirst(batch, 'roomId', 'room_id');

  return {
    stockroomType: stockroomType || null,
    inventoryId: id ?? null,
    name: name ?? null,
    status: status ?? null,
    totalQuantity: (totalQuantity !== null && totalQuantity !== undefined) ? Number(totalQuantity) : null,
    roomId: roomId ?? null
  };
}
function buildUnitPayloadObject(stockroomType, unit) {
  if (stockroomType === 'apparel') {
    return {
      unitId:     unit.apparelId          ?? null,
      batchId:    unit.receiveApparelId   ?? unit.apparelInventoryId ?? null,
      status:     unit.apparelStatus      ?? null,
      roomId:     unit.roomId             ?? null,
      createdAt:  unit.createdAt          ?? null,
    };
  }

  if (stockroomType === 'supply') {
    return {
      unitId:     unit.adminSupplyId          ?? null,
      batchId:    unit.receiveAdminSupplyId   ?? unit.adminSupplyInventoryId ?? null,
      status:     unit.status                 ?? null,
      roomId:     unit.roomId                 ?? null,
      createdAt:  unit.createdAt              ?? null
    };
  }

  return {
    unitId: unit.id   ?? null,
    name:   unit.name ?? null
  };
}

async function writePngFromPayload(stockroomType, payload) {
  const filename = filenameFromPayload(stockroomType, payload);
  const absolutePath = path.join(UPLOADS_DIR, filename);
  await QRCode.toFile(absolutePath, payload, {
    errorCorrectionLevel: 'H',
    margin: 1,
    scale: 4
  });
  const publicPath = `/uploads/qrcodes/${filename}`;
  return { filename, absolutePath, publicPath };
}

async function generateBatchQR(argsOrStockroom) {
  // normalize arguments (keeps backwards compatibility)
  let stockroomType, inventoryId;
  if (typeof argsOrStockroom === 'object' && argsOrStockroom !== null && !Array.isArray(argsOrStockroom)) {
    ({ stockroomType, inventoryId } = argsOrStockroom);
  } else {
    stockroomType = arguments[0];
    inventoryId = arguments[1];
  }

  if (!stockroomType || !inventoryId) 
    throw new Error('stockroomType and inventoryId required');

  // load batch record (reuse your existing loader)
  const batch = await loadBatchRecord(stockroomType, inventoryId);
  if (!batch) throw new Error(`Batch not found for ${stockroomType} id=${inventoryId}`);


  // build payload object (use your existing builder)
  const payloadObj = buildBatchPayloadObject(stockroomType, batch);
  const payload = JSON.stringify(payloadObj);

  // compute deterministic filename & absolute path BEFORE writing
  const filename = filenameFromPayload(stockroomType, payload);
  const absolutePath = path.join(UPLOADS_DIR, filename);
  const publicPath = `/uploads/qrcodes/${filename}`;

  // if file already exists, return info immediately (idempotent)
  if (fs.existsSync(absolutePath)) {
    return { filename, absolutePath, publicPath, payload, batch };
  }

  const { filename: writtenFilename, absolutePath: writtenAbs, publicPath: writtenPublic } =
    await writePngFromPayload(stockroomType, payload, { filenameOverride: filename, outputDir: UPLOADS_DIR });

  // optional: update DB rows with qr path info (if you do that elsewhere)
  try { if (typeof batch.update === 'function') await batch.update({ qrFilePath: payload, qrCodePath: writtenPublic }); } catch (e) {}

  return { filename: writtenFilename || filename, absolutePath: writtenAbs || absolutePath, publicPath: writtenPublic || publicPath, payload, batch };
}
async function generateUnitQR(argsOrStockroom) {
  let stockroomType, unitId;
  if (typeof argsOrStockroom === 'object' && argsOrStockroom !== null && !Array.isArray(argsOrStockroom)) {
    ({ stockroomType, unitId } = argsOrStockroom);
  } else {
    stockroomType = arguments[0];
    unitId = arguments[1];
  }

  if (!stockroomType || !unitId) 
    throw new Error('stockroomType and unitId required');

  const unit = await loadUnitRecord(stockroomType, unitId);
  if (!unit) throw new Error(`Unit not found for ${stockroomType} id=${unitId}`);

  const payloadObj = buildUnitPayloadObject(stockroomType, unit);
  const payload = JSON.stringify(payloadObj);

  const filename = filenameFromPayload(stockroomType, payload);
  const absolutePath = path.join(UPLOADS_DIR, filename);
  const publicPath = `/uploads/qrcodes/${filename}`;

  if (fs.existsSync(absolutePath)) {
    return { filename, absolutePath, publicPath, payload, unit };
  }

  // otherwise create file
  const { filename: writtenFilename, absolutePath: writtenAbs, publicPath: writtenPublic } =
    await writePngFromPayload(stockroomType, payload, { filenameOverride: filename, outputDir: UPLOADS_DIR });

  try { if (typeof unit.update === 'function') await unit.update({ qrFilePath: payload, qrCodePath: writtenPublic }); } catch (e) {}

  return { filename: writtenFilename || filename, absolutePath: writtenAbs || absolutePath, publicPath: writtenPublic || publicPath, payload, unit };
}

async function scanItem(qrPayloadText) {
  if (!qrPayloadText) throw { status: 400, message: 'qr payload required' };

  // previously you attempted exact QR matches first — keep that
  if (db.Qr) {
    const record = await db.Qr.findOne({ where: { qrFilePath: qrPayloadText } });
    if (record) return { qrRecord: record };
  }

  try {
    const parsed = JSON.parse(qrPayloadText);

    // helper tries explicit type first, otherwise tries common types
    async function findBatch(parsedObj) {
      const id = Number(parsedObj.inventoryId || parsedObj.id);
      if (!id) return null;
      const explicit = (parsedObj.stockroomType || parsedObj.itemType || parsedObj.type);
      const tryOrder = explicit ? [String(explicit).toLowerCase()] : ['apparel','supply','genitem','it','maintenance'];
      for (const t of tryOrder) {
        const inv = await loadBatchRecord(t, id);
        if (inv) return { inv, type: t };
      }
      return null;
    }

    if (parsed.inventoryId || parsed.id) {
      const found = await findBatch(parsed);
      if (found) {
        parsed._detectedItemType = parsed._detectedItemType || found.type;
        return { payload: parsed, inventory: found.inv };
      }
    }

    if (parsed.unitId) {
      const tryOrder = [(parsed.stockroomType || parsed.itemType || parsed.type), 'apparel','supply','genitem','it','maintenance']
                       .filter(Boolean).map(x => String(x).toLowerCase());
      for (const t of tryOrder) {
        const u = await loadUnitRecord(t, Number(parsed.unitId));
        if (u) { parsed._detectedItemType = parsed._detectedItemType || t; return { payload: parsed, unit: u }; }
      }
    }

    return { payload: parsed };
  } catch (e) {
    throw { status: 404, message: 'QR code not found' };
  }
}

// new helper: centralize unit release logic so controller can be tiny
async function releaseUnit(stockroomType, unitId, opts = {}) {
  if (!stockroomType || !unitId) throw { status: 400, message: 'Invalid params' };
  const t = String(stockroomType).toLowerCase();
  const actorId = opts.actorId || null;

  if (t === 'apparel') {
    const apparelService = require('_services/apparel.service');
    return apparelService.releaseUnitById(Number(unitId), { actorId });
  }

  if (['admin-supply','supply','adminsupply','admin-supply'].includes(t)) {
    const supplyService = require('_services/adminSupply.service');
    return supplyService.releaseUnitById(Number(unitId), { actorId });
  }

  if (['genitem','general-item','general','it','maintenance'].includes(t)) {
    const genService = require('_services/genItem.service');
    return genService.releaseUnitById(Number(unitId), { actorId });
  }

  throw { status: 400, message: 'Unsupported stockroomType for unit release' };
}


async function updateItemStatus(stockroomType, id) {
  if (!stockroomType || !id) return null;

  if (stockroomType === 'apparel') {
    const updated = await db.Apparel.update(
      { itemStatus: updated.apparelStatus },
      { where: { id } }
    );
    if (!updated) throw new Error('Status update failed');

    return null;
  }
}
async function markInventoryQrGenerated(stockroomType, inventoryId) {
  try {
    if (!inventoryId) return;

    stockroomType = String(stockroomType || '').toLowerCase();

    if (stockroomType === 'apparel' && db.ApparelInventory) {
      await db.ApparelInventory.update({ qrStatus: true }, { where: { id: inventoryId } });
      return;
    }
    if (stockroomType === 'supply' && db.AdminSupplyInventory) {
      await db.AdminSupplyInventory.update({ qrStatus: true }, { where: { id: inventoryId } });
      return;
    }
    if ((stockroomType === 'general' || stockroomType === 'it' || stockroomType === 'maintenance') && db.GenItemInventory) {
      await db.GenItemInventory.update({ qrStatus: true }, { where: { id: inventoryId } });
      return;
    }

    const modelName = `${stockroomType.charAt(0).toUpperCase()}${stockroomType.slice(1)}Inventory`;
    if (db[modelName]) {
      await db[modelName].update({ qrStatus: true }, { where: { id: inventoryId } });
    }
  } catch (err) {
    console.warn('markInventoryQrGenerated warning:', err && err.message ? err.message : err);
  }
}

================================================================================
File: _services\request.item.service.js
Size: 27.47 kB
================================================================================

const db = require('_helpers/db-handler');
const Role = require('_helpers/role');
const accountService = require('_services/account.service');

module.exports = {
  createItemRequest,
  listItemRequests,
  getItemRequestById,
  acceptItemRequest,
  declineItemRequest,
  releaseItemRequest,
  fulfillItemRequest
};

async function createItemRequest({ accountId, requesterRoomId, requestToRoomId, itemId, quantity = 1, note = null, ipAddress, browserInfo }) {
  if (!accountId) throw { status: 401, message: 'Unauthenticated' };
  if (!Number.isInteger(quantity) || quantity <= 0) throw { status: 400, message: 'quantity must be positive integer' };

  // Defensive: ensure requestToRoom exists and is stockroom/substockroom (in case service is called directly)
  const requestToRoom = await db.Room.findByPk(requestToRoomId);
  if (!requestToRoom) throw { status: 400, message: 'Invalid requestToRoomId' };
  const rt = String(requestToRoom.roomType || '').toLowerCase();
  if (!['stockroom', 'substockroom'].includes(rt)) {
    throw { status: 403, message: 'Can only request from rooms of type stockroom or substockroom' };
  }

  // first, ensure the itemId exists and belongs to the requestToRoomId
  let resolvedType = null;
  let itemRow = null;

  async function tryInventory(modelName) {
    const M = db[modelName];
    if (!M) return null;
    const candidate = await M.findByPk(itemId);
    if (!candidate) return null;
    const roomFields = ['roomId','locationRoomId','storedRoomId','room_id','stockRoomId'];
    for (const f of roomFields) {
      if (typeof candidate[f] !== 'undefined' && String(candidate[f]) === String(requestToRoomId)) {
        return candidate;
      }
    }
    return null;
  }

  if (db.ApparelInventory) {
    const r = await tryInventory('ApparelInventory');
    if (r) { resolvedType = 'apparel'; itemRow = r; }
  }
  if (!resolvedType && db.AdminSupplyInventory) {
    const r = await tryInventory('AdminSupplyInventory');
    if (r) { resolvedType = 'supply'; itemRow = r; }
  }
  if (!resolvedType && db.GenItemInventory) {
    const r = await tryInventory('GenItemInventory');
    if (r) { resolvedType = 'genItem'; itemRow = r; }
  }

  if (!resolvedType) {
    const unitCandidates = [
      { model: 'Apparel', type: 'apparel' },
      { model: 'AdminSupply', type: 'supply' },
      { model: 'GenItem', type: 'genItem' }
    ];
    for (const cand of unitCandidates) {
      const M = db[cand.model];
      if (!M) continue;
      const u = await M.findByPk(itemId);
      if (!u) continue;
      const roomFields = ['roomId','locationRoomId','storedRoomId','room_id','stockRoomId'];
      for (const f of roomFields) {
        if (typeof u[f] !== 'undefined' && String(u[f]) === String(requestToRoomId)) {
          resolvedType = cand.type; itemRow = u; break;
        }
      }
      if (resolvedType) break;
    }
  }

  if (!resolvedType) {
    throw { status: 400, message: `Item ${itemId} was not found in the inventory (or does not belong to room ${requestToRoomId})` };
  }

  // Create the ItemRequest record (store itemType for downstream compatibility)
  const created = await db.ItemRequest.create({
    accountId,
    requesterRoomId,
    requestToRoomId,
    itemType: resolvedType,
    itemId,
    quantity,
    note,
    status: 'pending'
    , ipAddress, browserInfo
  });

  try {
    await accountService.logActivity(
      String(accountId),
      'item_request_create',
      created.ipAddress,
      created.browserInfo,
      `requestId:${created.itemRequestId}`
    );
  } catch (e) { console.error('activity log failed (createItemRequest)', e); }

  return created;
}

async function listItemRequests({ where = {}, limit = 100, offset = 0 } = {}) {
  return await db.ItemRequest.findAll({
    where,
    order: [['itemRequestId','DESC']],
    limit,
    offset,
    include: [
      { model: db.Room, attributes: ['roomId','roomName'] },
      { model: db.Account, attributes: ['accountId','firstName','lastName'] }
    ]
  });
}
async function getItemRequestById(id) {
  const r = await db.ItemRequest.findByPk(id, {
    include: [{
      model: db.Account,
      attributes: ['accountId', 'firstName', 'lastName']
    }]
  });
  if (!r) throw { status: 404, message: 'ItemRequest not found' };
  return r;
}
async function acceptItemRequest(id, acceptorAccountId, ipAddress, browserInfo) {
  const req = await getItemRequestById(id);
  if (req.status !== 'pending') throw { status: 400, message: 'Only pending requests can be accepted' };

  req.status = 'accepted';
  req.acceptedBy = acceptorAccountId || null;
  req.acceptedAt = new Date();
  await req.save();

  try {
    await accountService.logActivity(
      String(acceptorAccountId),
      'item_request_accept',
      ipAddress,
      browserInfo,
      `requestId:${req.itemRequestId}`
    );
  } catch (e) { console.error('activity log failed (acceptItemRequest)', e); }

  return req;
}
async function declineItemRequest(id, declinerAccountId, reason = null, ipAddress, browserInfo) {
  const req = await getItemRequestById(id);
  if (req.status !== 'pending') throw { status: 400, message: 'Only pending requests can be declined' };
  req.status = 'declined';
  if (reason) req.note = (req.note ? req.note + ' | ' : '') + `Declined: ${reason}`;
  await req.save();

  try {
    await accountService.logActivity(
      String(declinerAccountId),
      'item_request_decline',
      ipAddress,
      browserInfo,
      `requestId:${req.itemRequestId}${reason ? `, reason:${reason}` : ''}`
    );
  } catch (e) { console.error('activity log failed (declineItemRequest)', e); }

  return req;
}
// async function releaseItemRequest(id, releaserAccountId, ipAddress, browserInfo) {
//   const req = await getItemRequestById(id);
//   if (req.status !== 'accepted') throw { status: 400, message: 'Only accepted requests can be released' };

//   const qty = parseInt(req.quantity || 0, 10);
//   if (!Number.isInteger(qty) || qty <= 0) throw { status: 400, message: 'Invalid quantity' };

//   const sequelize = db.sequelize || null;
//   const t = sequelize ? await sequelize.transaction() : null;

//   try {
//     const inv = await resolveInventory(req, { transaction: t });
//     if (!inv) {
//       req.status = 'out_of_stock';
//       await req.save({ transaction: t });
//       if (t) await t.commit();
//       throw { status: 404, message: 'Inventory item not found; request marked out_of_stock' };
//     }

//     const available = inv.totalQuantity || 0;
//     if (available < qty) {
//       req.status = 'out_of_stock';
//       await req.save({ transaction: t });
//       if (t) await t.commit();
//       throw { status: 400, message: `Not enough stock to release (${available} available); request marked out_of_stock` };
//     }

//     const requester = await db.Account.findByPk(req.accountId || req.acccountId, { transaction: t });
//     const requesterName = requester ? `${requester.firstName || ''} ${requester.lastName || ''}`.trim() : String(req.accountId || req.acccountId);

//     const releaseBatch = await createReleaseForType(req, inv, qty, requesterName, releaserAccountId, { transaction: t });

//     req.status = 'released';
//     req.releasedBy = releaserAccountId || null;
//     req.releasedAt = new Date();
//     await req.save({ transaction: t });

//     try {
//       await accountService.logActivity(
//         String(releaserAccountId),
//         'item_request_release',
//         ipAddress,
//         browserInfo,
//         `requestId:${req.itemRequestId}, qty:${qty}`
//       );
//     } catch (e) { console.error('activity log failed (releaseItemRequest)', e); }

//     if (t) await t.commit();
//     return { request: req, releaseBatch };
//   } catch (err) {
//     if (t) {
//       try { await t.rollback(); } catch (e) {}
//     }
//     try {
//       const fresh = await db.ItemRequest.findByPk(id);
//       if (fresh && fresh.status === 'accepted') {
//         fresh.status = 'out_of_stock';
//         await fresh.save();
//       }
//     } catch (e) {}
//     throw err;
//   }
// }
// async function fulfillItemRequest(id, fulfillerAccountId, ipAddress, browserInfo) {
//   const req = await getItemRequestById(id);
//   if (req.status !== 'released') throw { status: 400, message: 'Only released requests can be fulfilled by the requester' };

//   req.status = 'fulfilled';
//   req.fulfilledBy = fulfillerAccountId || null;
//   req.fulfilledAt = new Date();
//   await req.save();

//   try {
//     await accountService.logActivity(
//       String(fulfillerAccountId),
//       'item_request_fulfill',
//       ipAddress,
//       browserInfo,
//       `requestId:${req.itemRequestId}`
//     );
//   } catch (e) { console.error('activity log failed (fulfillItemRequest)', e); }

//   return req;
// }

async function releaseItemRequest(requestId, user, ipAddress = '', browserInfo = '') {
  const rid = Number(requestId);
  if (!Number.isFinite(rid) || rid <= 0) throw { status: 400, message: 'Invalid request id' };

  const result = await db.sequelize.transaction(async (t) => {
    const reqRow = await db.ItemRequest.findByPk(rid, { transaction: t, lock: t.LOCK.UPDATE });
    if (!reqRow) throw { status: 404, message: 'Item request not found' };

    // must be in accepted state to release (adjust to your actual statuses)
    if (reqRow.status !== 'accepted') throw { status: 400, message: `Cannot release request in status '${reqRow.status}'` };

    // ensure itemId exists (common cause of "not found")
    const itemId = reqRow.itemId;
    if (!itemId) {
      // more helpful error so you can debug acceptance flow
      throw { status: 400, message: 'ItemRequest.itemId is null or missing. Ensure accept flow sets the inventory itemId before release.' };
    }

    // find inventory row (search across inventory tables)
    const invInfo = await getInventoryModelForItemId(itemId, t);
    if (!invInfo) {
      // mark request out_of_stock (your existing logic did this)
      reqRow.status = 'out_of_stock';
      reqRow.outOfStockAt = new Date();
      await reqRow.save({ transaction: t });
      throw { status: 400, message: 'Inventory item not found; request marked out_of_stock' };
    }

    const inv = invInfo.row;
    const qty = Number(reqRow.quantity || 0);
    if (!Number.isFinite(qty) || qty <= 0) throw { status: 400, message: 'Invalid request quantity' };

    const available = Number(inv.totalQuantity || 0);
    if (available < qty) {
      // not enough stock -> mark out_of_stock and return
      reqRow.status = 'out_of_stock';
      reqRow.outOfStockAt = new Date();
      await reqRow.save({ transaction: t });
      throw { status: 400, message: `Insufficient stock (have ${available}, need ${qty}). Request marked out_of_stock.` };
    }

    // decrease inventory
    inv.totalQuantity = Math.max(0, available - qty);
    await inv.save({ transaction: t });

    // mark request released
    reqRow.status = 'released';
    reqRow.releasedBy = String(user?.accountId ?? user?.id ?? user?.userId ?? '');
    reqRow.releasedAt = new Date();
    await reqRow.save({ transaction: t });

    return { reqRow, invInfo };
  });

  // activity log (best-effort) — include ip/browser if provided
  try {
    await accountService.logActivity(
      String(user?.accountId ?? user?.id ?? user?.userId ?? ''),
      'itemrequest_release',
      ipAddress || '',
      browserInfo || '',
      `requestId:${result.reqRow.requestId}`
    );
  } catch (err) {
    console.error('activity log failed (releaseItemRequest)', err);
  }

  return result.reqRow;
}

// /**
//  * fulfillItemRequest
//  * - After release, mark request fulfilled/closed; adjust other flags as needed.
//  */
// async function fulfillItemRequest(requestId, user, ipAddress = '', browserInfo = '') {
//   const rid = Number(requestId);
//   if (!Number.isFinite(rid) || rid <= 0) throw { status: 400, message: 'Invalid request id' };

//   const result = await db.sequelize.transaction(async (t) => {
//     const reqRow = await db.ItemRequest.findByPk(rid, { transaction: t, lock: t.LOCK.UPDATE });
//     if (!reqRow) throw { status: 404, message: 'Item request not found' };

//     // require released -> fulfill. If your flow uses a different status, adapt this.
//     if (reqRow.status !== 'released') throw { status: 400, message: `Only released requests can be fulfilled. Current status: '${reqRow.status}'` };

//     reqRow.status = 'fulfilled';
//     reqRow.fulfilledBy = String(user?.accountId ?? user?.id ?? user?.userId ?? '');
//     reqRow.fulfilledAt = new Date();
//     await reqRow.save({ transaction: t });

//     return reqRow;
//   });

//   // activity log
//   try {
//     await accountService.logActivity(
//       String(user?.accountId ?? user?.id ?? user?.userId ?? ''),
//       'itemrequest_fulfill',
//       ipAddress || '',
//       browserInfo || '',
//       `requestId:${result.requestId}`
//     );
//   } catch (err) {
//     console.error('activity log failed (fulfillItemRequest)', err);
//   }

//   return result;
// }
async function findInventoryAndType(itemId, itemType, options = {}) {
  const id = Number(itemId);
  if (!Number.isFinite(id) || id <= 0) return null;
  const tOpt = options.transaction ? { transaction: options.transaction } : {};

  // apparel: try inventory first, then unit
  if (String(itemType).toLowerCase().includes('apparel')) {
    const inv = await db.ApparelInventory.findByPk(id, tOpt);
    if (inv) return { inv, type: 'apparel' };
    const unit = await db.Apparel.findByPk(id, tOpt);
    if (unit) return { unit, type: 'apparel' };
    return null;
  }

  // admin supplies / supplies
  if (String(itemType).toLowerCase().includes('supply') || String(itemType).toLowerCase() === 'admin-supply') {
    const inv = await db.AdminSupplyInventory.findByPk(id, tOpt);
    if (inv) return { inv, type: 'supply' };
    const unit = await db.AdminSupply.findByPk(id, tOpt);
    if (unit) return { unit, type: 'supply' };
    return null;
  }

  // gen items / IT / maintenance / general items
  if (['genitem', 'gen-item', 'gen_item', 'gen item', 'it', 'maintenance'].includes(String(itemType).toLowerCase())) {
    const inv = await db.GenItemInventory.findByPk(id, tOpt);
    if (inv) return { inv, type: 'genitem' };
    const unit = await db.GenItem.findByPk(id, tOpt);
    if (unit) return { unit, type: 'genitem' };
    return null;
  }

  // fallback: try to find by unit or inventory generically
  // try apparel unit/inv as default
  const inv = await db.ApparelInventory.findByPk(id, tOpt);
  if (inv) return { inv, type: 'apparel' };
  const unit = await db.Apparel.findByPk(id, tOpt);
  if (unit) return { unit, type: 'apparel' };

  return null;
}
async function fulfillItemRequest(requestId, user, ipAddress = '', browserInfo = '') {
  const rid = Number(requestId);
  if (!Number.isFinite(rid) || rid <= 0) throw { status: 400, message: 'Invalid request id' };

  const result = await db.sequelize.transaction(async (t) => {
    const reqRow = await db.ItemRequest.findByPk(rid, { transaction: t, lock: t.LOCK.UPDATE });
    if (!reqRow) throw { status: 404, message: 'Item request not found' };

    // require released -> fulfill
    if (String(reqRow.status) !== 'released') throw { status: 400, message: `Only released requests can be fulfilled. Current status: '${reqRow.status}'` };

    // find the inventory/unit that was released (helper already in file)
    const found = await findInventoryAndType(reqRow.itemId, reqRow.itemType);
    if (!found || (!found.inv && !found.unit)) {
      // mark failed and save
      reqRow.status = 'failed_request';
      await reqRow.save({ transaction: t });
      throw { status: 404, message: 'Could not locate inventory item to fulfill request; request marked failed' };
    }

    const qty = Number(reqRow.quantity || 0);
    if (!Number.isFinite(qty) || qty <= 0) {
      throw { status: 400, message: 'Invalid request quantity' };
    }

    // Use requesterRoomId as destination room
    const destRoomId = Number(reqRow.requesterRoomId);
    if (!Number.isFinite(destRoomId) || destRoomId <= 0) {
      throw { status: 400, message: 'Invalid requesterRoomId on request' };
    }

    // get an example inventory record for metadata (name/size/etc.)
    const exampleInv = found.inv || (found.unit ? await resolveInventoryFromUnit(found) : null);
    if (!exampleInv) {
      reqRow.status = 'failed_request';
      await reqRow.save({ transaction: t });
      throw { status: 404, message: 'Could not resolve inventory metadata for fulfillment' };
    }

    // small helper for unit status
    function getUnitStatusForType(type) {
      if (String(type) === 'apparel') return 'good';
      return 'in_stock';
    }

    // create/update destination inventory and create receive batch + units (transactional)
    let createdBatch = null;

    if (String(found.type) === 'apparel') {
      const where = {
        roomId: destRoomId,
        apparelName: exampleInv.apparelName,
        apparelLevel: exampleInv.apparelLevel,
        apparelType: exampleInv.apparelType,
        apparelFor: exampleInv.apparelFor,
        apparelSize: exampleInv.apparelSize
      };
      const [destInv] = await db.ApparelInventory.findOrCreate({ where, defaults: Object.assign({ totalQuantity: 0 }, where), transaction: t });
      destInv.totalQuantity = (destInv.totalQuantity || 0) + qty;
      await destInv.save({ transaction: t });

      createdBatch = await db.ReceiveApparel.create({
        roomId: destRoomId,
        receivedFrom: `ItemRequest #${reqRow.itemRequestId}`,
        receivedBy: String(user?.accountId ?? user?.id ?? null),
        apparelName: destInv.apparelName,
        apparelLevel: destInv.apparelLevel,
        apparelType: destInv.apparelType,
        apparelFor: destInv.apparelFor,
        apparelSize: destInv.apparelSize,
        apparelQuantity: qty
      }, { transaction: t });

      if (db.Apparel && qty > 0) {
        const apparelUnits = Array(qty).fill().map(() => ({
          receiveApparelId: createdBatch.receiveApparelId,
          apparelInventoryId: destInv.apparelInventoryId ?? destInv.id,
          roomId: destRoomId,
          status: getUnitStatusForType(found.type)
        }));
        await db.Apparel.bulkCreate(apparelUnits, { transaction: t });
      }
    }
    else if (String(found.type) === 'supply' || String(found.type) === 'admin-supply') {
      const where = {
        roomId: destRoomId,
        supplyName: exampleInv.supplyName,
        supplyMeasure: exampleInv.supplyMeasure
      };
      const [destInv] = await db.AdminSupplyInventory.findOrCreate({ where, defaults: Object.assign({ totalQuantity: 0 }, where), transaction: t });
      destInv.totalQuantity = (destInv.totalQuantity || 0) + qty;
      await destInv.save({ transaction: t });

      createdBatch = await db.ReceiveAdminSupply.create({
        roomId: destRoomId,
        receivedFrom: `ItemRequest #${reqRow.itemRequestId}`,
        receivedBy: String(user?.accountId ?? user?.id ?? null),
        supplyName: destInv.supplyName,
        supplyQuantity: qty,
        supplyMeasure: destInv.supplyMeasure
      }, { transaction: t });

      if (db.AdminSupply && qty > 0) {
        const units = Array(qty).fill().map(() => ({
          receiveAdminSupplyId: createdBatch.receiveAdminSupplyId,
          adminSupplyInventoryId: destInv.adminSupplyInventoryId ?? destInv.id,
          roomId: destRoomId,
          status: 'in_stock'
        }));
        await db.AdminSupply.bulkCreate(units, { transaction: t });
      }
    }
    else if (String(found.type) === 'genitem' || String(found.type) === 'it' || String(found.type) === 'maintenance') {
      const where = {
        roomId: destRoomId,
        genItemName: exampleInv.genItemName,
        genItemSize: exampleInv.genItemSize ?? null,
        genItemType: exampleInv.genItemType
      };
      const [destInv] = await db.GenItemInventory.findOrCreate({ where, defaults: Object.assign({ totalQuantity: 0 }, where), transaction: t });
      destInv.totalQuantity = (destInv.totalQuantity || 0) + qty;
      await destInv.save({ transaction: t });

      createdBatch = await db.ReceiveGenItem.create({
        roomId: destRoomId,
        receivedFrom: `ItemRequest #${reqRow.itemRequestId}`,
        receivedBy: String(user?.accountId ?? user?.id ?? null),
        genItemName: destInv.genItemName,
        genItemSize: destInv.genItemSize ?? null,
        genItemQuantity: qty,
        genItemType: destInv.genItemType
      }, { transaction: t });

      if (db.GenItem && qty > 0) {
        const units = Array(qty).fill().map(() => ({
          receiveGenItemId: createdBatch.receiveGenItemId,
          genItemInventoryId: destInv.genItemInventoryId ?? destInv.id,
          roomId: destRoomId,
          status: 'in_stock'
        }));
        await db.GenItem.bulkCreate(units, { transaction: t });
      }
    } else {
      // unsupported type — mark failed
      reqRow.status = 'failed_request';
      await reqRow.save({ transaction: t });
      throw { status: 400, message: `Unsupported item type for fulfillment: ${found.type}` };
    }

    // finally mark request fulfilled
    reqRow.status = 'fulfilled';
    reqRow.fulfilledBy = String(user?.accountId ?? user?.id ?? '');
    reqRow.fulfilledAt = new Date();
    await reqRow.save({ transaction: t });

    return { request: reqRow, createdBatch };
  });

  // activity log (best-effort)
  try {
    await accountService.logActivity(
      String(user?.accountId ?? user?.id ?? ''),
      'itemrequest_fulfill',
      ipAddress || '',
      browserInfo || '',
      `requestId:${result.request.itemRequestId || result.request.id}`
    );
  } catch (err) {
    console.error('activity log failed (fulfillItemRequest log)', err);
  }

  return result;
}






/* ---------------- Helpers ---------------- */

async function resolveInventory(req, opts = {}) {
  const txOpt = opts.transaction ? { transaction: opts.transaction } : {};
  if (req.itemType === 'apparel') {
    let inv = await db.ApparelInventory.findByPk(req.itemId, txOpt);
    if (inv) return inv;
    const unit = await db.Apparel.findByPk(req.itemId, txOpt);
    if (unit?.apparelInventoryId) return await db.ApparelInventory.findByPk(unit.apparelInventoryId, txOpt);
    return null;
  }

  if (req.itemType === 'supply') {
    let inv = await db.AdminSupplyInventory.findByPk(req.itemId, txOpt);
    if (inv) return inv;
    const unit = await db.AdminSupply.findByPk(req.itemId, txOpt);
    if (unit?.adminSupplyInventoryId) return await db.AdminSupplyInventory.findByPk(unit.adminSupplyInventoryId, txOpt);
    return null;
  }

  if (req.itemType === 'genItem') {
    let inv = await db.GenItemInventory.findByPk(req.itemId, txOpt);
    if (inv) return inv;
    const unit = await db.GenItem.findByPk(req.itemId, txOpt);
    if (unit?.genItemInventoryId) return await db.GenItemInventory.findByPk(unit.genItemInventoryId, txOpt);
    return null;
  }

  return null;
}
async function createReleaseForType(req, inv, qty, requesterName, releaserAccountId, opts = {}) {
  const tx = opts.transaction ? { transaction: opts.transaction } : {};
  const releaserLabel = releaserAccountId ? String(releaserAccountId) : 'Stockroom';

  if (req.itemType === 'apparel') {
    const release = await db.ReleaseApparel.create({
      roomId:                 inv.roomId,
      apparelInventoryId:     inv.apparelInventoryId ?? inv.id,
      releasedBy:             releaserLabel,
      claimedBy:              requesterName,
      releaseApparelQuantity: qty
    }, tx);

    // deduct inventory aggregate
    inv.totalQuantity = (inv.totalQuantity || 0) - qty;
    await inv.save(tx);

    // mark per-unit Apparel rows as released (best-effort)
    if (db.Apparel && qty > 0) {
      const units = await db.Apparel.findAll({
        where: { apparelInventoryId: inv.apparelInventoryId ?? inv.id, status: 'good' }, // 'good' is your in-stock apparel enum
        limit: qty,
        order: [['apparelId', 'ASC']],
        ...tx
      });
      await Promise.all(units.map(u => { u.status = 'released'; return u.save(tx); }));
    }

    return release;
  }

  if (req.itemType === 'supply') {
    let release = null;
    if (db.ReleaseAdminSupply) {
      release = await db.ReleaseAdminSupply.create({
        roomId:                     inv.roomId,
        adminSupplyInventoryId:     inv.adminSupplyInventoryId ?? inv.id,
        releasedBy:                 releaserLabel,
        claimedBy:                  requesterName,
        releaseAdminSupplyQuantity: qty
      }, tx);
    } else {
      release = { note: 'AdminSupply released (no ReleaseAdminSupply model)', inventoryId: inv.adminSupplyInventoryId ?? inv.id, qty };
    }

    inv.totalQuantity = (inv.totalQuantity || 0) - qty;
    await inv.save(tx);

    if (db.AdminSupply && qty > 0) {
      const units = await db.AdminSupply.findAll({
        where: { adminSupplyInventoryId: inv.adminSupplyInventoryId ?? inv.id, status: 'in_stock' },
        limit: qty,
        order: [['adminSupplyId', 'ASC']],
        ...tx
      });
      await Promise.all(units.map(u => { u.status = 'released'; return u.save(tx); }));
    }

    return release;
  }

  if (req.itemType === 'genItem') {
    const release = await db.ReleaseGenItem.create({
      roomId:                inv.roomId,
      genItemInventoryId:    inv.genItemInventoryId ?? inv.id,
      releasedBy:            releaserLabel,
      claimedBy:             requesterName,
      releaseItemQuantity:   qty,
      genItemType:           inv.genItemType
    }, tx);

    inv.totalQuantity = (inv.totalQuantity || 0) - qty;
    await inv.save(tx);

    if (db.GenItem && qty > 0) {
      const units = await db.GenItem.findAll({
        where: { genItemInventoryId: inv.genItemInventoryId ?? inv.id, status: 'in_stock' },
        limit: qty,
        order: [['genItemId', 'ASC']],
        ...tx
      });
      await Promise.all(units.map(u => { u.status = 'released'; return u.save(tx); }));
    }

    return release;
  }

  throw { status: 500, message: 'Unsupported itemType for release' };
}
async function getInventoryModelForItemId(id, transaction) {
  if (!id) return null;
  const candidates = [
    { key: 'apparel', model: db.ApparelInventory },
    { key: 'supply',  model: db.AdminSupplyInventory },
    { key: 'genitem', model: db.GenItemInventory }
  ];

  for (const c of candidates) {
    if (!c.model) continue;
    const opts = transaction ? { transaction, lock: transaction.LOCK.UPDATE } : {};
    const r = await c.model.findByPk(id, opts);
    if (r) return { key: c.key, model: c.model, row: r };
  }
  return null;
}

================================================================================
File: _services\request.stock.service.js
Size: 16.45 kB
================================================================================

const db = require('_helpers/db-handler');
const accountService = require('_services/account.service');

module.exports = {
  createStockRequest,
  listStockRequests,
  getStockRequestById,
  approveStockRequest,
  disapproveStockRequest,
  fulfillStockRequest
};

async function createStockRequest({ accountId, requesterRoomId, itemId, quantity = 1, note = null, ipAddress, browserInfo }) {
  if (!accountId) throw { status: 400, message: 'accountId is required' };
  if (!Number.isInteger(quantity) || quantity <= 0) throw { status: 400, message: 'quantity must be a positive integer' };

  // determine itemType by checking inventory tables first, then unit tables
  let resolvedType = null;

  // helper short-circuit checks (check inventories)
  if (db.ApparelInventory) {
    const inv = await db.ApparelInventory.findByPk(itemId);
    if (inv) resolvedType = 'apparel';
  }
  if (!resolvedType && db.AdminSupplyInventory) {
    const inv = await db.AdminSupplyInventory.findByPk(itemId);
    if (inv) resolvedType = 'supply';
  }
  if (!resolvedType && db.GenItemInventory) {
    const inv = await db.GenItemInventory.findByPk(itemId);
    if (inv) resolvedType = 'genItem';
  }

  // if not inventory, check unit tables (individual items/units)
  if (!resolvedType) {
    if (db.Apparel) {
      const unit = await db.Apparel.findByPk(itemId);
      if (unit) resolvedType = 'apparel';
    }
    if (!resolvedType && db.AdminSupply) {
      const unit = await db.AdminSupply.findByPk(itemId);
      if (unit) resolvedType = 'supply';
    }
    if (!resolvedType && db.GenItem) {
      const unit = await db.GenItem.findByPk(itemId);
      if (unit) resolvedType = 'genItem';
    }
  }

  if (!resolvedType) {
    throw { status: 400, message: `Item id ${itemId} not found in inventories or units` };
  }

  // create stock request — store the resolved itemType for downstream flows
  const req = await db.StockRequest.create({
    accountId,
    requesterRoomId,
    itemType: resolvedType,
    itemId,
    quantity,
    note,
    status: 'pending'
  });

  try {
    await accountService.logActivity(String(accountId), 'stock_request_create', ipAddress, browserInfo, `stockRequestId:${req.stockRequestId}`);
  } catch (err) {
    console.error('activity log failed (createStockRequest)', err);
  }

  return req;
}
async function listStockRequests({ where = {}, limit = 100, offset = 0 } = {}) {
  return await db.StockRequest.findAll({
    where,
    order: [['stockRequestId','DESC']],
    limit,
    offset,
    include: [
      { model: db.Room, attributes: ['roomId','roomName'] },
      { model: db.Account, attributes: ['accountId','firstName','lastName'] }
    ]
  });
}
async function getStockRequestById(stockRequestId) {
  const r = await db.StockRequest.findByPk(stockRequestId, {
    include: [{
      model: db.Account,
      attributes: ['accountId', 'firstName', 'lastName']
    }]
  });
  if (!r) throw { status: 404, message: 'StockRequest not found' };

  try {
    const requestedItem = await _loadRequestedItem(r.itemId, r.itemType);
    if (typeof r.setDataValue === 'function') r.setDataValue('requestedItem', requestedItem);
    else r.requestedItem = requestedItem;
  } catch (err) {
    console.error('getStockRequestById - requested item load failed:', err);
    if (typeof r.setDataValue === 'function') r.setDataValue('requestedItem', null);
    else r.requestedItem = null;
  }

  return r;
}
async function approveStockRequest(id, approverAccountId = null, ipAddress, browserInfo) {
  const req = await getStockRequestById(id);
  if (req.status !== 'pending') throw { status: 400, message: 'Only pending requests can be approved' };
  req.status = 'approved';
  await req.save();

  try {
    await accountService.logActivity( String(approverAccountId), 'stock_request_approve', ipAddress, browserInfo, `stockRequestId:${req.stockRequestId}`);
  } catch (err) {
    console.error('activity log failed (approveStockRequest)', err);
  }

  return req;
}
async function disapproveStockRequest(id, adminAccountId = null, reason = null, ipAddress, browserInfo) {
  const req = await getStockRequestById(id);
  if (req.status !== 'pending') throw { status: 400, message: 'Only pending requests can be disapproved' };
  req.status = 'disapproved';
  if (reason) req.note = (req.note ? req.note + ' | ' : '') + `Disapproved: ${reason}`;
  await req.save();

  try {
    await accountService.logActivity(String(adminAccountId), 'stock_request_disapprove', ipAddress, browserInfo, `stockRequestId:${req.stockRequestId || req.id}${reason ? `, reason:${reason}` : ''}`);
  } catch (err) {
    console.error('activity log failed (disapproveStockRequest)', err);
  }

  return req;
}
async function fulfillStockRequest(stockRequestId, fulfillerAccountId, ipAddress, browserInfo) {
  const req = await db.StockRequest.findByPk(stockRequestId);
  if (!req) throw { status: 404, message: 'StockRequest not found' };
  if (req.status !== 'approved') throw { status: 400, message: 'Only approved requests can be fulfilled' };

  const found = await findInventoryAndType(req.itemId, req.itemType);
  if (!found || (!found.inv && !found.unit)) {
    req.status = 'failed_request';
    await req.save();
    throw { status: 404, message: 'Could not locate inventory item to fulfill request; marked as failed' };
  }

  const qty = parseInt(req.quantity || 0, 10);
  if (!Number.isInteger(qty) || qty <= 0) throw { status: 400, message: 'Invalid request quantity' };

  try {
    const createdBatch = await createReceiveAndUnits(found, qty, fulfillerAccountId || req.acccountId || 0);

    if (found.inv) await updateInventory(found.inv, qty);
    else {
      if (found.unit) {
        const inv = await resolveInventoryFromUnit(found);
        if (inv) await updateInventory(inv, qty);
      }
    }

    req.status = 'fulfilled';
    await req.save();

    try {
      await accountService.logActivity(String(fulfillerAccountId), 'stock_request_fulfill', ipAddress, browserInfo, `stockRequestId:${req.stockRequestId}`);
    } catch (err) {
      console.error('activity log failed (fulfillStockRequest - log)', err);
    }

    return { request: req, createdBatch };
  } catch (err) {
    if (req.status !== 'failed_request' && req.status !== 'fulfilled') {
      req.status = 'failed_request';
      await req.save();
    }
    throw err;
  }
}

/* ---------- Helpers (kept local for drop-in) ---------- */
async function findInventoryAndType(id, preferredType) {
  if (!id) return null;

  const normalizeType = t => (typeof t === 'string' ? String(t).toLowerCase() : t);

  if (preferredType) {
    const pref = normalizeType(preferredType);
    const model = getInventoryModel(pref === 'genitem' ? 'genItem' : pref);
    if (model) {
      const inv = await model.findByPk(id);
      if (inv) return { type: pref, inv };
    }
    if (pref === 'apparel' && db.Apparel) {
      const u = await db.Apparel.findByPk(id);
      if (u) {
        const inv = await resolveInventoryFromUnit({ type: 'apparel', unit: u }).catch(() => null);
        return { type: 'apparel', unit: u, inv: inv || null };
      }
    }
    if ((pref === 'supply' || pref === 'admin-supply') && db.AdminSupply) {
      const u = await db.AdminSupply.findByPk(id);
      if (u) {
        const inv = await resolveInventoryFromUnit({ type: 'supply', unit: u }).catch(() => null);
        return { type: 'supply', unit: u, inv: inv || null };
      }
    }
    if ((pref === 'genitem' || pref === 'it' || pref === 'maintenance') && db.GenItem) {
      const u = await db.GenItem.findByPk(id);
      if (u) {
        const inv = await resolveInventoryFromUnit({ type: 'genitem', unit: u }).catch(() => null);
        return { type: 'genitem', unit: u, inv: inv || null };
      }
    }
  }

  if (db.ApparelInventory) {
    const inv = await db.ApparelInventory.findByPk(id);
    if (inv) return { type: 'apparel', inv };
  }
  if (db.AdminSupplyInventory) {
    const inv = await db.AdminSupplyInventory.findByPk(id);
    if (inv) return { type: 'supply', inv };
  }
  if (db.GenItemInventory) {
    const inv = await db.GenItemInventory.findByPk(id);
    if (inv) return { type: 'genitem', inv };
  }

  if (db.Apparel) {
    const u = await db.Apparel.findByPk(id);
    if (u) {
      const inv = await resolveInventoryFromUnit({ type: 'apparel', unit: u }).catch(() => null);
      return { type: 'apparel', unit: u, inv: inv || null };
    }
  }
  if (db.AdminSupply) {
    const u = await db.AdminSupply.findByPk(id);
    if (u) {
      const inv = await resolveInventoryFromUnit({ type: 'supply', unit: u }).catch(() => null);
      return { type: 'supply', unit: u, inv: inv || null };
    }
  }
  if (db.GenItem) {
    const u = await db.GenItem.findByPk(id);
    if (u) {
      const inv = await resolveInventoryFromUnit({ type: 'genitem', unit: u }).catch(() => null);
      return { type: 'genitem', unit: u, inv: inv || null };
    }
  }

  return null;
}
async function resolveInventoryFromUnit(found) {
  try {
    if (found.type === 'apparel' && found.unit.apparelInventoryId) {
      return await db.ApparelInventory.findByPk(found.unit.apparelInventoryId);
    }
    if (found.type === 'supply' && found.unit.adminSupplyInventoryId) {
      return await db.AdminSupplyInventory.findByPk(found.unit.adminSupplyInventoryId);
    }
    if (found.type === 'genitem' && found.unit.genItemInventoryId) {
      return await db.GenItemInventory.findByPk(found.unit.genItemInventoryId);
    }
  } catch (e) {
    return null;
  }
  return null;
}
function getUnitStatusForType(type) {
  if (type === 'apparel') return 'good';
  if (type === 'supply') return 'in_stock';
  if (type === 'genitem') return 'in_stock';
  return 'in_stock';
}
async function createReceiveAndUnits(found, qty, fulfillerAccountId) {
  if (found.type === 'apparel') {
    const inv = found.inv || (found.unit ? await resolveInventoryFromUnit(found) : null);
    if (!inv) throw { status: 404, message: 'Apparel inventory record not found' };

    const batch = await db.ReceiveApparel.create({
      roomId:          inv.roomId,
      receivedFrom:    'Administration',
      receivedBy:      fulfillerAccountId,
      apparelName:     inv.apparelName,
      apparelLevel:    inv.apparelLevel,
      apparelType:     inv.apparelType,
      apparelFor:      inv.apparelFor,
      apparelSize:     inv.apparelSize,
      apparelQuantity: qty
    });

    const unitStatus = getUnitStatusForType(found.type);

if (db.Apparel && qty > 0) {
  const apparelUnits = Array(qty).fill().map(() => ({
    receiveApparelId: batch.receiveApparelId,
    apparelInventoryId: inv.apparelInventoryId ?? inv.id,
    roomId: inv.roomId,
    status: unitStatus
  }));
  await db.Apparel.bulkCreate(apparelUnits);
}

    return batch;
  }

  if (found.type === 'supply') {
    const inv = found.inv || (found.unit ? await resolveInventoryFromUnit(found) : null);
    if (!inv) throw { status: 404, message: 'AdminSupply inventory record not found' };

    const batch = await db.ReceiveAdminSupply.create({
      roomId:        inv.roomId,
      receivedFrom:  'Administration',
      receivedBy:    fulfillerAccountId,
      supplyName:    inv.supplyName,
      supplyQuantity: qty,
      supplyMeasure: inv.supplyMeasure
    });

    if (db.AdminSupply && qty > 0) {
      const units = Array(qty).fill().map(() => ({
        receiveAdminSupplyId: batch.receiveAdminSupplyId,
        adminSupplyInventoryId: inv.adminSupplyInventoryId ?? inv.id,
        roomId: inv.roomId,
        status: 'in_stock'
      }));
      await db.AdminSupply.bulkCreate(units);
    }

    return batch;
  }

  if (found.type === 'genitem') {
    const inv = found.inv || (found.unit ? await resolveInventoryFromUnit(found) : null);
    if (!inv) throw { status: 404, message: 'GenItem inventory record not found' };

    const batch = await db.ReceiveGenItem.create({
      roomId:         inv.roomId,
      receivedFrom:   'Administration',
      receivedBy:     fulfillerAccountId,
      genItemName:    inv.genItemName,
      genItemSize:    inv.genItemSize ?? null,
      genItemQuantity: qty,
      genItemType:    inv.genItemType
    });

    if (db.GenItem && qty > 0) {
      const units = Array(qty).fill().map(() => ({
        receiveGenItemId: batch.receiveGenItemId,
        roomId: inv.roomId,
        status: 'in_stock'
      }));
      await db.GenItem.bulkCreate(units);
    }

    return batch;
  }

  throw { status: 500, message: 'Unsupported inventory type' };
}
async function updateInventory(inv, qty) {
  if (!inv) return;
  if (typeof inv.totalQuantity !== 'undefined') {
    inv.totalQuantity = (inv.totalQuantity || 0) + qty;
    await inv.save();
    return;
  }
  if (typeof inv.supplyQuantity !== 'undefined') {
    inv.supplyQuantity = (inv.supplyQuantity || 0) + qty;
    await inv.save();
    return;
  }
  if (typeof inv.quantity !== 'undefined') {
    inv.quantity = (inv.quantity || 0) + qty;
    await inv.save();
    return;
  }

  throw { status: 500, message: 'Inventory does not have known quantity field' };
}
function getInventoryModel(itemType) {
  if (itemType === 'apparel') return db.ApparelInventory;
  if (itemType === 'supply') return db.AdminSupplyInventory;
  if (itemType === 'genItem') return db.GenItemInventory;
  return;
}
async function _loadRequestedItem(itemId, itemTypeRaw) {
  if (!itemId) return null;

  const typeNorm = String(itemTypeRaw || '').toLowerCase();

  const invModel = getInventoryModel(itemTypeRaw);
  if (invModel) {
    const inv = await invModel.findByPk(itemId);
    if (inv) return { kind: 'inventory', type: typeNorm || 'unknown', inventory: inv, unit: null };
  }

  const unitResult = await _tryLoadUnitByType(itemId, typeNorm);
  if (unitResult) return unitResult;

  return await _tryLoadAnyUnit(itemId);
}
async function _tryLoadUnitByType(itemId, typeNorm) {
  try {
    if (typeNorm.includes('apparel')) {
      if (db.Apparel) {
        const unit = await db.Apparel.findByPk(itemId);
        if (unit) {
          const inv = await resolveInventoryFromUnit({ type: 'apparel', unit }).catch(() => null);
          return { kind: 'unit', type: 'apparel', unit, inventory: inv || null };
        }
      }
    } else if (typeNorm.includes('supply') || typeNorm === 'supply') {
      if (db.AdminSupply) {
        const unit = await db.AdminSupply.findByPk(itemId);
        if (unit) {
          const inv = await resolveInventoryFromUnit({ type: 'supply', unit }).catch(() => null);
          return { kind: 'unit', type: 'supply', unit, inventory: inv || null };
        }
      }
    } else if (typeNorm.includes('gen') || typeNorm === 'genitem' || typeNorm === 'gen-item') {
      if (db.GenItem) {
        const unit = await db.GenItem.findByPk(itemId);
        if (unit) {
          const inv = await resolveInventoryFromUnit({ type: 'genitem', unit }).catch(() => null);
          return { kind: 'unit', type: 'genitem', unit, inventory: inv || null };
        }
      }
    }
  } catch (e) {
    throw e;
  }
  return null;
}
async function _tryLoadAnyUnit(itemId) {
  // Apparel
  if (db.Apparel) {
    const unit = await db.Apparel.findByPk(itemId);
    if (unit) {
      const inv = await resolveInventoryFromUnit({ type: 'apparel', unit }).catch(() => null);
      return { kind: 'unit', type: 'apparel', unit, inventory: inv || null };
    }
  }

  // AdminSupply
  if (db.AdminSupply) {
    const unit = await db.AdminSupply.findByPk(itemId);
    if (unit) {
      const inv = await resolveInventoryFromUnit({ type: 'supply', unit }).catch(() => null);
      return { kind: 'unit', type: 'supply', unit, inventory: inv || null };
    }
  }

  // GenItem
  if (db.GenItem) {
    const unit = await db.GenItem.findByPk(itemId);
    if (unit) {
      const inv = await resolveInventoryFromUnit({ type: 'genitem', unit }).catch(() => null);
      return { kind: 'unit', type: 'genitem', unit, inventory: inv || null };
    }
  }

  return null;
}

================================================================================
File: _services\room.service.js
Size: 33.67 kB
================================================================================

const db        = require('_helpers/db-handler');
const Role      = require('_helpers/role');
const qrService = require('_services/qr.service');
const accountService = require('_services/account.service');

module.exports = {
  // POST -------------------------------------------------------------------------------------
  createRoomHandler,                  // create new room.
  ensureIsStockroomHandler,           // will check if the type of a room is stockroom or sub stockroom
  ensureRoomExistsHandler,

  receiveInStockroomHandler,          // recieve in stockroom and it will route to the specific recieve functions depends on its payload.
  receiveApparelInRoomHandler,        // receive apparel function with its payload.
  receiveAdminSupplyInRoomHandler,    // receive admin supply function and its payload.
  receiveGenItemInRoomHandler,        // receive general item function and its payload.

  releaseInStockroomHandler,          // release in stockroom and it will route to the specific recieve functions depends on its payload.
  releaseApparelInRoomHandler,        // release apparel function with its payload.
  releaseAdminSupplyInRoomHandler,
  releaseGenItemInRoomHandler,

  // POST & GET --------------------------------------------------------------------------------
  generateApparelBatchForRoom,
  generateAdminSupplyBatchForRoom,
  generateGenItemBatchForRoom,

  generateApparelUnitForRoom,
  generateAdminSupplyUnitForRoom,
  generateGenItemUnitForRoom,

  // GET -------------------------------------------------------------------------------------
  getRoomsHandler,                    // display all rooms.
  getRoomByIdHandler,                 // display a specific room.

  getReceiveApparelsByRoomHandler,
  getReceiveAdminSupplyByRoomHandler,
  getReceiveGenItemByRoomHandler,
  
  getApparelInventoryByRoomHandler,
  getAdminSupplyInventoryByRoomHandler,
  getGenItemInventoryByRoomHandler,
  
  getApparelUnitsByRoomHandler,
  getAdminSupplyUnitsByRoomHandler,
  getGenItemUnitsByRoomHandler,
  
  getReleaseApparelsByRoomHandler,
  getReleasedBatchAdminSupplyByRoomHandler,
  getReleasedGenItemByRoomHandler,

  // PUT -------------------------------------------------------------------------------------
  updateRoomHandler,                  // update a specific room.

  getItemsByRoomHandler,

  listRoomsHandler,
  updateApparelUnitByRoomHandler,
  getAllUnitsByRoomHandler
};

// Room's CRUD Handler
function isSuperAdmin(user) {
  if (!user) return false;
  const role = user.role;
  if (!role) return false;
  if (Array.isArray(role)) {
    return role.some(r => String(r).toLowerCase() === 'superadmin');
  }
  return String(role).toLowerCase() === 'superadmin';
}
async function getRoomsHandler(user) {
  if (!user) return [];

  const include = [{
    model: db.Account,
    attributes: ['firstName', 'lastName', 'accountId']
  }];

  if ((user.role || '').toString().toLowerCase() === (Role.SuperAdmin || '').toString().toLowerCase()) {
    return await db.Room.findAll({ include });
  }

  const accountId = Number(user.accountId || user.AccountId || user.id);
  if (!accountId) return [];

  return await db.Room.findAll({
    where: { roomInCharge: accountId },
    include
  });
}
async function createRoomHandler(payload, user, ipAddress, browserInfo) {
  if (!isSuperAdmin(user)) {
    const err = new Error('Forbidden: only Super Admin can create rooms');
    err.status = 403;
    throw err;
  }

  const created = await db.Room.create({
    roomName:     payload.roomName,
    roomFloor:    payload.roomFloor,
    roomType:     payload.roomType,
    stockroomType: payload.stockroomType ?? null, // <- add this line
    roomInCharge: payload.roomInCharge,
    description:  payload.description,
  });

  try {
    await accountService.logActivity(user.accountId, 'room_create', ipAddress, browserInfo, `roomId:${created.roomId}`);
  } catch (err) {
    console.error('activity log failed (createRoom)', err);
  }

  return created;
}
async function getRoomByIdHandler(roomId, user) {
  const room = await db.Room.findByPk(roomId, {
    include: [{
      model: db.Account,
      attributes: ['firstName', 'lastName', 'accountId']
    }]
  });

  if (!room) {
    const err = new Error('Room not found');
    err.status = 404;
    throw err;
  }

  if ((user.role || '').toString().toLowerCase() === (Role.SuperAdmin || '').toString().toLowerCase()) {
    return room;
  }

  const accountId = Number(user.accountId || user.AccountId || user.id);
  if (accountId && Number(room.roomInCharge) === accountId) {
    return room;
  }

  const err = new Error('Forbidden: you do not have access to this room');
  err.status = 403;
  throw err;
}
async function updateRoomHandler(roomId, payload, user, ipAddress, browserInfo) {
  if (!isSuperAdmin(user)) {
    const err = new Error('Forbidden: only Super Admin can edit rooms');
    err.status = 403;
    throw err;
  }

  const room = await db.Room.findByPk(roomId);
  if (!room) {
    const err = new Error('Room not found');
    err.status = 404;
    throw err;
  }

  Object.assign(room, {
    roomName:     payload.roomName  ?? room.roomName,
    roomFloor:    payload.roomFloor ?? room.roomFloor,
    roomType:     payload.roomType  ?? room.roomType,
    stockroomType: (payload.hasOwnProperty('stockroomType') ? payload.stockroomType : room.stockroomType),
    roomInCharge: payload.roomInCharge ?? room.roomInCharge,
    description:  payload.description ?? room.description,
  });

  try {
    await accountService.logActivity(user.accountId, 'room_update', ipAddress, browserInfo, `roomId:${roomId}`);
  } catch (err) {
    console.error('activity log failed (roomUpdate)', err);
  }

  await room.save();

  

  return room;
}

// Stockroom/Substockroom identifier
async function ensureIsStockroomHandler(roomId) {
  const room = await db.Room.findByPk(roomId);
  if (!room) throw new Error(`Room ${roomId} not found`);

  const rt = (room.roomType).toString().toLowerCase();
  if (rt !== 'stockroom' && rt !== 'substockroom') {
    const err = new Error(`Room ${roomId} is not a stockroom/substockroom`);
    err.status = 400;
    throw err;
  }
  if (!room.stockroomType) {
    const err = new Error(`Can't receive these items in this room.`);
    err.status = 400;
    throw err;
  }
  return room;
}
async function ensureRoomExistsHandler(roomId) {
  if (!roomId) throw { status: 400, message: 'roomId required' };
  const room = await db.Room.findByPk(roomId);
  if (!room) throw { status: 404, message: 'Room not found' };
  return room;
}

// Receive Handler
async function receiveInStockroomHandler(roomId, payload) {
  await ensureIsStockroomHandler(roomId);

  // normalize numeric fields
  if (payload.apparelQuantity != null) payload.apparelQuantity  = parseInt(payload.apparelQuantity, 10);
  if (payload.supplyQuantity  != null) payload.supplyQuantity   = parseInt(payload.supplyQuantity,  10);
  if (payload.genItemQuantity != null) payload.genItemQuantity  = parseInt(payload.genItemQuantity, 10);

  // apparel path
  if (payload.apparelName && Number.isInteger(payload.apparelQuantity) && payload.apparelQuantity > 0) {
    return await receiveApparelInRoomHandler(roomId, payload);
  }

  // admin supply path
  if (payload.supplyName && Number.isInteger(payload.supplyQuantity) && payload.supplyQuantity > 0) {
    return await receiveAdminSupplyInRoomHandler(roomId, payload);
  }

  // general item path
  if (payload.genItemName && Number.isInteger(payload.genItemQuantity) && payload.genItemQuantity > 0) {
    return await receiveGenItemInRoomHandler(roomId, payload);
  }

  try {
    await accountService.logActivity(user.accountId, 'room_create', ipAddress, browserInfo, `borrowId:${created.roomId}`);
  } catch (err) {
    console.error('activity log failed (createBorrow)', err);
  }

  const err = new Error('Bad payload: must include either apparelName+apparelQuantity or supplyName+supplyQuantity');
  err.status = 400;
  throw err;
}
async function receiveApparelInRoomHandler(roomId, payload, user, ipAddress, browserInfo) {
  await ensureIsStockroomHandler(roomId);

  const batch = await db.ReceiveApparel.create({
    roomId,
    receivedFrom:     payload.receivedFrom,
    receivedBy:       payload.receivedBy,
    apparelName:      payload.apparelName,
    apparelLevel:     payload.apparelLevel,
    apparelType:      payload.apparelType,
    apparelFor:       payload.apparelFor,
    apparelSize:      payload.apparelSize,
    apparelQuantity:  payload.apparelQuantity,
    notes:            payload.notes || null
  });

  const [inv] = await db.ApparelInventory.findOrCreate({
    where: {
      roomId,
      apparelName:  payload.apparelName,
      apparelLevel: payload.apparelLevel,
      apparelType:  payload.apparelType,
      apparelFor:   payload.apparelFor,
      apparelSize:  payload.apparelSize
    },
    defaults: { totalQuantity: 0 }
  });

  inv.totalQuantity = (inv.totalQuantity || 0) + payload.apparelQuantity;
  await inv.save();

  let createdUnits = [];
  if (db.Apparel) {
    const apparelUnits = Array(payload.apparelQuantity).fill().map(() => ({
      receiveApparelId: batch.receiveApparelId,
      apparelInventoryId: inv.apparelInventoryId ?? inv.id,
      roomId: roomId,
      status: 'good'
    }));
    createdUnits = await db.Apparel.bulkCreate(apparelUnits);
  }

  const res = db.ReceiveApparel.findByPk(batch.receiveApparelId, {
    include: [{ model: db.Apparel }]
  });

  try {
    await accountService.logActivity(user.accountId, 'receive_apparel', ipAddress, browserInfo, `roomId:${roomId}`);
  } catch (err) {
    console.error('activity log failed (receiveApparel)', err);
  }

  return res;
}
async function receiveAdminSupplyInRoomHandler(roomId, payload, user, ipAddress, browserInfo) {
  await ensureIsStockroomHandler(roomId);

  const batch = await db.ReceiveAdminSupply.create({
    roomId,
    receivedFrom: payload.receivedFrom,
    receivedBy: payload.receivedBy,
    supplyName: payload.supplyName,
    supplyQuantity: payload.supplyQuantity,
    supplyMeasure: payload.supplyMeasure,
    notes: payload.notes || null
  });

  const [inv] = await db.AdminSupplyInventory.findOrCreate({
    where: {
      roomId,
      supplyName: payload.supplyName,
      supplyMeasure: payload.supplyMeasure
    },
    defaults: { totalQuantity: 0 }
  });

  inv.totalQuantity = (inv.totalQuantity || 0) + payload.supplyQuantity;
  await inv.save();

  let createdUnits = [];
  if (db.AdminSupply) {
    const adminSupplyUnits = Array(payload.supplyQuantity).fill().map(() => ({
      receiveAdminSupplyId: batch.receiveAdminSupplyId,
      adminSupplyInventoryId: inv.adminSupplyInventoryId ?? inv.id, 
      roomId: roomId,
      status: 'good'
    }));
    createdUnits = await db.AdminSupply.bulkCreate(adminSupplyUnits);
  }

  const res = db.ReceiveAdminSupply.findByPk(batch.receiveAdminSupplyId, {
    include: [{ model: db.AdminSupply}]
  });

  try {
    await accountService.logActivity(user.accountId, 'receive_admin-supply', ipAddress, browserInfo, `roomId:${roomId}`);
  } catch (err) {
    console.error('activity log failed (receiveAdminSupply)', err);
  }

  return res;
}
async function receiveGenItemInRoomHandler(roomId, payload, user, ipAddress, browserInfo) {
  await ensureIsStockroomHandler(roomId);

  const batch = await db.ReceiveGenItem.create({
    roomId,
    receivedFrom:     payload.receivedFrom,
    receivedBy:       payload.receivedBy,
    genItemName:      payload.genItemName,
    genItemSize:      payload.genItemSize || null,
    genItemQuantity:  payload.genItemQuantity,
    genItemType:      payload.genItemType,
    notes:            payload.notes || null
  });
  
  // FIND or CREATE inventory first (moved up)
  const [inv] = await db.GenItemInventory.findOrCreate({
    where: {
      roomId,
      genItemName: payload.genItemName,
      genItemSize: payload.genItemSize || null,
      genItemType: payload.genItemType,
    },
    defaults: { totalQuantity: 0 }
  });
  
  // Update inventory total and save
  inv.totalQuantity = (inv.totalQuantity || 0) + payload.genItemQuantity;
  await inv.save();
  
  // Then create unit rows (and include genItemInventoryId)
  let createdUnits = [];
  if (db.GenItem) {
    const genItemUnits = Array(payload.genItemQuantity).fill().map(() => ({
      receiveGenItemId: batch.receiveGenItemId,
      genItemInventoryId: inv.genItemInventoryId ?? inv.id, // <-- important
      roomId: roomId,
      status: 'good'
    }));
    createdUnits = await db.GenItem.bulkCreate(genItemUnits);
  }
  
  // return the batch (including generated units, same as before)
  const res = db.ReceiveGenItem.findByPk(batch.receiveGenItemId, {
    include: [{ model: db.GenItem }]
  });

  try {
    await accountService.logActivity(user.accountId, 'receive_general-items', ipAddress, browserInfo, `roomId:${roomId}`);
  } catch (err) {
    console.error('activity log failed (receiveGenItems)', err);
  }

  return res;
}

// Get Received Handler
async function getReceiveApparelsByRoomHandler(roomId) {
  await ensureIsStockroomHandler(roomId);

  const batches = await db.ReceiveApparel.findAll({
    where: { roomId: roomId },
    include: [
      { model: db.Account, attributes: ['accountId','firstName','lastName'], required: false },
      { model: db.Apparel, required: false }
    ],
    order: [['receivedAt', 'DESC']]
  });

  return batches;
}
// async function getApparelUnitsByRoomHandler(roomId) {

//   // await ensureIsStockroomHandler(roomId);
//   await ensureRoomExistsHandler(roomId);

//   const units = await db.Apparel.findAll({
//     where: { roomId: roomId },
//     order: [['apparelId', 'ASC']]
//   });

//   return units;
// }
async function getApparelUnitsByRoomHandler(roomId) {
  // Return apparel unit rows for any room (don't require stockroom check)
  const units = await db.Apparel.findAll({
    where: { roomId: roomId },
    order: [['apparelId', 'ASC']]
  });
  return units;
}
async function getApparelInventoryByRoomHandler(roomId) {

  await ensureIsStockroomHandler(roomId);

  const inventory = await db.ApparelInventory.findAll({
    where: { roomId: roomId },
    order: [['apparelName', 'ASC'], ['apparelLevel', 'ASC']]
  });

  return inventory;
}

async function getReceiveAdminSupplyByRoomHandler(roomId) {
  await ensureIsStockroomHandler(roomId);

  const batches = await db.ReceiveAdminSupply.findAll({
    where: { roomId: roomId },
    include: [
      { model: db.Account, attributes: ['accountId','firstName','lastName'], required: false },
      { model: db.AdminSupply, required: false }
    ],
    order: [['receivedAt', 'DESC']]
  });

  return batches;
}
// async function getAdminSupplyUnitsByRoomHandler(roomId) {

//   await ensureIsStockroomHandler(roomId);

//   const units = await db.AdminSupply.findAll({
//     where: { roomId: roomId },
//     order: [['adminSupplyId', 'ASC']]
//   });

//   return units;
// }
async function getAdminSupplyUnitsByRoomHandler(roomId) {
  // Return admin supply units for any room (don't require stockroom check)
  const units = await db.AdminSupply.findAll({
    where: { roomId: roomId },
    order: [['adminSupplyId', 'ASC']]
  });
  return units;
}
async function getAdminSupplyInventoryByRoomHandler(roomId) {

  await ensureIsStockroomHandler(roomId);

  const inventory = await db.AdminSupplyInventory.findAll({
    where: { roomId: roomId },
    order: [['supplyName', 'ASC'], ['supplyMeasure', 'ASC']]
  });

  return inventory;
}

async function getReceiveGenItemByRoomHandler(roomId) {
  await ensureIsStockroomHandler(roomId);

  const batches = await db.ReceiveGenItem.findAll({
    where: { roomId: roomId },
    include: [
      { model: db.Account, attributes: ['accountId','firstName','lastName'], required: false },
      { model: db.GenItem, required: false }
    ],
    order: [['receivedAt', 'DESC'], ['genItemType', 'DESC']]
  });

  return batches;
}
// async function getGenItemUnitsByRoomHandler(roomId) {

//   // await ensureIsStockroomHandler(roomId);

//   const units = await db.GenItem.findAll({
//     where: { roomId: roomId },
//     order: [['genItemId', 'ASC']]
//   });

//   return units;
// }
async function getGenItemUnitsByRoomHandler(roomId) {
  // Return general-item units for any room (don't require stockroom check)
  const units = await db.GenItem.findAll({
    where: { roomId: roomId },
    order: [['genItemId', 'ASC']]
  });
  return units;
}
async function getGenItemInventoryByRoomHandler(roomId) {

  await ensureIsStockroomHandler(roomId);

  const inventory = await db.GenItemInventory.findAll({
    where: { roomId: roomId },
    order: [['genItemName', 'ASC'], ['genItemType', 'ASC']]
  });

  return inventory;
}

// Release Handler
async function releaseInStockroomHandler(roomId, payload) {
  await ensureIsStockroomHandler(roomId);

  if (payload.releaseApparelQuantity != null) payload.releaseApparelQuantity = parseInt(payload.releaseApparelQuantity, 10);

  // apparel path
  if (payload.apparelInventoryId && Number.isInteger(payload.releaseApparelQuantity) && payload.releaseApparelQuantity > 0) {
    return await releaseApparelInRoomHandler(roomId, payload);
  }

  // admin supply path
  if (payload.adminSupplyInventoryId && Number.isInteger(payload.releaseAdminSupplyQuantity) && payload.releaseAdminSupplyQuantity > 0) {
    return await releaseAdminSupplyInRoomHandler(roomId, payload);
  }

  // general item path
  if (payload.genItemInventoryId && Number.isInteger(payload.releaseItemQuantity) && payload.releaseItemQuantity > 0) {
    return await releaseGenItemInRoomHandler(roomId, payload);
  }

  const err = new Error('Bad payload: must include either name or quantity');
  err.status = 400;
  throw err;
}
async function releaseApparelInRoomHandler(roomId, payload, user, ipAddress, browserInfo) {
  await ensureIsStockroomHandler(roomId);

  const qty = Number(payload.releaseApparelQuantity || 0);
  if (!Number.isInteger(qty) || qty <= 0) throw { status: 400, message: 'Invalid release quantity' };

  const sequelize = db.sequelize || null;
  const t = sequelize ? await sequelize.transaction() : null;

  try {
    const [inv] = await db.ApparelInventory.findOrCreate({
      where: {
        roomId,
        apparelInventoryId: payload.apparelInventoryId,
      },
      defaults: { totalQuantity: 0, status: 'out_of_stock' },
      transaction: t
    });

    const available = inv.totalQuantity || 0;
    if (available < qty) {
      if (t) await t.rollback();
      throw { status: 400, message: `Not enough stock to release (${available} available)` };
    }

    const batch = await db.ReleaseApparel.create({
      roomId,
      apparelInventoryId: payload.apparelInventoryId,
      releasedBy: payload.releasedBy,
      claimedBy: payload.claimedBy,
      releaseApparelQuantity: qty,
      notes: payload.notes || null
    }, { transaction: t });

    await updateInventory(inv, -qty, { transaction: t });

    if (t) await t.commit();

    const res = db.ReleaseApparel.findByPk(batch.releaseApparelId);

    try {
      await accountService.logActivity(user.accountId, 'release_apparel', ipAddress, browserInfo, `roomId:${roomId}`);
    } catch (err) {
      console.error('activity log failed (releaseApparel)', err);
    }

    return res;
  } catch (e) {
    if (t) await t.rollback();
    throw e;
  }
}
async function releaseAdminSupplyInRoomHandler(roomId, payload, user, ipAddress, browserInfo) {
  await ensureIsStockroomHandler(roomId);

  const qty = Number(payload.releaseAdminSupplyQuantity || 0);
  if (!Number.isInteger(qty) || qty <= 0) throw { status: 400, message: 'Invalid release quantity' };

  const sequelize = db.sequelize || null;
  const t = sequelize ? await sequelize.transaction() : null;

  try {
    const [inv] = await db.AdminSupplyInventory.findOrCreate({
      where: {
        roomId,
        adminSupplyInventoryId: payload.adminSupplyInventoryId,
      },
      defaults: { totalQuantity: 0, status: 'out_of_stock' },
      transaction: t
    });

    const available = inv.totalQuantity || 0;
    if (available < qty) {
      if (t) await t.rollback();
      throw { status: 400, message: `Not enough stock to release (${available} available)` };
    }

    const batch = await db.ReleaseAdminSupply.create({
      roomId,
      adminSupplyInventoryId: payload.adminSupplyInventoryId,
      releasedBy: payload.releasedBy,
      claimedBy: payload.claimedBy,
      releaseAdminSupplyQuantity: qty,
      notes: payload.notes || null
    }, { transaction: t });

    await updateInventory(inv, -qty, { transaction: t });

    if (t) await t.commit();
    const res = db.ReleaseAdminSupply.findByPk(batch.releaseAdminSupplyId);

    try {
      await accountService.logActivity(user.accountId, 'release_admin-supply', ipAddress, browserInfo, `roomId:${roomId}`);
    } catch (err) {
      console.error('activity log failed (releaseAdminSupply)', err);
    }

    return res;
  } catch (e) {
    if (t) await t.rollback();
    throw e;
  }
}
async function releaseGenItemInRoomHandler(roomId, payload, user, ipAddress, browserInfo) {
  await ensureIsStockroomHandler(roomId);

  const qty = Number(payload.releaseItemQuantity || 0);
  if (!Number.isInteger(qty) || qty <= 0) throw { status: 400, message: 'Invalid release quantity' };

  const sequelize = db.sequelize || null;
  const t = sequelize ? await sequelize.transaction() : null;

  try {
    const [inv] = await db.GenItemInventory.findOrCreate({
      where: {
        roomId,
        genItemInventoryId: payload.genItemInventoryId,
      },
      defaults: { totalQuantity: 0, status: 'out_of_stock' },
      transaction: t
    });

    const available = inv.totalQuantity || 0;
    if (available < qty) {
      if (t) await t.rollback();
      throw { status: 400, message: `Not enough stock to release (${available} available)` };
    }

    const batch = await db.ReleaseGenItem.create({
      roomId,
      genItemInventoryId: payload.genItemInventoryId,
      releasedBy: payload.releasedBy,
      claimedBy: payload.claimedBy,
      releaseItemQuantity: qty,
      genItemType: payload.genItemType,
      notes: payload.notes || null
    }, { transaction: t });

    await updateInventory(inv, -qty, { transaction: t });

    if (t) await t.commit();
    const res = db.ReleaseGenItem.findByPk(batch.releaseGenItemId);

    try {
      await accountService.logActivity(user.accountId, 'release_general-tems', ipAddress, browserInfo, `roomId:${roomId}`);
    } catch (err) {
      console.error('activity log failed (releaseGenItem)', err);
    }

    return res;
  } catch (e) {
    if (t) await t.rollback();
    throw e;
  }
}

// Get Released Apparels Handler
async function getReleaseApparelsByRoomHandler(roomId) {
  await ensureIsStockroomHandler(roomId);

  const batches = await db.ReleaseApparel.findAll({
    where: { roomId: roomId },
    include: [
      { model: db.Account, attributes: ['accountId','firstName','lastName'], required: false },
    ],
    order: [['releasedAt', 'DESC']]
  });

  return batches;
}
async function getReleasedBatchAdminSupplyByRoomHandler(roomId) {
  await ensureIsStockroomHandler(roomId);

  if (db.ReleaseAdminSupply) {
    return await db.ReleaseAdminSupply.findAll({
      where: { roomId },
      order: [['releasedAt', 'DESC']]
    });
  }

  return [];
}
async function getReleasedGenItemByRoomHandler(roomId) {
  await ensureIsStockroomHandler(roomId);

  if (db.ReleaseGenItem) {
    return await db.ReleaseGenItem.findAll({
      where: { roomId },
      order: [['releasedAt', 'DESC']]
    });
  }
  return [];
}

// Generate QR Code Handler
async function generateApparelBatchForRoom(roomId, inventoryId) {
  if (!roomId) throw { status: 400, message: 'roomId required' };
  if (!inventoryId) throw { status: 400, message: 'inventoryId required' };

  await ensureIsStockroomHandler(roomId);

  const inv = await db.ApparelInventory.findByPk(inventoryId);
  if (!inv) throw { status: 404, message: 'ApparelInventory not found' };
  if (String(inv.roomId) !== String(roomId)) throw { status: 403, message: 'Inventory does not belong to this room' };

  const result = await qrService.generateBatchQR({ stockroomType: 'apparel', inventoryId });

  return { inventoryId, result};
}
async function generateAdminSupplyBatchForRoom(roomId, inventoryId) {
  if (!roomId) throw { status: 400, message: 'roomId required' };
  if (!inventoryId) throw { status: 400, message: 'inventoryId required' };

  await ensureIsStockroomHandler(roomId);

  const inv = await db.AdminSupplyInventory.findByPk(inventoryId);
  if (!inv) throw { status: 404, message: 'AdminSupplyInventory not found' };
  if (String(inv.roomId) !== String(roomId)) throw { status: 403, message: 'Inventory does not belong to this room' };

  const result = await qrService.generateBatchQR({ stockroomType: 'supply', inventoryId });

  

  return { inventoryId, ...result };
}
async function generateGenItemBatchForRoom(roomId, inventoryId) {
  if (!roomId) throw { status: 400, message: 'roomId required' };
  if (!inventoryId) throw { status: 400, message: 'inventoryId required' };

  await ensureIsStockroomHandler(roomId);

  const inv = await db.GenItemInventory.findByPk(inventoryId);
  if (!inv) throw { status: 404, message: 'GenItemInventory not found' };
  if (String(inv.roomId) !== String(roomId)) throw { status: 403, message: 'Inventory does not belong to this room' };

  const result = await qrService.generateBatchQR({ stockroomType: 'it' || 'maintenance', inventoryId });
  return { inventoryId, ...result };
}

async function generateApparelUnitForRoom(roomId, unitId) {
  if (!roomId) throw { status: 400, message: 'roomId required' };
  if (!unitId) throw { status: 400, message: 'unitId required' };

  await ensureIsStockroomHandler(roomId);

  const unit = await db.Apparel.findByPk(unitId);
  if (!unit) throw { status: 404, message: 'Apparel unit not found' };
  if (String(unit.roomId) !== String(roomId)) throw { status: 403, message: 'Unit does not belong to this room' };

  const result = await qrService.generateUnitQR({ stockroomType: 'apparel', unitId });
  return { unitId, ...result };
}
async function generateAdminSupplyUnitForRoom(roomId, unitId) {
  if (!roomId) throw { status: 400, message: 'roomId required' };
  if (!unitId) throw { status: 400, message: 'unitId required' };

  await ensureIsStockroomHandler(roomId);

  const unit = await db.AdminSupply.findByPk(unitId);
  if (!unit) throw { status: 404, message: 'AdminSupply unit not found' };
  if (String(unit.roomId) !== String(roomId)) throw { status: 403, message: 'Unit does not belong to this room' };

  const result = await qrService.generateUnitQR({ stockroomType: 'supply', unitId });
  return { unitId, ...result };
}
async function generateGenItemUnitForRoom(roomId, unitId) {
  if (!roomId) throw { status: 400, message: 'roomId required' };
  if (!unitId) throw { status: 400, message: 'unitId required' };

  await ensureIsStockroomHandler(roomId);

  const unit = await db.GenItem.findByPk(unitId);
  if (!unit) throw { status: 404, message: 'GenItem unit not found' };
  if (String(unit.roomId) !== String(roomId)) throw { status: 403, message: 'Unit does not belong to this room' };

  const result = await qrService.generateUnitQR({ stockroomType: 'it' || 'maintenance', unitId });
  return { unitId, ...result };
}

function computeInventoryStatus(remaining) {
  if (remaining <= 1) return 'out_of_stock';
  if (remaining < 10) return 'low_stock';
  return 'high_stock';
}
async function updateInventory(inv, qtyChange, opts = {}) {
  if (!inv) return;

  if (!Number.isFinite(Number(qtyChange))) {
    throw { status: 500, message: 'Invalid qtyChange to updateInventory' };
  }

  const delta = Number(qtyChange);
  const transaction = opts.transaction;

  if (typeof inv.totalQuantity !== 'undefined') {
    inv.totalQuantity = Math.max(0, (inv.totalQuantity || 0) + delta);

    if (typeof inv.status !== 'undefined') {
      inv.status = computeInventoryStatus(inv.totalQuantity);
    }

    await inv.save({ transaction });
    return;
  }

  if (typeof inv.quantity !== 'undefined') {
    inv.quantity = Math.max(0, (inv.quantity || 0) + delta);

    if (typeof inv.status !== 'undefined') {
      inv.status = computeInventoryStatus(inv.quantity);
    }

    await inv.save({ transaction });
    return;
  }

  try {
    const current = Number(inv.getDataValue('quantity') || 0);
    inv.setDataValue('quantity', Math.max(0, current + delta));
    await inv.save({ transaction });
  } catch (err) {
    throw { status: 500, message: 'Unable to update inventory quantity', detail: err.message || err };
  }
}

// original method
async function getItemsByRoomHandler(roomId) {
  await ensureIsStockroomHandler(roomId);

  // load per-type inventory lists in parallel (fall back to empty array)
  const [apparelInv, supplyInv, genInv] = await Promise.all([
    getApparelInventoryByRoomHandler(roomId).catch(() => []),
    getAdminSupplyInventoryByRoomHandler(roomId).catch(() => []),
    getGenItemInventoryByRoomHandler(roomId).catch(() => [])
  ]);

  const merged = [];

  (apparelInv || []).forEach(inv => {
    merged.push({
      itemType: 'apparel',
      inventoryId: inv.apparelInventoryId ?? inv.id ?? null,
      name: inv.apparelName ?? inv.name ?? `Apparel #${inv.apparelInventoryId || inv.id || ''}`,
      totalQuantity: Number(inv.totalQuantity || inv.apparelQuantity || 0),
      raw: inv
    });
  });

  (supplyInv || []).forEach(inv => {
    merged.push({
      itemType: 'supply',
      inventoryId: inv.adminSupplyInventoryId ?? inv.id ?? null,
      name: inv.supplyName ?? inv.name ?? `Supply #${inv.adminSupplyInventoryId || inv.id || ''}`,
      totalQuantity: Number(inv.totalQuantity || inv.supplyQuantity || 0),
      raw: inv
    });
  });

  (genInv || []).forEach(inv => {
    merged.push({
      itemType: 'genItem',
      inventoryId: inv.genItemInventoryId ?? inv.id ?? null,
      name: inv.genItemName ?? inv.name ?? `Item #${inv.genItemInventoryId || inv.id || ''}`,
      totalQuantity: Number(inv.totalQuantity || inv.genItemQuantity || 0),
      raw: inv
    });
  });

  // stable sort by name for consistent UI
  merged.sort((a, b) => (a.name || '').toString().localeCompare((b.name || '').toString()));

  return merged;
}


// ---------------------------added methods---------------------------
async function listRoomsHandler() {
  const include = [{
    model: db.Account,
    attributes: ['firstName', 'lastName', 'accountId']
  }];

  return await db.Room.findAll({ include });
}



async function updateApparelUnitByRoomHandler(roomId, unitId, payload = {}, user = null) {
  if (!Number.isFinite(roomId) || !Number.isFinite(unitId)) {
    throw { status: 400, message: 'Invalid params' };
  }

  // optional: ensure room exists (you already have ensureRoomExistsHandler in file)
  await ensureRoomExistsHandler(roomId);

  const unit = await db.Apparel.findByPk(unitId);
  if (!unit) throw { status: 404, message: 'Apparel unit not found' };
  if (String(unit.roomId) !== String(roomId)) throw { status: 403, message: 'Unit does not belong to this room' };

  // Only accept description and status updates
  const updates = {};
  if (typeof payload.description !== 'undefined') updates.description = payload.description;
  if (typeof payload.status !== 'undefined') updates.status = payload.status;

  if (Object.keys(updates).length === 0) throw { status: 400, message: 'Nothing to update' };

  // persist
  await unit.update(updates);

  // optional: log activity (accountService.logActivity) — follow your existing pattern if needed

  return unit; // returns updated unit row
}

async function getAllUnitsByRoomHandler(roomId) {
  await ensureRoomExistsHandler(roomId);

  const [apparelUnits, supplyUnits, genUnits] = await Promise.all([
    getApparelUnitsByRoomHandler(roomId).catch(() => []),
    getAdminSupplyUnitsByRoomHandler(roomId).catch(() => []),
    getGenItemUnitsByRoomHandler(roomId).catch(() => []),
  ]);

  const normalized = [];

  (apparelUnits || []).forEach(u => {
    const row = (typeof u.get === 'function') ? u.get() : u;
    normalized.push(Object.assign({ unitType: 'apparel' }, row));
  });

  (supplyUnits || []).forEach(u => {
    const row = (typeof u.get === 'function') ? u.get() : u;
    normalized.push(Object.assign({ unitType: 'supply' }, row));
  });

  (genUnits || []).forEach(u => {
    const row = (typeof u.get === 'function') ? u.get() : u;
    normalized.push(Object.assign({ unitType: 'genitem' }, row));
  });

  return normalized;
}

================================================================================
File: _services\transfer.service.js
Size: 20.81 kB
================================================================================

const db = require('_helpers/db-handler');
const Role = require('_helpers/role'); 
const { Transaction }     = require('sequelize');
const accountService = require('./account.service');

module.exports = {
  createTransfer,
  acceptTransfer,
  getById,
  listTransfers
};

const ADMIN_ROLES = ['superAdmin'];

async function createTransfer({ createdBy, fromRoomId, toRoomId, itemId, quantity = 1, note = null, ipAddress, browserInfo }) {
  try {
    if (!createdBy) throw { status: 401, message: 'Unauthenticated' };
    if (!Number.isInteger(quantity) || quantity <= 0) throw { status: 400, message: 'quantity must be a positive integer' };

    // Defensive: ensure rooms exist
    const fromRoom = await db.Room.findByPk(fromRoomId);
    if (!fromRoom) throw { status: 400, message: 'Invalid fromRoomId' };

    const toRoom = await db.Room.findByPk(toRoomId);
    if (!toRoom) throw { status: 400, message: 'Invalid toRoomId' };

    // Defensive: require toRoom.roomType to be stockroom or substockroom
    const tr = String(toRoom.roomType || '').toLowerCase();
    if (!['stockroom', 'substockroom'].includes(tr)) {
      throw { status: 403, message: 'Transfers are allowed only to rooms of type stockroom or substockroom' };
    }

    // Helper: check an inventory table by PK and ensure its room-field matches fromRoomId
    const roomFields = ['roomId', 'locationRoomId', 'storedRoomId', 'room_id', 'stockRoomId'];

    async function checkInventoryModel(modelName) {
      const M = db[modelName];
      if (!M) return null;
      const candidate = await M.findByPk(itemId);
      if (!candidate) return null;
      for (const f of roomFields) {
        if (typeof candidate[f] !== 'undefined' && String(candidate[f]) === String(fromRoomId)) {
          return { model: modelName, row: candidate };
        }
      }
      return null;
    }

    // 1) Try inventory tables first
    const inventoryModels = [
      { model: 'ApparelInventory', type: 'apparel' },
      { model: 'AdminSupplyInventory', type: 'supply' },
      { model: 'GenItemInventory', type: 'genItem' }
    ];

    let resolvedType = null;
    let itemRow = null;

    for (const im of inventoryModels) {
      const res = await checkInventoryModel(im.model);
      if (res) { resolvedType = im.type; itemRow = res.row; break; }
    }

    // 2) If not found, try unit/item tables (individual units) and check room fields there
    if (!resolvedType) {
      const unitModels = [
        { model: 'Apparel', type: 'apparel' },
        { model: 'AdminSupply', type: 'supply' },
        { model: 'GenItem', type: 'genItem' }
      ];

      for (const um of unitModels) {
        const M = db[um.model];
        if (!M) continue;
        const unit = await M.findByPk(itemId);
        if (!unit) continue;
        for (const f of roomFields) {
          if (typeof unit[f] !== 'undefined' && String(unit[f]) === String(fromRoomId)) {
            resolvedType = um.type;
            itemRow = unit;
            break;
          }
        }
        if (resolvedType) break;
      }
    }

    if (!resolvedType) {
      // No matching inventory or unit found that belongs to fromRoomId
      throw { status: 400, message: `Item ${itemId} not found in room ${fromRoomId}` };
    }

    // Create the transfer record and store itemType for downstream compatibility
    const transfer = await db.Transfer.create({
      createdBy,
      fromRoomId,
      toRoomId,
      itemType: resolvedType,
      itemId,
      quantity,
      note,
      status: 'pending'
    });

    try {
      await accountService.logActivity(String(createdBy), 'transfer_create', ipAddress, browserInfo, `transferId:${transfer.transferId}`);
    } catch (err) {
      console.error('activity log failed (createTransfer)', err);
    }

    return transfer;
  } catch (err) {
    // Ensure errors are thrown as objects with .status and .message where possible
    if (err && err.status && err.message) throw err;
    console.error('createTransfer error:', err && (err.stack || err));
    throw { status: 500, message: 'Server error while creating transfer' };
  }
}
// async function acceptTransfer(transferId, accepterId, accepterRole, ipAddress, browserInfo) {
//   if (!transferId) throw { status: 400, message: 'transferId required' };

//   // normalize allowed admin roles (lowercase)
//   const ADMIN_ROLES = ['superadmin', 'admin', 'super_admin'];

//   const txn = await db.sequelize.transaction();
//   try {
//     // load transfer WITH txn
//     const tr = await db.Transfer.findByPk(transferId, { transaction: txn });
//     if (!tr) {
//       await txn.rollback();
//       throw { status: 404, message: 'Transfer not found' };
//     }
//     if (tr.status !== 'in_transfer') {
//       await txn.rollback();
//       throw { status: 400, message: 'Only in_transfer can be accepted' };
//     }

//     // load destination room to get roomInCharge
//     let toRoom = null;
//     if (tr.toRoomId) {
//       toRoom = await db.Room.findByPk(tr.toRoomId, { transaction: txn });
//     }
//     const roomInCharge = toRoom?.roomInCharge ?? null;

//     // normalize role and check authorization: admin OR room-in-charge
//     const roleLower = String(accepterRole || '').toLowerCase();
//     let isAdmin = ADMIN_ROLES.includes(roleLower);

//     if (!isAdmin) {
//       // try direct match first
//       if (roomInCharge && String(roomInCharge) === String(accepterId)) {
//         // allowed
//       } else {
//         // try resolving account/user to cover schema mismatch (accountId vs userId etc.)
//         let accepterMatches = false;
//         const acct = await db.Account.findByPk(accepterId, { transaction: txn }).catch(() => null);
//         if (acct) {
//           if (String(acct.accountId) === String(roomInCharge) || String(acct.id) === String(roomInCharge)) accepterMatches = true;
//         }
//         if (!accepterMatches && db.User) {
//           const user = await db.User.findByPk(accepterId, { transaction: txn }).catch(() => null);
//           if (user && (String(user.userId ?? user.id) === String(roomInCharge))) accepterMatches = true;
//         }

//         if (!accepterMatches) {
//           await txn.rollback();
//           throw {
//             status: 403,
//             message: `Only the room-in-charge or an admin can accept this transfer. accepterId=${accepterId}, role=${accepterRole}, roomInCharge=${roomInCharge}`
//           };
//         }
//       }
//     }

//     // Authorized — now perform inventory move + receive creation in same transaction

//     // 1) get inventory model for itemType
//     const model = inventoryModelFor(tr.itemType);
//     if (!model) {
//       await txn.rollback();
//       throw { status: 400, message: 'unknown itemType' };
//     }

//     // 2) find source inventory
//     let srcInv = null;
//     if (tr.itemId) {
//       srcInv = await model.findByPk(tr.itemId, { transaction: txn }).catch(() => null);
//     }
//     if (!srcInv) {
//       srcInv = await model.findOne({ where: { id: tr.itemId, roomId: tr.fromRoomId }, transaction: txn }).catch(() => null);
//     }
//     if (!srcInv) {
//       await txn.rollback();
//       throw { status: 404, message: 'Source inventory not found' };
//     }

//     // 3) check available qty
//     const available = getQuantity(srcInv);
//     if (available < tr.quantity) {
//       await txn.rollback();
//       throw { status: 400, message: 'Insufficient quantity in source' };
//     }

//     // 4) decrement source and increment destination using helpers (they save with transaction)
//     await adjustInventory(srcInv, -Number(tr.quantity), txn);

//     const destInv = await findOrCreateMatchingInventory(model, srcInv, tr.toRoomId, { transaction: txn });
//     await adjustInventory(destInv, Number(tr.quantity), txn);

//     // 5) update transfer record (inside txn)
//     await tr.update({ status: 'transfer_accepted', acceptedBy: accepterId || null, acceptedAt: new Date() }, { transaction: txn });

//     // 6) create receive batch & unit records (helper expects txn)
//     const typeNorm = String(tr.itemType || '').toLowerCase();
//     await createReceiveBatchAndUnits(typeNorm, destInv, Number(tr.quantity), tr, accepterId, txn);

//     // commit and return (fresh tr)
//     await txn.commit();

//     try {
//       await accountService.logActivity(String(accepterId), 'transfer_create', ipAddress, browserInfo, `transferId:${transferId}`);
//     } catch (err) {
//       console.error('activity log failed (createTransfer)', err);
//     }

//     // reload the transfer with any associations if you need them
//     return await db.Transfer.findByPk(tr.transferId || tr.id);
//   } catch (err) {
//     // rollback if not already rolled back
//     try { if (txn) await txn.rollback(); } catch (_) { /* ignore */ }
//     throw err;
//   }
// }
async function acceptTransfer(transferId, accepterId, accepterRole, ipAddress, browserInfo) {
  if (!transferId) throw { status: 400, message: 'transferId required' };

  const ADMIN_ROLES = ['superadmin', 'admin', 'super_admin'];
  const txn = await db.sequelize.transaction();
  try {
    const tr = await db.Transfer.findByPk(transferId, { transaction: txn });
    if (!tr) {
      await txn.rollback();
      throw { status: 404, message: 'Transfer not found' };
    }

    // allow both pending and in_transfer to be accepted
    if (!['in_transfer', 'pending'].includes(String(tr.status || '').toLowerCase())) {
      await txn.rollback();
      throw { status: 400, message: 'Only pending or in_transfer can be accepted' };
    }

    // load toRoom to check roomInCharge
    let toRoom = null;
    if (tr.toRoomId) toRoom = await db.Room.findByPk(tr.toRoomId, { transaction: txn });
    const roomInCharge = toRoom?.roomInCharge ?? null;

    // normalize role; admin or room in charge allowed
    const roleLower = String(accepterRole || '').toLowerCase();
    const isAdmin = ADMIN_ROLES.includes(roleLower);

    if (!isAdmin) {
      // try matching accepterId === roomInCharge, or resolve via Account/User tables
      let accepterMatches = false;
      if (roomInCharge && String(roomInCharge) === String(accepterId)) accepterMatches = true;

      const acct = await db.Account.findByPk(accepterId, { transaction: txn }).catch(() => null);
      if (acct && (String(acct.accountId) === String(roomInCharge) || String(acct.id) === String(roomInCharge))) accepterMatches = true;

      if (!accepterMatches && db.User) {
        const user = await db.User.findByPk(accepterId, { transaction: txn }).catch(() => null);
        if (user && (String(user.userId ?? user.id) === String(roomInCharge))) accepterMatches = true;
      }

      if (!accepterMatches) {
        await txn.rollback();
        throw { status: 403, message: `Only room-in-charge or admin can accept this transfer (accepterId=${accepterId})` };
      }
    }

    // perform inventory adjustments (existing logic)...
    // (keep the existing inventory move code here unchanged)

    await tr.update({ status: 'transfer_accepted', acceptedBy: accepterId || null, acceptedAt: new Date() }, { transaction: txn });
    await txn.commit();

    // best-effort log (use your account service logger)
    try {
      await accountService.logActivity(String(accepterId), 'transfer_accept', ipAddress, browserInfo, `transferId:${tr.transferId || tr.id}`);
    } catch (e) {
      console.error('activity log failed (acceptTransfer)', e);
    }

    return tr;
  } catch (err) {
    if (txn && !txn.finished) await txn.rollback().catch(()=>{});
    throw err;
  }
}

/* ---------- helpers ---------- */

function getQuantity(inv) {
  if (!inv) return 0;
  if (typeof inv.totalQuantity !== 'undefined') return Number(inv.totalQuantity || 0);
  if (typeof inv.supplyQuantity !== 'undefined') return Number(inv.supplyQuantity || 0);
  if (typeof inv.quantity !== 'undefined') return Number(inv.quantity || 0);
  // fallback to sequelize getter if present
  try { return Number(inv.getDataValue && inv.getDataValue('quantity') || 0); } catch (_) { return 0; }
}

async function adjustInventory(inv, delta, txn) {
  if (!inv) throw { status: 500, message: 'Invalid inventory' };
  if (!Number.isFinite(Number(delta))) throw { status: 500, message: 'Invalid delta to adjustInventory' };
  const d = Number(delta);

  if (typeof inv.totalQuantity !== 'undefined') {
    inv.totalQuantity = Math.max(0, (inv.totalQuantity || 0) + d);
    if (typeof inv.status !== 'undefined') inv.status = computeInventoryStatus(inv.totalQuantity);
    await inv.save({ transaction: txn });
    return inv;
  }

  if (typeof inv.supplyQuantity !== 'undefined') {
    inv.supplyQuantity = Math.max(0, (inv.supplyQuantity || 0) + d);
    if (typeof inv.status !== 'undefined') inv.status = computeInventoryStatus(inv.supplyQuantity);
    await inv.save({ transaction: txn });
    return inv;
  }

  if (typeof inv.quantity !== 'undefined') {
    inv.quantity = Math.max(0, (inv.quantity || 0) + d);
    if (typeof inv.status !== 'undefined') inv.status = computeInventoryStatus(inv.quantity);
    await inv.save({ transaction: txn });
    return inv;
  }

  // fallback using generic setters
  try {
    const curr = Number(inv.getDataValue && inv.getDataValue('quantity') || 0);
    inv.setDataValue('quantity', Math.max(0, curr + d));
    if (typeof inv.status !== 'undefined') inv.status = computeInventoryStatus(inv.getDataValue('quantity'));
    await inv.save({ transaction: txn });
    return inv;
  } catch (err) {
    throw { status: 500, message: 'Unable to adjust inventory', detail: err.message || err };
  }
}

async function createReceiveBatchAndUnits(typeNorm, destInv, qty, tr, accepterId, txn) {
  if (!qty || qty <= 0) return; // nothing to create

  // apparel
  if (typeNorm === 'apparel') {
    const batch = await db.ReceiveApparel.create({
      roomId:          destInv.roomId,
      receivedFrom:    `Transfer #${tr.transferId}`,
      receivedBy:      accepterId || null,
      apparelName:     destInv.apparelName,
      apparelLevel:    destInv.apparelLevel,
      apparelType:     destInv.apparelType,
      apparelFor:      destInv.apparelFor,
      apparelSize:     destInv.apparelSize,
      apparelQuantity: qty
    }, { transaction: txn });

    if (db.Apparel) {
      const units = Array(qty).fill().map(() => ({
        receiveApparelId: batch.receiveApparelId,
        apparelInventoryId: destInv.apparelInventoryId ?? destInv.id,
        roomId: destInv.roomId,
        status: 'good'
      }));
      await db.Apparel.bulkCreate(units, { transaction: txn });
    }
    return;
  }

  // supplies (AdminSupply)
  if (typeNorm.includes('supply')) {
    const batch = await db.ReceiveAdminSupply.create({
      roomId:         destInv.roomId,
      receivedFrom:   `Transfer #${tr.transferId}`,
      receivedBy:     accepterId || null,
      supplyName:     destInv.supplyName,
      supplyQuantity: qty,
      supplyMeasure:  destInv.supplyMeasure
    }, { transaction: txn });

    if (db.AdminSupply) {
      const units = Array(qty).fill().map(() => ({
        receiveAdminSupplyId: batch.receiveAdminSupplyId,
        adminSupplyInventoryId: destInv.adminSupplyInventoryId ?? destInv.id,
        roomId: destInv.roomId,
        status: 'in_stock'
      }));
      await db.AdminSupply.bulkCreate(units, { transaction: txn });
    }
    return;
  }

  // gen items
  if (typeNorm.includes('gen')) {
    const batch = await db.ReceiveGenItem.create({
      roomId:          destInv.roomId,
      receivedFrom:    `Transfer #${tr.transferId}`,
      receivedBy:      accepterId || null,
      genItemName:     destInv.genItemName,
      genItemSize:     destInv.genItemSize ?? null,
      genItemQuantity: qty,
      genItemType:     destInv.genItemType
    }, { transaction: txn });

    if (db.GenItem) {
      const units = Array(qty).fill().map(() => ({
        receiveGenItemId: batch.receiveGenItemId,
        roomId: destInv.roomId,
        status: 'in_stock'
      }));
      await db.GenItem.bulkCreate(units, { transaction: txn });
    }
    return;
  }

  // unsupported type -> no-op
  return;
}

// ---- add these helpers if they don't exist already in this file ----
function computeInventoryStatus(remaining) {
  if (remaining <= 1) return 'out_of_stock';
  if (remaining < 10) return 'low_stock';
  return 'high_stock';
}

async function updateInventory(inv, qtyChange, opts = {}) {
  if (!inv) return;
  if (!Number.isFinite(Number(qtyChange))) {
    throw { status: 500, message: 'Invalid qtyChange to updateInventory' };
  }
  const delta = Number(qtyChange);
  const transaction = opts.transaction;

  if (typeof inv.totalQuantity !== 'undefined') {
    inv.totalQuantity = Math.max(0, (inv.totalQuantity || 0) + delta);
    if (typeof inv.status !== 'undefined') inv.status = computeInventoryStatus(inv.totalQuantity);
    await inv.save({ transaction });
    return;
  }

  if (typeof inv.supplyQuantity !== 'undefined') {
    inv.supplyQuantity = Math.max(0, (inv.supplyQuantity || 0) + delta);
    if (typeof inv.status !== 'undefined') inv.status = computeInventoryStatus(inv.supplyQuantity);
    await inv.save({ transaction });
    return;
  }

  if (typeof inv.quantity !== 'undefined') {
    inv.quantity = Math.max(0, (inv.quantity || 0) + delta);
    if (typeof inv.status !== 'undefined') inv.status = computeInventoryStatus(inv.quantity);
    await inv.save({ transaction });
    return;
  }

  // fallback for weird models
  try {
    const current = Number(inv.getDataValue('quantity') || 0);
    inv.setDataValue('quantity', Math.max(0, current + delta));
    await inv.save({ transaction });
  } catch (err) {
    throw { status: 500, message: 'Unable to update inventory quantity', detail: err.message || err };
  }
}

function pickQuantity(inv) {
  if (!inv) return 0;
  if (typeof inv.totalQuantity !== 'undefined') return inv.totalQuantity || 0;
  if (typeof inv.supplyQuantity !== 'undefined') return inv.supplyQuantity || 0;
  if (typeof inv.quantity !== 'undefined') return inv.quantity || 0;
  return 0;
}

function inventoryModelFor(itemType) {
  if (itemType === 'apparel') return db.ApparelInventory;
  if (itemType === 'supply') return db.AdminSupplyInventory;
  if (itemType === 'genItem') return db.GenItemInventory;
  return null;
}
async function findOrCreateMatchingInventory(model, exampleInv, roomId, opts = {}) {
  const transaction = opts.transaction;
  // apparel
  if (model === db.ApparelInventory) {
    const where = {
      roomId,
      apparelName: exampleInv.apparelName,
      apparelLevel: exampleInv.apparelLevel,
      apparelType: exampleInv.apparelType,
      apparelFor: exampleInv.apparelFor,
      apparelSize: exampleInv.apparelSize
    };
    const [inv] = await db.ApparelInventory.findOrCreate({ where, defaults: Object.assign({ totalQuantity: 0 }, where), transaction });
    return inv;
  }
  // admin supply
  if (model === db.AdminSupplyInventory) {
    const where = { roomId, supplyName: exampleInv.supplyName, supplyMeasure: exampleInv.supplyMeasure };
    const [inv] = await db.AdminSupplyInventory.findOrCreate({ where, defaults: Object.assign({ totalQuantity: 0 }, where), transaction });
    return inv;
  }
  // gen item
  if (model === db.GenItemInventory) {
    const where = { roomId, genItemName: exampleInv.genItemName, genItemType: exampleInv.genItemType, genItemSize: exampleInv.genItemSize };
    const [inv] = await db.GenItemInventory.findOrCreate({ where, defaults: Object.assign({ totalQuantity: 0 }, where), transaction });
    return inv;
  }

  const [fallback] = await model.findOrCreate({ where: { roomId }, defaults: { totalQuantity: 0, roomId }, transaction });
  return fallback;
}

async function getById(id) {
  return db.Transfer.findByPk(id);
}
async function listTransfers({ where = {}, limit = 200, offset = 0 } = {}) {
  return db.Transfer.findAll({
    where,
    order: [['transferId','DESC']],
    limit,
    offset,
    include: [
      { model: db.Room, as: 'fromRoom', attributes: ['roomId','roomName','roomInCharge'], required: false },
      { model: db.Room, as: 'toRoom', attributes: ['roomId','roomName','roomInCharge'], required: false }
    ]
  });
}
