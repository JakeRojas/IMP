
================================================================================
File: config.json
Size: 562 B
================================================================================

{
    "database": {
        "host": "localhost",
        "port": 3306,
        "user": "root",
        "password": "root",
        "database": "IMP_db"
    },
    "secret": "THIS IS USED TO SIGN AND VERIFY JWT TOKENS, REPLACE IT WITH YOUR OWN SECRET, IT CAN BE ANY STRING", 
    "emailFrom": "info@node-mysql-signup-verification-api.com",
    "smtpOptions": {
        "host": "smtp.ethereal.email", 
        "port": 587,
        "auth": {
            "user":"samir.mohr@ethereal.email",
            "pass":"DybCr9vj2zAZtFeqcN"
        }
    }
}

================================================================================
File: notes.md
Size: 626 B
================================================================================

<!-- items should have this status: -->
    every room scanning status:
        used - in used item
        damage - damaged item
        misplaced item - item that is not belong to that room
    
    rooms status
        missing - missing item

    stockroom status:
        active - working item but not used
        inactive - out of stock/

<!-- roles should have -->
    super admin
    admin
    user

<!-- item category should have -->
    IT assets
    apparel assets
    admin assets

<!-- name casing -->
    pascal casing / TestTest : model name
    camel casing / testTest  : function name

================================================================================
File: package.json
Size: 1.02 kB
================================================================================

{
  "name": "imp",
  "version": "1.0.0",
  "description": "Inventory Management Project",
  "main": "server.js",
  "scripts": {
    "start": "node ./server.js",
    "start:dev": "nodemon ./server.js",
    "export:all": "folder2txt --output backend.txt C:/Users/Administrator/My Desktop/Inventory Monitoring/IMP --exclude node_modules"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcryptjs": "^3.0.2",
    "body-parser": "^1.20.3",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "crypto": "^1.0.1",
    "express": "^4.21.2",
    "express-jwt": "^8.5.1",
    "joi": "^17.13.3",
    "jsonwebtoken": "^9.0.2",
    "lodash": "^4.17.21",
    "multer": "^2.0.0",
    "mysql2": "^3.12.0",
    "ngrok": "^5.0.0-beta.2",
    "nodemailer": "^6.10.0",
    "pdfkit": "^0.17.2",
    "qrcode": "^1.5.4",
    "rootpath": "^0.1.2",
    "sequelize": "^6.37.5",
    "swagger-ui-express": "^5.0.1",
    "yamljs": "^0.3.0"
  },
  "devDependencies": {
    "folder2txt": "^1.0.2",
    "nodemon": "^3.1.9"
  }
}


================================================================================
File: README.md
Size: 37 B
================================================================================

# IMP
Inventory Management Project


================================================================================
File: server.js
Size: 3.58 kB
================================================================================

require('rootpath')();
const express         = require('express');
const app             = express();
const bodyParser      = require('body-parser');
const cookieParser    = require('cookie-parser');
const cors            = require('cors');
const errorHandler    = require('_middlewares/error-handler');
const path            = require('path');

// ─── JSON / URL-ENCODED PARSING ───────────────────────────────────────────────
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// ─── BODY-PARSER & COOKIE ───────────────────────────────────────────────────
app.use(bodyParser.urlencoded({extended: false }));
app.use(bodyParser.json()); 
app.use(cookieParser());

// ─── FRONTEND PORT ───────────────────────────────────────────────────
const allowedOrigins = [
  'http://localhost:4200',      // duplicated project
  'http://localhost:4000',      // angularBoilerplate
  'http://localhost:3000',      // nextjs frontend
  'http://221.121.99.208:4200'    // your other device (keep or remove as needed)
];

app.use(cors({
  origin: function(origin, callback){
    // allow requests with no origin (like mobile apps or curl)
    if(!origin) return callback(null, true);
    if(allowedOrigins.indexOf(origin) !== -1){
      callback(null, true);
    } else {
      callback(new Error('CORS policy does not allow access from this origin'));
    }
  },
  credentials: true
}));

// ─── SERVE UPLOADS DIRECTORY ────────────────────────────────────────────────
app.use('/uploads', express.static(path.join(__dirname, '..', 'uploads')));
// ─── API ROUTES ────────────────────────────────────────────────
app.use('/rooms',       require('./_controllers/room.controller'));
app.use('/accounts',    require('./_controllers/account.controller'));
app.use('/qr',          require('./_controllers/qr.controller'));
app.use('/req-stock',   require('./_controllers/request.stock.controller'));
app.use('/req-item',    require('./_controllers/request.item.controller'));
app.use('/transfers',   require('./_controllers/transfer.controller'));

// ─── SWAGGER DOCS ROUTES ────────────────────────────────────────────────
app.use('/api-docs',    require('./_helpers/swagger'));

// ─── GLOBAL ERROR HANDLER ────────────────────────────────────────────────
app.use(errorHandler);

// ─── START SERVER ────────────────────────────────────────────────
const port = process.env.NODE_ENV === 'production' ? (process.env.PORT || 80): 5000;
app.listen(port, () => console.log('Server listening on port' + port));
// const port = process.env.NODE_ENV === 'production' ? (process.env.PORT || 80) : 5000;
// app.listen(port, '0.0.0.0', () => console.log(`Server listening on 0.0.0.0:${port}`));

================================================================================
File: swagger.yaml
Size: 23.7 kB
================================================================================

openapi: 3.0.0
info:
  title: Node.js Sign-up and Verification API
  description: Node.js and MySQL - API with email sign-up, verification, authentication and forgot password
  version: 1.0.0

servers:
  - url: http://localhost:5000
    description: Local development server

paths:
  /accounts/authenticate:
    post:
      summary: Authenticate account credentials and return a JWT token and a cookie with a refresh token
      description: Accounts must be verified before authenticating.
      operationId: authenticate
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                email:
                  type: string
                  example: "jason@example.com"
                password:
                  type: string
                  example: "pass123"
              required:
                - email
                - password
      responses:
        "200":
          description: Account details, a JWT access token and a refresh token cookie
          headers:
            Set-Cookie:
              description: "`refreshToken`"
              schema:
                type: string
                example: refreshToken=51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550; Path=/; Expires=Tue, 16 Jun 2020 09:14:17 GMT; HttpOnly
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
                  isVerified:
                    type: boolean
                    example: true
                  jwtToken:
                    type: string
                    example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1ZWIxMmUxOTdlMDZhNzZjY2RlZmMxMjEiLCJpZCI6IjVlYjEyZTE5N2UwNmE3NmNjZGVmYzEyMSIsImlhdCI6MTU4ODc1ODE1N30.xR9H0STbFOpSkuGA9jHNZOJ6eS7umHHqKRhI807YT1Y"
        "400":
          description: The email or password is incorrect
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Email or password is incorrect"
  /accounts/refresh-token:
    post:
      summary: Use a refresh token to generate a new JWT token and a new refresh token
      description: The refresh token is sent and returned via cookies.
      operationId: refreshToken
      parameters:
        - in: cookie
          name: refreshToken
          description: The `refreshToken` cookie
          schema:
            type: string
            example: 51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550
      responses:
        "200":
          description: Account details, a JWT access token and a new refresh token cookie
          headers:
            Set-Cookie:
              description: "`refreshToken`"
              schema:
                type: string
                example: refreshToken=51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550; Path=/; Expires=Tue, 16 Jun 2020 09:14:17 GMT; HttpOnly
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
                  isVerified:
                    type: boolean
                    example: true
                  jwtToken:
                    type: string
                    example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1ZWIxMmUxOTdlMDZhNzZjY2RlZmMxMjEiLCJpZCI6IjVlYjEyZTE5N2UwNmE3NmNjZGVmYzEyMSIsImlhdCI6MTU4ODc1ODE1N30.xR9H0STbFOpSkuGA9jHNZOJ6eS7umHHqKRhI807YT1Y"
        "400":
          description: The refresh token is invalid, revoked or expired
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Invalid token"
  /accounts/revoke-token:
    post:
      summary: Revoke a refresh token
      description: Admin users can revoke the tokens of any account, regular users can only revoke their own tokens.
      operationId: revokeToken
      security:
        - bearerAuth: []
      parameters:
        - in: cookie
          name: refreshToken
          description: The refresh token can be sent in a cookie or the post body, if both are sent the token in the body is used.
          schema:
            type: string
            example: 51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                token:
                  type: string
                  example: "51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550"
      responses:
        "200":
          description: The refresh token was successfully revoked
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Token revoked"
        "400":
          description: The refresh token is invalid
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Invalid token"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
  /accounts/register:
    post:
      summary: Register a new user account and send a verification email
      description: The first account registered in the system is assigned the `Admin` role, other accounts are assigned the `User` role.
      operationId: register
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                title:
                  type: string
                  example: "Mr"
                firstName:
                  type: string
                  example: "Jason"
                lastName:
                  type: string
                  example: "Watmore"
                email:
                  type: string
                  example: "jason@example.com"
                password:
                  type: string
                  example: "pass123"
                confirmPassword:
                  type: string
                  example: "pass123"
                acceptTerms:
                  type: boolean
              required:
                - title
                - firstName
                - lastName
                - email
                - password
                - confirmPassword
                - acceptTerms
      responses:
        "200":
          description: The registration request was successful and a verification email has been sent to the specified email address
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Registration successful, please check your email for verification instructions"
  /accounts/verify-email:
    post:
      summary: Verify a new account with a verification token received by email after registration
      operationId: verifyEmail
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                token:
                  type: string
                  example: "3c7f8d9c4cb348ff95a0b74a1452aa24fc9611bb76768bb9eafeeb826ddae2935f1880bc7713318f"
              required:
                - token
      responses:
        "200":
          description: Verification was successful so you can now login to the account
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Verification successful, you can now login"
        "400":
          description: Verification failed due to an invalid token
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Verification failed"
  /accounts/forgot-password:
    post:
      summary: Submit email address to reset the password on an account
      operationId: forgotPassword
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                email:
                  type: string
                  example: "jason@example.com"
              required:
                - email
      responses:
        "200":
          description: The request was received and an email has been sent to the specified address with password reset instructions (if the email address is associated with an account)
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Please check your email for password reset instructions"
  /accounts/validate-reset-token:
    post:
      summary: Validate the reset password token received by email after submitting to the /accounts/forgot-password route
      operationId: validateResetToken
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                token:
                  type: string
                  example: "3c7f8d9c4cb348ff95a0b74a1452aa24fc9611bb76768bb9eafeeb826ddae2935f1880bc7713318f"
              required:
                - token
      responses:
        "200":
          description: Token is valid
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Token is valid"
        "400":
          description: Token is invalid
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Invalid token"
  /accounts/reset-password:
    post:
      summary: Reset the password for an account
      operationId: resetPassword
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                token:
                  type: string
                  example: "3c7f8d9c4cb348ff95a0b74a1452aa24fc9611bb76768bb9eafeeb826ddae2935f1880bc7713318f"
                password:
                  type: string
                  example: "newPass123"
                confirmPassword:
                  type: string
                  example: "newPass123"
              required:
                - token
                - password
                - confirmPassword
      responses:
        "200":
          description: Password reset was successful so you can now login to the account with the new password
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Password reset successful, you can now login"
        "400":
          description: Password reset failed due to an invalid token
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Invalid token"
  /accounts:
    get:
      summary: Get a list of all accounts
      description: Restricted to admin users.
      operationId: getAllAccounts
      security:
        - bearerAuth: []
      responses:
        "200":
          description: An array of all accounts
          content:
            application/json:
              schema:
                type: array
                items:
                  type: object
                  properties:
                    id:
                      type: string
                      example: "5eb12e197e06a76ccdefc121"
                    title:
                      type: string
                      example: "Mr"
                    firstName:
                      type: string
                      example: "Jason"
                    lastName:
                      type: string
                      example: "Watmore"
                    email:
                      type: string
                      example: "jason@example.com"
                    role:
                      type: string
                      example: "Admin"
                    created:
                      type: string
                      example: "2020-05-05T09:12:57.848Z"
                    updated:
                      type: string
                      example: "2020-05-08T03:11:21.553Z"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
    post:
      summary: Create a new account
      description: Restricted to admin users.
      operationId: createAccount
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                title:
                  type: string
                  example: "Mr"
                firstName:
                  type: string
                  example: "Jason"
                lastName:
                  type: string
                  example: "Watmore"
                email:
                  type: string
                  example: "jason@example.com"
                password:
                  type: string
                  example: "pass123"
                confirmPassword:
                  type: string
                  example: "pass123"
                role:
                  type: string
                  enum: [Admin, User]
              required:
                - title
                - firstName
                - lastName
                - email
                - password
                - confirmPassword
                - role
      responses:
        "200":
          description: Account created successfully, verification is not required for accounts created with this endpoint. The details of the new account are returned.
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
        "400":
          description: Email is already registered
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Email 'jason@example.com' is already registered"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
  /accounts/{id}:
    parameters:
      - in: path
        name: id
        description: Account id
        required: true
        example: "5eb12e197e06a76ccdefc121"
        schema:
          type: string
    get:
      summary: Get a single account by id
      description: Admin users can access any account, regular users are restricted to their own account.
      operationId: getAccountById
      security:
        - bearerAuth: []
      responses:
        "200":
          description: Details of the specified account
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
                  updated:
                    type: string
                    example: "2020-05-08T03:11:21.553Z"
        "404":
          $ref: "#/components/responses/NotFoundError"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
    put:
      summary: Update an account
      description: Admin users can update any account including role, regular users are restricted to their own account and cannot update role.
      operationId: updateAccount
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                title:
                  type: string
                  example: "Mr"
                firstName:
                  type: string
                  example: "Jason"
                lastName:
                  type: string
                  example: "Watmore"
                email:
                  type: string
                  example: "jason@example.com"
                password:
                  type: string
                  example: "pass123"
                confirmPassword:
                  type: string
                  example: "pass123"
                role:
                  type: string
                  enum: [Admin, User]
      responses:
        "200":
          description: Account updated successfully. The details of the updated account are returned.
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
                  updated:
                    type: string
                    example: "2020-05-08T03:11:21.553Z"
        "404":
          $ref: "#/components/responses/NotFoundError"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
    delete:
      summary: Delete an account
      description: Admin users can delete any account, regular users are restricted to their own account.
      operationId: deleteAccount
      security:
        - bearerAuth: []
      responses:
        "200":
          description: Account deleted successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Account deleted successfully"
        "404":
          $ref: "#/components/responses/NotFoundError"
        "401":
          $ref: "#/components/responses/UnauthorizedError"

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  responses:
    UnauthorizedError:
      description: Access token is missing or invalid, or the user does not have access to perform the action
      content:
        application/json:
          schema:
            type: object
            properties:
              message:
                type: string
                example: "Unauthorized"
    NotFoundError:
      description: Not Found
      content:
        application/json:
          schema:
            type: object
            properties:
              message:
                type: string
                example: "Not Found"

================================================================================
File: _controllers\account.controller.js
Size: 12.82 kB
================================================================================

// main functions of account controller
const express   = require('express');
const router    = express. Router(); 
const Joi       = require('joi');

const validateRequest   = require('_middlewares/validate-request'); 
const authorize         = require('_middlewares/authorize');
const Role              = require('_helpers/role');
const accountService    = require('_services/account.service');
const db                = require('_helpers/db-handler');

router.post('/register',                registerSchema, register);
router.post('/authenticate',            authenticateSchema, authenticate);
router.post('/refresh-token',           refreshToken);
router.post('/revoke-token',            authorize(), revokeTokenSchema, revokeToken); 
router.post('/verify-email',            verifyEmailSchema, verifyEmail);
router.post('/forgot-password',         forgotPasswordSchema, forgotPassword);
router.post('/validate-reset-token',    validateResetTokenSchema, validateResetToken);
router.post('/reset-password',          resetPasswordSchema, resetPassword);

router.post('/:accountId/activity',     authorize(), getActivities);
router.get('/activity-logs',            authorize(Role.SuperAdmin), getAllActivityLogs);
router.get('/exists',                   existsAccount);

router.post('/create-user',             authorize (Role.SuperAdmin), createSchema, create);
router.get('/',                         authorize (Role.SuperAdmin), getAll);
router.get('/:accountId',               authorize(), getById);
router.put('/:accountId',               authorize(Role.SuperAdmin), updateSchema, update);

router.delete('/:accountId',            authorize(Role.SuperAdmin), _delete);

module.exports = router;

function authenticateSchema(req, res, next) { 
    const schema = Joi.object({
        email: Joi.string().required(),
        password: Joi.string().required()
    });

    validateRequest(req, next, schema);
}
async function authenticate(req, res, next) {
try {
    const { email, password } = req.body;
    const ipAddress = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
    const browserInfo = req.headers['user-agent'] || 'Unknown Browser';

    // accountService.authenticate returns { ...basicDetails(account), jwtToken, refreshToken: token }
    const account = await accountService.authenticate({ email, password, ipAddress, browserInfo });

    if (account.status === 'deactivated') {
      return res.status(403).json({ message: 'Account is deactivated. Contact administrator.' });
    }

    // set jwt cookie (if you want a jwt cookie) — keep same options as before
    res.cookie('token', account.jwtToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 60 * 1000, // 1h
    });

    // set refresh-token cookie (httpOnly) — setTokenCookie already does this
    setTokenCookie(res, account.refreshToken);

    // return the account object (frontend expects account + jwtToken)
    return res.json(account);
} catch (err) {
    next(err);
}
}
//===================Logging Function=======================================
function getActivities(req, res, next) {
    const filters = {
        actionType: req.query.actionType,
        startDate: req.query.startDate,
        endDate: req.query.endDate
    };
    accountService.getAccountActivities(req.params.id, filters)
        .then(activities => res.json(activities))
        .catch(next);
}
function getAllActivityLogs(req, res, next) {
    const filters = {
        actionType: req.query.actionType,
        startDate: req.query.startDate,
        endDate: req.query.endDate,
        userId: req.query.userId
    };
    
    accountService.getAllActivityLogs(filters)
        .then(logs => res.json({
            success: true,
            data: logs
        }))
        .catch(next);
}
async function refreshToken(req, res, next) {
    try {
      // try common locations for the refresh token
      const token =
        (req.cookies && req.cookies.refreshToken) ||
        req.body?.token ||
        req.get('x-refresh-token') ||
        req.headers['x-refresh-token'];
  
      // No token -> not logged in (choose 204 to avoid console noise)
      if (!token) {
        return res.status(204).end(); // or res.status(401).json({ message: 'No refresh token' });
      }
  
      // call service — wrap in try so service errors are handled
      let accountPayload;
      try {
        accountPayload = await accountService.refreshToken({ token, ipAddress: req.ip });
      } catch (serviceErr) {
        // service-level failure (invalid token / DB error). Distinguish if possible:
        if (serviceErr && serviceErr.message && serviceErr.message.toLowerCase().includes('invalid')) {
          return res.status(401).json({ message: 'Invalid or expired refresh token' });
        }
        // unexpected service error: log and forward
        console.error('refreshToken service error:', serviceErr);
        return res.status(500).json({ message: 'Internal error while refreshing token' });
      }
  
      // No payload => treat as unauthorized
      if (!accountPayload) {
        return res.status(401).json({ message: 'Invalid or expired refresh token' });
      }
  
      // success: return payload (tokens/account)
      return res.json(accountPayload);
    } catch (err) {
      console.error('refreshToken handler unexpected error:', err);
      // fallback: don't expose internal errors
      return res.status(500).json({ message: 'Unexpected server error' });
    }
}
function revokeTokenSchema(req, res, next) { 
    const schema = Joi.object({
        token: Joi.string().empty('')
    });
    validateRequest(req, next, schema);
}
async function revokeToken (req, res, next) {
    try {
        const token = req.body.token || req.cookies.refreshToken;
        const ipAddress = req.ip;

        if (!token) return res.status(400).json({ message: 'Token is required' });

        // Find refresh token (validate it)
        const refreshToken = await db.RefreshToken.findOne({ where: { token } });
        if (!refreshToken || !refreshToken.isActive) {
            // Keep response consistent with service errors
            return res.status(400).json({ message: 'Invalid token' });
        }

        // Ensure token belongs to caller or caller is SuperAdmin
        if (refreshToken.accountId !== req.user.accountId && req.user.role !== Role.SuperAdmin) {
            return res.status(401).json({ message: 'Unauthorized' });
        }

        // Revoke via service (keeps single place for revoke logic)
        await accountService.revokeToken({ token, ipAddress });
        return res.json({ message: 'Token revoked' });
    } catch (err) {
        next(err);
    }
}
function registerSchema(req, res, next) {
    const schema = Joi.object({
        title: Joi.string().required(),
        firstName: Joi.string().required(), 
        lastName: Joi.string().required(),
        email: Joi.string().email().required(),
        password: Joi.string().min(6).required(),
        confirmPassword: Joi.string().valid(Joi.ref('password')).required(), 
    });
    validateRequest(req, next, schema);
}
function register(req, res, next) {
    accountService.register(req.body, req.get('origin'))
        .then(() => res.json({ message: 'Registration successful, please check your email for verification instructions' })) 
        .catch(next);
}
async function existsAccount(req, res, next) {
    try {
      const total = await db.Account.count();
      const exists = (total && total > 0);
      return res.json({ exists });
    } catch (err) {
      console.error('accounts.exists error:', err && err.stack ? err.stack : err);
      return res.status(500).json({ message: 'Internal server error' });
    }
}
function verifyEmailSchema(req, res, next) {
    const schema = Joi.object({
        token: Joi.string().required()
    });
    validateRequest(req, next, schema);
}
function verifyEmail(req, res, next) {
    accountService.verifyEmail(req.body)
        .then(() => res.json({ message: 'Verification successful, you can now login' })) 
        .catch(next);
}
function forgotPasswordSchema(req, res, next) {
    const schema = Joi.object({
        email: Joi.string().email().required()
    });
    validateRequest(req, next, schema);
}
function forgotPassword(req, res, next) {
    accountService.forgotPassword(req.body, req.get('origin'))
        .then(() => res.json({ message: 'Please check your email for password reset instructions' })) 
        .catch(next);
}
function validateResetTokenSchema(req, res, next) {
    const schema = Joi.object({
        token: Joi.string().required()
    });
    validateRequest(req, next, schema);
}
function validateResetToken(req, res, next) {
    accountService.validateResetToken(req.body)
        .then(() => res.json({ message: 'Token is valid' }))
        .catch(next);
}
function resetPasswordSchema(req, res, next) {
    const schema = Joi.object({
        token: Joi.string().required(),
        password: Joi.string().min(6).required(),
        confirmPassword: Joi.string().valid(Joi.ref('password')).required()
    });
    validateRequest(req, next, schema);
}
function resetPassword(req, res, next) {
    const { token, password } = req.body;
    const ipAddress = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
    const browserInfo = req.headers['user-agent'] || 'Unknown Browser';
  
    accountService.resetPassword({ token, password }, ipAddress, browserInfo)
      .then(() => {
        res.json({ message: 'Password reset successful, you can now login' });
      })
      .catch(next);
}
function getAll(req, res, next) {
    accountService.getAll()
        .then (account => res.json (account))
        .catch(next);
}
function getById(req, res, next) {
    accountService.getById(req.params.accountId)
        .then(account => account ? res.json(account) : res.sendStatus(404)) 
        .catch(next);
}
function createSchema (req, res, next) {
    const schema = Joi.object({
        title: Joi.string().required(), 
        firstName: Joi.string().required(), 
        lastName: Joi.string().required(), 
        email: Joi.string().email().required(),
        password: Joi.string().min(6).required(), 
        confirmPassword: Joi.string().valid(Joi.ref('password')).required(),
        role: Joi.string().valid(Role. SuperAdmin, Role.Admin, Role.User, Role.StockroomAdmin, Role.Teacher).required(),
        status: Joi.string().valid('active','deactivated').optional(),
    });
    validateRequest(req, next, schema);
}
function create(req, res, next) {
    accountService.create(req.body) 
    .then (account => res.json (account)) 
    .catch(next);
}
function updateSchema(req, res, next) { 
    const schema = Joi.object({
        title: Joi.string().empty(''), 
        firstName: Joi.string().empty(''), 
        lastName: Joi.string().empty(''),
        email: Joi.string().email().empty(''),
        password: Joi.string().min(6).empty(''),
        confirmPassword: Joi.string().valid(Joi.ref('password')).empty(''),
        status: Joi.string().valid('active', 'deactivated').empty(''),
        role: Joi.string().valid(Role. SuperAdmin, Role.Admin, Role.User, Role.StockroomAdmin, Role.Teacher).empty('')
    });
    validateRequest(req, next, schema);
}
function update(req, res, next) {
  
    const ipAddress = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
    const browserInfo = req.headers['user-agent'] || 'Unknown Browser';
  
    accountService.update(req.params.accountId, req.body, ipAddress, browserInfo)
      .then(account => {
        res.json({
          success: true,
          message: 'Account updated successfully',
          account: account
        });
      })
      .catch(next);
}
async function _delete(req, res, next) {
    try {
      const accountId = parseInt(req.params.accountId || req.params.accountId, 10);
      if (Number.isNaN(accountId)) return res.status(400).json({ message: 'Invalid id' });
  
      // soft delete
      await accountService.update(accountId, { status: 'deactivated' });
      res.json({ message: 'Account deactivated' });
    } catch (err) {
      next(err);
    }
}
function setTokenCookie(res, token) {
  const cookieOptions = {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    expires: new Date(Date.now() + 7*24*60*60*1000)
  };
  res.cookie('refreshToken', token, cookieOptions);
}

================================================================================
File: _controllers\qr.controller.js
Size: 8.88 kB
================================================================================

const PDFDocument = require('pdfkit');
const fs          = require('fs');
const express     = require('express');
const router      = express.Router();

const qrService   = require('_services/qr.service'); 
const db          = require('_helpers/db-handler');

router.post('/scan',                                scanItem);
router.post('/:stockroomType/unit/:unitId/release', releaseUnit);

router.get('/:stockroomType/:inventoryId/qrcode', getBatchQr);
router.get('/:stockroomType/unit/:unitId/qrcode', qrGeneratorUnit);

router.get('/:stockroomType/room/:roomId/pdf-all', generateAllPdf);

module.exports = router;

async function getBatchQr(req, res, next) {
  try {
    const stockroomType = String(req.params.stockroomType || '').toLowerCase();
    const inventoryId = Number(req.params.inventoryId);
    const out = await qrService.generateBatchQR({ stockroomType, inventoryId });
    const pngPath = out && (out.absolutePath || out.path || out.filepath);
    if (!pngPath || !fs.existsSync(pngPath)) return res.status(404).json({ message: 'QR not found' });

    res.sendFile(pngPath);
  } catch (err) {
    next(err);
  }
}
async function qrGeneratorUnit(req, res, next) {
  try {
    const stockroomType = req.params.stockroomType; 
    const unitId = parseInt(req.params.unitId, 10);
    if (!stockroomType || Number.isNaN(unitId)) return res.status(400).json({ message: 'Invalid params' });

    const { filename, absolutePath } = await qrService.generateUnitQR({ stockroomType, unitId });
    const buffer = await fs.promises.readFile(absolutePath);
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.type('png').send(buffer);
  } catch (err) { next(err); }
}
async function scanItem(req, res, next) {
  try {
    const { qrId } = req.body;
    const item = await qrService.scanItem(qrId);
    return res.json({ item });
  } catch (err) {
    next(err);
  }
}
async function releaseUnit(req, res, next) {
  try {
    const stockroomType = req.params.stockroomType;
    const unitId = parseInt(req.params.unitId, 10);
    const actorId = req.body?.actorId;

    if (!stockroomType || Number.isNaN(unitId)) return res.status(400).json({ message: 'Invalid params' });

    // delegate to specific service depending on stockroomType
    if (stockroomType === 'apparel') {
      const apparelService = require('_services/apparel.service');
      const result = await apparelService.releaseUnitById(unitId, { actorId });
      return res.json(result);
    } else if (stockroomType === 'admin-supply' || stockroomType === 'supply') {
      const supplyService = require('_services/adminSupply.service');
      const result = await supplyService.releaseUnitById(unitId, { actorId });
      return res.json(result);
    } else {
      // fallback — you can add gen item handler similarly
      return res.status(400).json({ message: 'Unsupported stockroomType for unit release' });
    }
  } catch (err) { next(err); }
}
async function generateAllPdf(req, res, next) {
  try {
    const stockroomType = String(req.params.stockroomType || '').toLowerCase();
    const roomId = parseInt(req.params.roomId, 10);
    if (!stockroomType || Number.isNaN(roomId)) return res.status(400).json({ message: 'Invalid params' });

    // Load inventory for the room/type (adapt model names to your project if needed)
    let inventory = [];
    if (stockroomType === 'apparel') {
      inventory = await db.ApparelInventory.findAll({ where: { roomId } });
    } else if (stockroomType === 'supply') {
      inventory = await db.AdminSupplyInventory.findAll({ where: { roomId } });
    } else if (stockroomType === 'genitem' || stockroomType === 'it' || stockroomType === 'maintenance') {
      inventory = await db.GenItemInventory.findAll({ where: { roomId } });
    } else {
      const modelName = stockroomType + 'Inventory';
      if (db[modelName]) inventory = await db[modelName].findAll({ where: { roomId } });
    }

    if (!inventory || inventory.length === 0) {
      return res.status(404).json({ message: 'No inventory found for this room/type' });
    }

    // Helper to safely read candidate fields (also checks dataValues for Sequelize instances)
    function tryFields(obj, ...keys) {
      if (!obj) return null;
      for (const k of keys) {
        if (obj[k] !== undefined && obj[k] !== null) return obj[k];
        if (obj.dataValues && obj.dataValues[k] !== undefined && obj.dataValues[k] !== null) return obj.dataValues[k];
      }
      return null;
    }

    // Build array of items with image path and label (sku). Keep invId for fallback or later use.
    const qrItems = [];
    for (let idx = 0; idx < inventory.length; idx++) {
      const inv = inventory[idx];
      const invId = tryFields(inv,
        'receiveApparelId', 'apparelInventoryId', 'adminSupplyInventoryId', 'genItemInventoryId', 'id'
      );

      const out = await qrService.generateBatchQR({ stockroomType, inventoryId: invId });
      const pngPath = out && (out.absolutePath || out.path || out.filepath);

      const labelCandidate = tryFields(inv,
        'sku', 'code', 'itemCode', 'apparelSku', 'adminSupplyCode', 'genItemSku',
        'name', 'title', 'apparelName', 'supplyName', 'genItemName', 'itemName',
        'description', 'serialNumber'
      );

      // Final label fallback order:
      // 1) labelCandidate (preferred)
      // 2) invId (if present)
      // 3) "Item #<index+1>" as last resort to avoid 'undefined'
      const label = labelCandidate !== null && labelCandidate !== undefined
        ? String(labelCandidate)
        : (invId !== undefined && invId !== null ? String(invId) : `Item #${idx + 1}`);

      if (pngPath) {
        qrItems.push({ imgPath: pngPath, label, invId });
      } else {
        // optionally include items without PNG (they will show "QR missing" placeholders)
        qrItems.push({ imgPath: null, label, invId });
      }
    }

    if (!qrItems.length) {
      return res.status(404).json({ message: 'No QR images generated' });
    }

    // Prepare PDF response
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="qrcodes-${stockroomType}-room-${roomId}.pdf"`);

    const doc = new PDFDocument({ autoFirstPage: false, size: 'LETTER', margin: 0 });
    doc.pipe(res);

    // Layout constants
    const POINTS_PER_INCH = 72;
    const PAGE_WIDTH = 8.5 * POINTS_PER_INCH; // 612
    const PAGE_HEIGHT = 11 * POINTS_PER_INCH; // 792
    const MARGIN = 0.5 * POINTS_PER_INCH;     // half inch margin (36pt)
    const QR_SIDE = 1 * POINTS_PER_INCH;     // 1 inch QR (72pt)
    const LABEL_HEIGHT = 12;                 // room for label under QR (12pt)
    const CELL_HEIGHT = QR_SIDE + LABEL_HEIGHT;

    const usableWidth = PAGE_WIDTH - 2 * MARGIN;
    const usableHeight = PAGE_HEIGHT - 2 * MARGIN;

    // how many fit horizontally / vertically
    const cols = Math.max(1, Math.floor(usableWidth / QR_SIDE));
    const rows = Math.max(1, Math.floor(usableHeight / CELL_HEIGHT));
    const perPage = cols * rows;

    // distribute leftover space as gaps
    const gapX = (usableWidth - cols * QR_SIDE) / (cols + 1);
    const gapY = (usableHeight - rows * CELL_HEIGHT) / (rows + 1);
    const hGap = Math.max(0, gapX);
    const vGap = Math.max(0, gapY);

    // font defaults
    doc.font('Helvetica');

    for (let i = 0; i < qrItems.length; i++) {
      const indexInPage = i % perPage;
      if (indexInPage === 0) {
        doc.addPage({ size: 'LETTER', margin: 0 });
      }

      const col = indexInPage % cols;
      const row = Math.floor(indexInPage / cols);

      const x = MARGIN + hGap + col * (QR_SIDE + hGap);
      const y = MARGIN + vGap + row * (CELL_HEIGHT + vGap);

      const { imgPath, label } = qrItems[i];

      if (imgPath && fs.existsSync(imgPath)) {
        try {
          doc.image(imgPath, x, y, { width: QR_SIDE, height: QR_SIDE, align: 'center', valign: 'center' });
        } catch (imgErr) {
          doc.fontSize(8).text('QR image load error', x, y + QR_SIDE / 2 - 4, { width: QR_SIDE, align: 'center' });
        }
      } else {
        doc.fontSize(8).text('QR missing', x, y + QR_SIDE / 2 - 4, { width: QR_SIDE, align: 'center' });
      }

      // draw SKU label under the QR
      const labelY = y + QR_SIDE + 4; // small gap between QR and label
      doc.fontSize(10);
      doc.text(label, x, labelY, { width: QR_SIDE, align: 'center' });
    }

    doc.end();
  } catch (err) {
    console.error('generateAllPdf error:', err && err.stack ? err.stack : err);
    return res.status(500).json({ message: 'Internal server error while generating PDF' });
  }
}

================================================================================
File: _controllers\request.item.controller.js
Size: 3.72 kB
================================================================================

// _controllers/itemRequest.controller.js
const express = require('express');
const router  = express.Router();
const Joi     = require('joi');

const itemRequestService  = require('_services/request.item.service');
const validateRequest     = require('_middlewares/validate-request');
const authorize           = require('_middlewares/authorize');
const Role                = require('_helpers/role');

router.post('/', authorize([Role.SuperAdmin, Role.Teacher, Role.User]), createSchema, createRequest);

router.get('/',     authorize([Role.SuperAdmin, Role.StockroomAdmin, Role.Teacher, Role.User]), listRequests);
router.get('/:id',  authorize([Role.SuperAdmin, Role.StockroomAdmin, Role.Teacher, Role.User]), getRequestById);

router.post('/:id/accept',  authorize([Role.SuperAdmin, Role.StockroomAdmin]), acceptRequest);
router.post('/:id/decline', authorize([Role.SuperAdmin, Role.StockroomAdmin]), declineRequest);
router.post('/:id/release', authorize([Role.SuperAdmin, Role.StockroomAdmin]), releaseRequest);

router.post('/:id/fulfill', authorize([Role.SuperAdmin, Role.Teacher, Role.User]), fulfillRequest);

module.exports = router;

// Schemas
function createSchema(req, res, next) {
  const schema = Joi.object({
    requesterRoomId: Joi.number().integer().optional(),
    itemId: Joi.number().integer().allow(null),
    itemType: Joi.string().valid('apparel','supply','genItem').required(),
    quantity: Joi.number().integer().min(1).required(),
    note: Joi.string().max(500).allow('', null).optional(),
  });
  validateRequest(req, next, schema);
}

// Handlers
async function createRequest(req, res, next) {
  try {
    const payload = req.body;
    payload.accountId = req.user.accountId;
    const created = await itemRequestService.createItemRequest(payload);
    res.status(201).json({ success: true, data: created });
  } catch (err) { next(err); }
}
async function listRequests(req, res, next) {
  try {
    const where = {};
    if (req.query.status) where.status = req.query.status;
    if (req.query.accountId) where.accountId = req.query.accountId;
    const rows = await itemRequestService.listItemRequests({ where });
    res.json({ success: true, data: rows });
  } catch (err) { next(err); }
}
async function getRequestById(req, res, next) {
  try {
    const r = await itemRequestService.getItemRequestById(parseInt(req.params.id, 10));
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}
async function acceptRequest(req, res, next) {
  try {
    const r = await itemRequestService.acceptItemRequest(parseInt(req.params.id, 10), req.user.accountId);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}
async function declineRequest(req, res, next) {
  try {
    const reason = req.body.reason || null;
    const r = await itemRequestService.declineItemRequest(parseInt(req.params.id, 10), req.user.accountId, reason);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}
async function releaseRequest(req, res, next) {
  try {
    const releaserId = req.user && req.user.accountId;
    if (!releaserId) return res.status(401).json({ success: false, message: 'Unauthenticated' });
    const id = parseInt(req.params.id, 10);
    const result = await itemRequestService.releaseItemRequest(id, releaserId);
    res.json({ success: true, data: result });
  } catch (err) { next(err); }
}
async function fulfillRequest(req, res, next) {
  try {
    const r = await itemRequestService.fulfillItemRequest(parseInt(req.params.id, 10), req.user.accountId);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}


================================================================================
File: _controllers\request.stock.controller.js
Size: 3.9 kB
================================================================================

const express = require('express');
const router  = express.Router();
const Joi     = require('joi');

const validateRequest = require('_middlewares/validate-request');
const authorize       = require('_middlewares/authorize');
const Role            = require('_helpers/role');
const stockService    = require('_services/request.stock.service');

router.post('/',  authorize([Role.SuperAdmin, Role.StockroomAdmin]),              createSchema, createStockRequestHandler);
router.get('/',   authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]),  listRequests);

router.get('/:stockRequestId',  authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getRequestById);

router.post('/:id/approve',     authorize([Role.SuperAdmin, Role.Admin]),           approveRequest);
router.post('/:id/disapprove',  authorize([Role.SuperAdmin, Role.Admin]),           disapproveRequest);
router.post('/:id/fulfill',     authorize([Role.SuperAdmin, Role.StockroomAdmin]),  fulfillRequest);

module.exports = router;

function createSchema(req, res, next) {
  const schema = Joi.object({
    accountId: Joi.number().integer().required(), // if auth sets req.user you may not need to pass acccountId
    requesterRoomId: Joi.number().integer().optional(),
    itemId: Joi.number().integer().optional(),
    itemType: Joi.string().valid('apparel','supply','genItem').required(),
    quantity: Joi.number().integer().min(1).required(),
    note: Joi.string().max(500).allow('', null).optional(),
  });
  validateRequest(req, next, schema);
}
async function createStockRequestHandler(req, res) {
  try {
    console.log('POST /req-stock body:', req.body, 'user:', req.user && { id: req.user.accountId || req.user.id, role: req.user.role });
    const created = await stockService.createStockRequest(req.body);
    return res.json({ data: created });
  } catch (err) {
    // Log full error to server console for debugging
    console.error('Error in createStockRequestHandler:', err && err.stack ? err.stack : err);

    // Normalize response so frontend receives a helpful JSON on failure
    const status = (err && err.status) || 500;
    const message = (err && (err.message || err.error || err.toString())) || 'Server error';
    return res.status(status).json({ message, details: process.env.NODE_ENV === 'development' ? (err && err.stack ? err.stack : err) : undefined });
  }
}
async function listRequests(req, res, next) {
  try {
    const where = {};
    if (req.query.status) where.status = req.query.status;
    if (req.query.acccountId) where.acccountId = req.query.acccountId;
    const rows = await stockService.listStockRequests({ where });
    res.json({ success: true, data: rows });
  } catch (err) { next(err); }
}
async function getRequestById(req, res, next) {
  try {
    const stockRequestId = parseInt(req.params.stockRequestId, 10);
    const r = await stockService.getStockRequestById(stockRequestId);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}
async function approveRequest(req, res, next) {
  try {
    const id = parseInt(req.params.id, 10);
    const r = await stockService.approveStockRequest(id, req.user?.accountId);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}
async function disapproveRequest(req, res, next) {
  try {
    const id = parseInt(req.params.id, 10);
    const reason = req.body.reason || null;
    const r = await stockService.disapproveStockRequest(id, req.user?.accountId, reason);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}
async function fulfillRequest(req, res, next) {
  try {
    const id = parseInt(req.params.id, 10);
    const r = await stockService.fulfillStockRequest(id, req.user?.accountId);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}

================================================================================
File: _controllers\room.controller.js
Size: 18.68 kB
================================================================================

const express   = require('express');
const router    = express.Router();
const Joi       = require('joi');
const fs        = require('fs');
const path      = require('path');

const roomService       = require('_services/room.service');
const validateRequest   = require('_middlewares/validate-request');
const authorize         = require('_middlewares/authorize');
const Role              = require('_helpers/role');

// POST -------------------------------------------------------------------------------------
router.post('/create-room',               authorize(Role.SuperAdmin), createRoomschema, createRoom);
router.post('/:roomId/receive/apparel',   authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), receiveApparelSchema,      receiveApparel);
router.post('/:roomId/receive/supply',    authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), receiveAdminSupplySchema,  receiveAdminSupply);
router.post('/:roomId/receive/item',      authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), receiveGenItemSchema,      receiveGenItem);

router.post('/:roomId/release/apparel',   authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), releaseApparel);
router.post('/:roomId/release/supply',    authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), releaseAdminSupply);
router.post('/:roomId/release/item',      authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), releaseGenItem);
router.post('/:roomId/release',           authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), releaseInStockroom);

// GET & POST ------------------------------------------------------------------------------
router.get('/:roomId/qr/apparel/batch/:inventoryId',      authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getApparelBatchQr);
router.get('/:roomId/qr/admin-supply/batch/:inventoryId', authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getAdminSupplyBatchQr);
router.get('/:roomId/qr/general-item/batch/:inventoryId', authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getGenItemBatchQr);

router.get('/:roomId/qr/apparel/unit/:unitId',            authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getApparelUnitQr);
router.get('/:roomId/qr/admin-supply/unit/:unitId',       authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getAdminSupplyUnitQr);

// GET -------------------------------------------------------------------------------------
router.get('/',         authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getRooms);
router.get('/:roomId',  authorize(), getRoomById);
// Apparel
router.get('/:roomId/receive-apparels',   authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getReceiveApparels);
router.get('/:roomId/apparels',           authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getApparelUnits);
router.get('/:roomId/apparel-inventory',  authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getApparelInventory);
router.get('/:roomId/release-apparels',   authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getReleaseApparels);
// Admin Supply
router.get('/:roomId/receive-supply',     authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getReceiveAdminSupply);
router.get('/:roomId/supply',             authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getAdminSupplyUnits);
router.get('/:roomId/supply-inventory',   authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getAdminSupplyInventory);
router.get('/:roomId/release-supply',     authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getReleasedBatchAdminSupply);
// General Items
router.get('/:roomId/receive-items',      authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getReceiveGenItem);
router.get('/:roomId/items',              authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getGenItemUnits);
router.get('/:roomId/items-inventory',    authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getGenItemInventory);
router.get('/:roomId/release-items',      authorize([Role.SuperAdmin, Role.Admin, Role.StockroomAdmin]), getReleasedGenItems);

// PUT -------------------------------------------------------------------------------------
router.put('/:roomId',  authorize(Role.SuperAdmin, Role.Admin),  updateRoomSchema, updateRoom);

function resolveQrFilePath(result) {
  if (!result) return null;
  if (result.absolutePath && fs.existsSync(result.absolutePath)) return path.resolve(result.absolutePath);

  // fallback: try uploads/qrcodes/<filename>
  const projectRoot = path.join(__dirname, '../uploads');
  const try1 = path.join(projectRoot, 'uploads', 'qrcodes', result.filename || '');
  if (fs.existsSync(try1)) return try1;

  // fallback: try uploads/<filename>
  const try2 = path.join(projectRoot, 'uploads', result.filename || '');
  if (fs.existsSync(try2)) return try2;

  return null;
}

module.exports = router;

// Schema's part
function createRoomschema(req, res, next) {
  const schema = Joi.object({
      roomName: Joi.string().required().min(1).max(30),
      roomFloor: Joi.string().required().min(1).max(5),
      roomType: Joi.string().valid('stockroom','subStockroom','office','classroom', 'openarea').required(),
      stockroomType: Joi.string().valid('apparel','supply','general').allow(null).optional(),
      roomInCharge: Joi.number().integer().min(0)
  });
  validateRequest(req, next, schema);
}
function updateRoomSchema(req, res, next) {
  const schema = Joi.object({
    roomName: Joi.string().min(1).max(30).empty(),
    roomFloor: Joi.string().min(1).max(5).empty(),
    roomType: Joi.string().valid('stockroom','subStockroom','office','classroom', 'openarea').empty(''),
    stockroomType: Joi.string().valid('apparel','supply','general').allow(null).empty(),
    roomInCharge: Joi.number().integer().min(0).empty()
  });
  validateRequest(req, next, schema);
}
function receiveApparelSchema(req, res, next) {
  const paramsSchema = Joi.object({
    roomId: Joi.number().integer().min(1).required()
  });

  const bodySchema = Joi.object({
    apparelName:      Joi.string().trim().min(1).max(200).required(),
    apparelLevel:     Joi.string().trim().max(50).allow('pre', 'elem', '7', '8', '9', '10', 'sh', 'it', 'hs', 'educ', 'teachers').required(),
    apparelType:      Joi.string().trim().max(50).allow('uniform', 'pe').required(),
    apparelFor:       Joi.string().trim().max(50).allow('boys', 'girls').required(),
    apparelSize:      Joi.string().trim().max(50).allow(
                        '2', '4', '6', '8', '10', 
                        '12', '14', '16', '18', '20', 
                        'xs', 's', 'm', 'l', 'xl', 
                        '2xl', '3xl').required(),
    apparelQuantity:  Joi.number().integer().min(1).required(),

    receivedFrom:     Joi.string().trim().min(1).max(200).required(),
    receivedBy:       Joi.number().integer().min(1).required(),
    
    notes:            Joi.string().trim().allow('', null).optional()
  });

  // validate params first
  const { error: paramsErr } = paramsSchema.validate(req.params);
  if (paramsErr) return next(paramsErr);

  // validate body
  validateRequest(req, next, bodySchema);
}
function receiveAdminSupplySchema(req, res, next) {
  const paramsSchema = Joi.object({
    roomId: Joi.number().integer().min(1).required()
  });

  const bodySchema = Joi.object({
    supplyName:     Joi.string().trim().min(1).max(200).required(),
    supplyQuantity: Joi.number().integer().min(1).required(),
    supplyMeasure:  Joi.string().trim().max(50).allow(
                      'pc', 'box', 'bottle', 'pack', 'ream', 
                      'meter', 'roll', 'gallon', 'unit', 'educ', 
                      'teachers').required(),
    receivedFrom:   Joi.string().trim().min(1).max(200).required(),
    receivedBy:     Joi.number().integer().min(1).required(),

    notes:          Joi.string().trim().allow('', null).optional()
  });

  const { error: paramsErr } = paramsSchema.validate(req.params);
  if (paramsErr) return next(paramsErr);

  validateRequest(req, next, bodySchema);
}
function receiveGenItemSchema(req, res, next) {
  const paramsSchema = Joi.object({
    roomId: Joi.number().integer().min(1).required()
  });

  const bodySchema = Joi.object({
    genItemName:      Joi.string().trim().min(1).max(200).required(),
    genItemSize:      Joi.string().trim().max(50).allow('', null).optional(),
    genItemQuantity:  Joi.number().integer().min(1).required(),
    genItemType:      Joi.string().lowercase().valid('it','maintenance','unknownType').required(),

    receivedFrom:     Joi.string().trim().min(1).max(200).required(),
    receivedBy:       Joi.number().integer().min(1).required(),
    
    notes:            Joi.string().trim().allow('', null).optional()
  });

  // validate params first
  const { error: paramsErr } = paramsSchema.validate(req.params);
  if (paramsErr) return next(paramsErr);

  // validate body
  validateRequest(req, next, bodySchema);
}

// Management part
function createRoom(req, res, next) {
  roomService.createRoomHandler(req.body)
      .then(() => res.json({ message: 'Room created' }))
      .catch(next);
}
function getRooms(req, res, next) {
  roomService.getRoomsHandler()
      .then(room => res.json(room))
      .catch(next);
}
function getRoomById(req, res, next) {
  roomService.getRoomByIdHandler(req.params.roomId)
      .then(rooms => res.json(rooms))
      .catch(next);
}
async function updateRoom(req, res, next) {
  try {
    const updated = await roomService.updateRoomHandler(req.params.roomId, req.body);
    res.json(updated);
  } catch (err) {
    next(err);
  }
}

// Receive part
async function receiveApparel(req, res, next) {
  try {
    const roomId = parseInt(req.params.roomId, 10);
    const result = await roomService.receiveApparelInRoomHandler(roomId, req.body);
    res.status(201).json(result);
  } catch (err) { next(err); }
}
async function receiveAdminSupply(req, res, next) {
  try {
    const roomId = parseInt(req.params.roomId, 10);
    const result = await roomService.receiveAdminSupplyInRoomHandler(roomId, req.body);
    res.status(201).json(result);
  } catch (err) { next(err); }
}
async function receiveGenItem(req, res, next) {
  try {
    const roomId = parseInt(req.params.roomId, 10);
    const result = await roomService.receiveGenItemInRoomHandler(roomId, req.body);
    res.status(201).json(result);
  } catch (err) { next(err); }
}

// Release part
async function releaseInStockroom(req, res, next) {
  try {
    const roomId = parseInt(req.params.roomId, 10);
    // normalize fields so room.service gets the expected names
    if (req.body.releaseQuantity != null && req.body.releaseApparelQuantity == null) {
      req.body.releaseApparelQuantity = req.body.releaseQuantity;
    }
    if (req.body.claimedBy == null) {
      req.body.claimedBy = req.user?.id ? String(req.user.id) : '';
    }
    // support both claimedBy / releasedBy fields already present in your release schema
    const result = await roomService.releaseInStockroomHandler(roomId, req.body);
    res.status(201).json(result);
  } catch (err) { next(err); }
}
async function releaseApparel(req, res, next) {
  try {
    const roomId = parseInt(req.params.roomId, 10);

    // Normalize same as releaseInStockroom: accept releaseQuantity alias
    if (req.body.releaseQuantity != null && req.body.releaseApparelQuantity == null) {
      req.body.releaseApparelQuantity = req.body.releaseQuantity;
    }

    // Provide defaults for claimedBy/releasedBy so DB non-null constraints don't fail
    if (req.body.claimedBy == null) {
      req.body.claimedBy = req.user?.id ? String(req.user.id) : '';
    }
    if (req.body.releasedBy == null) {
      req.body.releasedBy = req.user?.id ? String(req.user.id) : '';
    }

    const result = await roomService.releaseApparelInRoomHandler(roomId, req.body);
    res.status(201).json(result);
  } catch (err) {
    next(err);
  }
}
async function releaseAdminSupply(req, res, next) {
  try {
    const roomId = parseInt(req.params.roomId, 10);
    const result = await roomService.releaseAdminSupplyInRoomHandler(roomId, req.body);
    res.status(201).json(result);
  } catch (err) { next(err); }
}
async function releaseGenItem(req, res, next) {
  try {
    const roomId = parseInt(req.params.roomId, 10);
    const result = await roomService.releaseGenItemInRoomHandler(roomId, req.body);
    res.status(201).json(result);
  } catch (err) { next(err); }
}


// Get Received part
function getReceiveApparels(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getReceiveApparelsByRoomHandler(roomId)
    .then(batches => res.json(batches))
    .catch(next);
}
function getApparelUnits(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getApparelUnitsByRoomHandler(roomId)
    .then(units => res.json(units))
    .catch(next);
}
function getApparelInventory(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getApparelInventoryByRoomHandler(roomId)
    .then(inventory => res.json(inventory))
    .catch(next);
}

function getReceiveAdminSupply(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getReceiveAdminSupplyByRoomHandler(roomId)
    .then(batches => res.json(batches))
    .catch(next);
}
function getAdminSupplyUnits(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getAdminSupplyUnitsByRoomHandler(roomId)
    .then(units => res.json(units))
    .catch(next);
}
function getAdminSupplyInventory(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getAdminSupplyInventoryByRoomHandler(roomId)
    .then(inventory => res.json(inventory))
    .catch(next);
}

function getReceiveGenItem(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getReceiveGenItemByRoomHandler(roomId)
    .then(batches => res.json(batches))
    .catch(next);
}
function getGenItemUnits(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getGenItemUnitsByRoomHandler(roomId)
    .then(units => res.json(units))
    .catch(next);
}
function getGenItemInventory(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getGenItemInventoryByRoomHandler(roomId)
    .then(inventory => res.json(inventory))
    .catch(next);
}

// Get Relesed Apparels part
function getReleaseApparels(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getReleaseApparelsByRoomHandler(roomId)
    .then(batches => res.json(batches))
    .catch(next);
}
function getReleasedBatchAdminSupply(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getReleasedBatchAdminSupplyByRoomHandler(roomId)
    .then(batches => res.json(batches))
    .catch(next);
}
function getReleasedGenItems(req, res, next) {
  const roomId = parseInt(req.params.roomId, 10);
  roomService.getReleasedGenItemByRoomHandler(roomId)
    .then(batches => res.json(batches))
    .catch(next);
}

// Generate and Get QR Code part
async function getApparelBatchQr(req, res, next) {
  try {
    const roomId = req.params.roomId;
    const inventoryId = req.params.inventoryId;

    // service will generate if missing (idempotent)
    const result = await roomService.generateApparelBatchForRoom(roomId, inventoryId);

    const absolute = resolveQrFilePath(result);
    if (!absolute) return res.status(404).json({ message: 'QR file not found' });

    // Always return the PNG image
    return res.type('png').sendFile(absolute);
  } catch (err) {
    if (err && err.status && err.message)
      return res.status(err.status).json({ message: err.message });
    next(err);
  }
}
async function getAdminSupplyBatchQr(req, res, next) {
  try {
    const roomId = req.params.roomId;
    const inventoryId = req.params.inventoryId;

    // service will generate if missing (idempotent)
    const result = await roomService.generateAdminSupplyBatchForRoom(roomId, inventoryId);

    const absolute = resolveQrFilePath(result);
    if (!absolute) return res.status(404).json({ message: 'QR file not found' });

    // Always return the PNG image
    return res.type('png').sendFile(absolute);
  } catch (err) {
    if (err && err.status && err.message)
      return res.status(err.status).json({ message: err.message });
    next(err);
  }
}
async function getGenItemBatchQr(req, res, next) {
  try {
    const roomId = req.params.roomId;
    const inventoryId = req.params.inventoryId;

    // service will generate if missing (idempotent)
    const result = await roomService.generateGenItemBatchForRoom(roomId, inventoryId);

    const absolute = resolveQrFilePath(result);
    if (!absolute) return res.status(404).json({ message: 'QR file not found' });

    // Always return the PNG image
    return res.type('png').sendFile(absolute);
  } catch (err) {
    if (err && err.status && err.message)
      return res.status(err.status).json({ message: err.message });
    next(err);
  }
}

async function getApparelUnitQr(req, res, next) {
  try {
    const roomId = req.params.roomId;
    const unitId = req.params.unitId;

    const result = await roomService.generateApparelUnitForRoom(roomId, unitId);

    const absolute = resolveQrFilePath(result);
    if (!absolute) return res.status(404).json({ message: 'QR file not found' });

    return res.type('png').sendFile(absolute);
  } catch (err) {
    if (err && err.status && err.message)
      return res.status(err.status).json({ message: err.message });
    next(err);
  }
}
async function getAdminSupplyUnitQr(req, res, next) {
  try {
    const roomId = req.params.roomId;
    const unitId = req.params.unitId;

    const result = await roomService.generateAdminSupplyUnitForRoom(roomId, unitId);

    const absolute = resolveQrFilePath(result);
    if (!absolute) return res.status(404).json({ message: 'QR file not found' });

    return res.type('png').sendFile(absolute);
  } catch (err) {
    if (err && err.status && err.message)
      return res.status(err.status).json({ message: err.message });
    next(err);
  }
}

================================================================================
File: _controllers\transfer.controller.js
Size: 3.19 kB
================================================================================

// _controllers/transfer.controller.js
const express = require('express');
const router  = express.Router();
const Joi     = require('joi');

const transferService = require('_services/transfer.service');
const validateRequest = require('_middlewares/validate-request');
const authorize       = require('_middlewares/authorize');
const Role            = require('_helpers/role');

router.post('/', authorize(Role.SuperAdmin, Role.Admin, Role.StockroomAdmin, Role.Teacher), createSchema, createTransfer);

router.get('/',     authorize(Role.SuperAdmin, Role.Admin, Role.StockroomAdmin, Role.Teacher), listTransfers);
router.get('/:id',  authorize(Role.SuperAdmin, Role.Admin, Role.StockroomAdmin, Role.Teacher), getById);

router.post('/:id/accept',        authorize(Role.SuperAdmin, Role.Admin, Role.StockroomAdmin, Role.Teacher), acceptTransfer);
router.post('/:id/return',        authorize(Role.SuperAdmin, Role.Admin, Role.StockroomAdmin, Role.Teacher), returnTransfer);
router.post('/:id/accept-return', authorize(Role.SuperAdmin, Role.Admin, Role.StockroomAdmin, Role.Teacher), acceptReturned);

module.exports = router;

// Schemas
function createSchema(req, res, next) {
  const schema = Joi.object({
    fromRoomId: Joi.number().integer().required(),
    toRoomId: Joi.number().integer().required(),
    itemType: Joi.string().valid('apparel','supply','genItem').required(),
    itemId: Joi.number().integer().required(),
    quantity: Joi.number().integer().min(1).required(),
    note: Joi.string().max(500).optional()
  });
  validateRequest(req, next, schema);
}

// Handlers
async function createTransfer(req, res, next) {
  try {
    const payload = req.body;
    payload.createdBy = req.user.accountId;
    const created = await transferService.createTransfer(payload);
    res.status(201).json({ success: true, data: created });
  } catch (err) { next(err); }
}
async function listTransfers(req, res, next) {
  try {
    const where = {};
    if (req.query.status) where.status = req.query.status;
    const rows = await transferService.listTransfers({ where });
    res.json({ success: true, data: rows });
  } catch (err) { next(err); }
}
async function getById(req, res, next) {
  try {
    const tr = await transferService.getById(parseInt(req.params.id, 10));
    res.json({ success: true, data: tr });
  } catch (err) { next(err); }
}
async function acceptTransfer(req, res, next) {
  try {
    const id = parseInt(req.params.id, 10);
    const r = await transferService.acceptTransfer(id, req.user.accountId);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}
async function returnTransfer(req, res, next) {
  try {
    const id = parseInt(req.params.id, 10);
    const r = await transferService.returnTransfer(id, req.user.accountId);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}
async function acceptReturned(req, res, next) {
  try {
    const id = parseInt(req.params.id, 10);
    const r = await transferService.acceptReturned(id, req.user.accountId);
    res.json({ success: true, data: r });
  } catch (err) { next(err); }
}


================================================================================
File: _helpers\db-handler.js
Size: 8.66 kB
================================================================================

const config            = require('config.json');
const mysql             = require('mysql2/promise');
const { Sequelize }     = require('sequelize');

module.exports = db = {};

initialize();
async function initialize() { 
    const { host, port, user, password, database } = config.database;
    const connection = await mysql.createConnection({ host, port, user, password });
    await connection.query(`CREATE DATABASE IF NOT EXISTS \`${database}\`;`);
    
    await connection.end();

    const sequelize = new Sequelize(database, user, password, { host: 'localhost', dialect: 'mysql' });

// Initialize models and add them to the exported `db` object
db.Room             = require('../_models/room.model')(sequelize);
db.Account          = require('../_models/account.model')(sequelize);
db.ActivityLog      = require('../_models/activitylog.model')(sequelize);
db.RefreshToken     = require('../_models/refresh-token.model')(sequelize);

// Apparel models
db.Apparel            = require('../_models/apparel/apparel.model')(sequelize);
db.ReceiveApparel     = require('../_models/apparel/receiveApparel.model')(sequelize);
db.ReleaseApparel     = require('../_models/apparel/releaseApparel.model')(sequelize);
db.ApparelInventory   = require('../_models/apparel/apparelInventory.model')(sequelize);

// Admin Supply models
db.AdminSupply              = require('../_models/adminSupply/adminSupply.model')(sequelize);
db.ReceiveAdminSupply       = require('../_models/adminSupply/receiveAdminSupply.model')(sequelize);
db.ReleaseAdminSupply      = require('../_models/adminSupply/releaseAdminSupply.model')(sequelize);
db.AdminSupplyInventory     = require('../_models/adminSupply/adminSupplyInventory.model')(sequelize);

// Item models
db.GenItem            = require('../_models/genItem/genItem.model')(sequelize);
db.ReceiveGenItem     = require('../_models/genItem/receiveGenItem.model')(sequelize);
db.ReleaseGenItem     = require('../_models/genItem/releaseGenItem.model')(sequelize);
db.GenItemInventory   = require('../_models/genItem/genItemInventory.model')(sequelize);

// Qr code models
db.Qr = require('../_models/qr.model')(sequelize);

// Request models
db.StockRequest = require('../_models/request/stock.request.model')(sequelize);
db.ItemRequest  = require('../_models/request/item.request.model')(sequelize);

// Transfer models
db.Transfer = require('../_models/transfer.model')(sequelize);

dbAssociations();

    await sequelize.sync({ alter: true }); 
}  

function dbAssociations() {
  // ---------------- Account / Auth ----------------
  // Account -> RefreshToken : store JWT refresh tokens for an account (cascade delete)
  db.Account.hasMany(db.RefreshToken, { onDelete: 'CASCADE' });
  db.RefreshToken.belongsTo(db.Account);

  // ---------------- Account / Room ----------------
  // [Label] Account (roomInCharge) -> Room : which account is in charge of a room
  db.Account.hasMany(db.Room, { foreignKey: 'roomInCharge' });
  db.Room.belongsTo(db.Account, { foreignKey: 'roomInCharge' });

  // ---------- APPAREL / BATCH / ROOM associations ----------
  // ReceiveApparel -> Apparel (per-unit), keep alias 'apparel' (matches prior code)
  db.ReceiveApparel.hasMany(db.Apparel, { foreignKey: 'receiveApparelId' });
  db.Apparel.belongsTo(db.ReceiveApparel, { foreignKey: 'receiveApparelId' });

  // ReceiveApparel -> Room (batch belongs to room) and Room -> ReceiveApparel
  db.ReceiveApparel.belongsTo(db.Room, { foreignKey: 'roomId' });
  db.Room.hasMany(db.ReceiveApparel, { foreignKey: 'roomId' });

  // Apparel may optionally belong to a Room directly (if your model has roomId)
  // Keep these so code that queries by Apparel.roomId keeps working if the attribute exists.
  db.Apparel.belongsTo(db.Room, { foreignKey: 'roomId' });
  db.Room.hasMany(db.Apparel, { foreignKey: 'roomId' });

  // ApparelInventory (aggregate) belongs to Room and Room has many ApparelInventory rows
  db.Room.hasMany(db.ApparelInventory, { foreignKey: 'roomId' });
  db.ApparelInventory.belongsTo(db.Room, { foreignKey: 'roomId' });

  // ApparelInventory <-> ReleaseApparel
  db.ApparelInventory.hasMany(db.ReleaseApparel, { foreignKey: 'apparelInventoryId' });
  db.ReleaseApparel.belongsTo(db.ApparelInventory, { foreignKey: 'apparelInventoryId'  });

  // ApparelInventory -> Apparel (optional relation if your model uses apparelInventoryId)
  db.ApparelInventory.hasMany(db.Apparel, { foreignKey: 'apparelInventoryId' });
  db.Apparel.belongsTo(db.ApparelInventory, { foreignKey: 'apparelInventoryId' });

  // ---------- ADMIN SUPPLY associations ----------
  db.ReceiveAdminSupply.hasMany(db.AdminSupply, { foreignKey: 'receiveAdminSupplyId' });
  db.AdminSupply.belongsTo(db.ReceiveAdminSupply, { foreignKey: 'receiveAdminSupplyId' });

  db.Account.hasMany(db.ReceiveApparel, { foreignKey: 'accountId'});
  db.ReceiveApparel.belongsTo(db.Account, { foreignKey: 'accountId'});

  db.Account.hasMany(db.ReceiveAdminSupply, { foreignKey: 'accountId'});
  db.ReceiveAdminSupply.belongsTo(db.Account, { foreignKey: 'accountId'});

  db.Account.hasMany(db.ReceiveGenItem, { foreignKey: 'accountId'});
  db.ReceiveGenItem.belongsTo(db.Account, { foreignKey: 'accountId'});

  db.Account.hasMany(db.ReleaseApparel, { foreignKey: 'accountId'});
  db.ReleaseApparel.belongsTo(db.Account, { foreignKey: 'accountId'});

  db.ReleaseApparel.belongsTo(db.Room, { foreignKey: 'roomId' });
  db.Room.hasMany(db.ReleaseApparel, { foreignKey: 'roomId' });

  db.ReceiveGenItem.hasMany(db.GenItem, { foreignKey: 'receiveGenItemId' });
  db.GenItem.belongsTo(db.ReceiveGenItem, { foreignKey: 'receiveGenItemId' });

  db.AdminSupply.belongsTo(db.Room, { foreignKey: 'roomId' });
  db.Room.hasMany(db.AdminSupply, { foreignKey: 'roomId' });



  // ---------------- STOCK REQUEST associations ----------------
  // StockRequest -> Account (who requested)
  db.Account.hasMany(db.StockRequest, { foreignKey: 'acccountId' });
  db.StockRequest.belongsTo(db.Account, { foreignKey: 'acccountId' });

  // StockRequest -> Room (which room/stockroom requested it)
  db.Room.hasMany(db.StockRequest, { foreignKey: 'requesterRoomId' });
  db.StockRequest.belongsTo(db.Room, { foreignKey: 'requesterRoomId' });

  db.StockRequest.belongsTo(db.ApparelInventory, { foreignKey: 'itemId', constraints: false });
  db.ApparelInventory.hasMany(db.StockRequest, { foreignKey: 'itemId', constraints: false });

  db.StockRequest.belongsTo(db.AdminSupplyInventory, { foreignKey: 'itemId', constraints: false });
  db.AdminSupplyInventory.hasMany(db.StockRequest, { foreignKey: 'itemId', constraints: false });

  db.StockRequest.belongsTo(db.GenItemInventory, { foreignKey: 'itemId', constraints: false });
  db.GenItemInventory.hasMany(db.StockRequest, { foreignKey: 'itemId', constraints: false });

  // ---------- ITEM REQUEST associations ----------
  db.Account.hasMany(db.ItemRequest, { foreignKey: 'accountId' });
  db.ItemRequest.belongsTo(db.Account, { foreignKey: 'accountId' });

  db.Room.hasMany(db.ItemRequest, { foreignKey: 'requesterRoomId' });
  db.ItemRequest.belongsTo(db.Room, { foreignKey: 'requesterRoomId' });

  // Polymorphic-ish itemId (no FK constraints since itemId may map to different tables)
  db.ItemRequest.belongsTo(db.ApparelInventory, { foreignKey: 'itemId', constraints: false });
  db.ApparelInventory.hasMany(db.ItemRequest, { foreignKey: 'itemId', constraints: false });

  db.ItemRequest.belongsTo(db.AdminSupplyInventory, { foreignKey: 'itemId', constraints: false });
  db.AdminSupplyInventory.hasMany(db.ItemRequest, { foreignKey: 'itemId', constraints: false });

  db.ItemRequest.belongsTo(db.GenItemInventory, { foreignKey: 'itemId', constraints: false });
  db.GenItemInventory.hasMany(db.ItemRequest, { foreignKey: 'itemId', constraints: false });

  db.Transfer.belongsTo(db.Account, { foreignKey: 'createdBy' });
  db.Transfer.belongsTo(db.Account, { foreignKey: 'acceptedBy' });    // who accepted transfer
  db.Transfer.belongsTo(db.Account, { foreignKey: 'returningBy' });   // who initiated return

  // Transfer <> Room (rooms)
  db.Transfer.belongsTo(db.Room, { foreignKey: 'fromRoomId' });
  db.Transfer.belongsTo(db.Room, { foreignKey: 'toRoomId' });

  db.Transfer.belongsTo(db.ApparelInventory, { foreignKey: 'itemId', constraints: false });
  db.Transfer.belongsTo(db.AdminSupplyInventory, { foreignKey: 'itemId', constraints: false });
  db.Transfer.belongsTo(db.GenItemInventory, { foreignKey: 'itemId', constraints: false });
}

================================================================================
File: _helpers\role.js
Size: 156 B
================================================================================

module.exports = {
    SuperAdmin: 'superAdmin',
    Admin: 'admin',
    StockroomAdmin: 'stockroomAdmin',
    Teacher: 'teacher',
    User: 'user',
}

================================================================================
File: _helpers\send-email.js
Size: 1.14 kB
================================================================================

const nodemailer    = require('nodemailer');
const config        = require('config.json');

module.exports = sendEmail;

async function sendEmail({ to, subject, html, from = config.emailFrom }) {
    let transporter;
    if (config.smtpOptions && config.smtpOptions.auth && config.smtpOptions.auth.user && config.smtpOptions.auth.pass) {
      transporter = nodemailer.createTransport(config.smtpOptions);
    } else {
      const testAccount = await nodemailer.createTestAccount();
      transporter = nodemailer.createTransport({
        host: 'smtp.ethereal.email',
        port: 587,
        secure: false,
        auth: {
          user: testAccount.user,
          pass: testAccount.pass,
        },
      });
      console.log('Using dynamic Ethereal test account. Preview emails at URL logged below.');
    }
  
    const info = await transporter.sendMail({ from, to, subject, html });
  
    // If this is a test transport (Ethereal), log the preview URL
    const previewUrl = nodemailer.getTestMessageUrl(info);
    if (previewUrl) console.log('Preview URL: %s', previewUrl);
  
    return info;
  }

================================================================================
File: _helpers\swagger.js
Size: 369 B
================================================================================

const express               = require('express');
const router                = express.Router();
const swaggerUi             = require('swagger-ui-express');
const YAML                  = require('yamljs');
const swaggerDocument       = YAML.load('./swagger.yaml');

router.use('/', swaggerUi.serve, swaggerUi.setup(swaggerDocument));

module.exports = router;

================================================================================
File: _middlewares\authorize.js
Size: 1.29 kB
================================================================================

const { expressjwt: jwt }   = require('express-jwt');
const { secret }            = require('config.json');
const db                    = require('_helpers/db-handler');
const Role                  = require('_helpers/role');

module.exports = authorize;

function authorize(roles = []) {
    if (typeof roles === 'string') {
        roles = [roles];
    }

    return [
        jwt({ secret, algorithms: ['HS256'], requestProperty: 'auth' }),

        async (req, res, next) => {
            try {
                const account = await db.Account.findByPk(req.auth.accountId);
                if (!account) {
                    return res.status(401).json({ message: 'Account no longer exists' });
                }

                if (roles.length && !roles.includes(account.role)) {
                    return res.status(403).json({ message: 'Forbidden: insufficient permissions' });
                }

                req.user = { accountId: account.accountId, email: account.email, role: account.role };
                next();
            } catch (error) {
                console.error('Authorization error:', error);
                res.status(500).json({ message: 'Internal server error during authorization' });
            }
        }
    ];
}

================================================================================
File: _middlewares\error-handler.js
Size: 561 B
================================================================================

//main
module.exports = errorHandler;

function errorHandler(err, req, res, next) {
    switch (true) {
        case typeof err === 'string':
            const is404 = err.toLowerCase().endsWith('not found');
            const statusCode = is404 ? 404 : 400;
            return res.status(statusCode).json({ message: err });
        case err.name === 'UnauthorizedError':
            return res.status(401).json({ message: 'Unauthorized error-handler' });
        default:
            return res.status(500).json({ message: err.message });
    }
}

================================================================================
File: _middlewares\validate-request.js
Size: 436 B
================================================================================

module.exports = validateRequest;

function validateRequest(req, next, schema) {
    const options = {
        abortEarly: false,
        allowUnknown: true,
        stripUnknown: true
    };
    const { error, value } = schema.validate(req.body, options);
    if (error) {
        next(`Validation error: ${error.details.map(x => x.message).join(', ')}`);
    } else {
        req.body = value;
        next();
    }
}


================================================================================
File: _models\account.model.js
Size: 1.81 kB
================================================================================

const { DataTypes } = require('sequelize');

module.exports = model;

function model(sequelize) {
    const attributes = {
        accountId:          { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },

        email:              { type: DataTypes.STRING,   allowNull: false }, 
        passwordHash:       { type: DataTypes.STRING,   allowNull: false }, 
        title:              { type: DataTypes.STRING,   allowNull: false }, 
        firstName:          { type: DataTypes.STRING,   allowNull: false }, 
        lastName:           { type: DataTypes.STRING,   allowNull: false },
        role:               { type: DataTypes.STRING,   allowNull: true }, 
        status:             { type: DataTypes.ENUM(
                                'active', 'deactivated'
                            ), allowNull: false, defaultValue: 'active'},

        verificationToken:  { type: DataTypes.STRING },
        verified:           { type: DataTypes.DATE },
        resetToken:         { type: DataTypes.STRING },
        resetTokenExpires:  { type: DataTypes.DATE },
        passwordReset:      { type: DataTypes.DATE},
        created:            { type: DataTypes.DATE,     allowNull: false, defaultValue: DataTypes.NOW }, 
        updated:            { type: DataTypes.DATE },
        isVerified:         { type: DataTypes.VIRTUAL,
                                get() { return !!(this.verified || this.passwordReset); }
                            },
    };

    const options = { 
        timestamps: false,
        defaultScope: {
            attributes: {exclude: ['passwordHash'] }
        },
        scopes: {
            withHash: { attributes: {}, }
        }
    };

    return sequelize.define('Account', attributes, options);
    
}

================================================================================
File: _models\activitylog.model.js
Size: 673 B
================================================================================

const { DataTypes } = require('sequelize');

module.exports = model;

function model(sequelize) {
    const attributes = {
        activityLogId:  { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        accountId:      { type: DataTypes.INTEGER,  allowNull: false },
        actionType:     { type: DataTypes.STRING,   allowNull: false },
        actionDetails:  { type: DataTypes.TEXT,     allowNull: true },
        timestamp:      { type: DataTypes.DATE,     defaultValue: DataTypes.NOW },
    };

    const options = {
        timestamps: false 
        
    };

    return sequelize.define('ActivityLog', attributes, options);
}

================================================================================
File: _models\adminSupply\adminSupply.model.js
Size: 609 B
================================================================================

const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {

    const attributes = {
        adminSupplyId:          { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:                 { type: DataTypes.INTEGER,  allowNull: false },
        receiveAdminSupplyId:   { type: DataTypes.INTEGER,  allowNull: false },
        status:                 { type: DataTypes.STRING,   allowNull: false, defaultValue: 'in_stock' }
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('AdminSupply', attributes);
};

================================================================================
File: _models\adminSupply\adminSupplyInventory.model.js
Size: 1.52 kB
================================================================================

/* 
    - this model will be the innventory of admin supply.
    - it will store all the received bathes of admin supply items but if the received item is the same to the existing item, only the total quantity will be change
    - ex.: if db.ReceiveAdminSupply received 5 quantities of one specific item and received again that kind of item but only 3 quantities, 
        the total quantity of that item will change by adding the new quantity into the existing.
    - this model will not store duplicate items but the total quantity will update. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
    adminSupplyInventoryId: { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
    roomId:                 { type: DataTypes.INTEGER,  allowNull: false },
    supplyName:             { type: DataTypes.STRING,   allowNull: false },
    supplyMeasure:          { type: DataTypes.ENUM(
                                'pc', 'box', 'bottle', 'pack', 'ream', 
                                'meter', 'roll', 'gallon', 'unit', 'educ', 
                                'teachers'
                                ), 
                                allowNull: false 
                            },
    totalQuantity:          { type: DataTypes.INTEGER, allowNull: false, defaultValue: 0 },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('AdminSupplyInventory', attributes);
};

================================================================================
File: _models\adminSupply\receiveAdminSupply.model.js
Size: 1.31 kB
================================================================================

const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
        receiveAdminSupplyId:   { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:                 { type: DataTypes.INTEGER,  allowNull: false },
        receivedFrom:           { type: DataTypes.STRING,   allowNull: false },
        receivedBy:             { type: DataTypes.INTEGER,  allowNull: false },
        supplyName:             { type: DataTypes.STRING,   allowNull: false },
        supplyQuantity:         { type: DataTypes.INTEGER,  allowNull: false },
        supplyMeasure:          { type: DataTypes.ENUM(
                                    'pc', 'box', 'bottle', 'pack', 'ream', 
                                    'meter', 'roll', 'gallon', 'unit', 'educ', 
                                    'teachers'
                                    ), 
                                    allowNull: false 
                                },
        receivedAt:             { type: DataTypes.DATE, allowNull: false, defaultValue: DataTypes.NOW },
        updated:                { type: DataTypes.DATE },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('ReceiveAdminSupply', attributes);
};

================================================================================
File: _models\adminSupply\releaseAdminSupply.model.js
Size: 1.08 kB
================================================================================

/* 
    - this model will store all the released of apprels.
    - its like as receave but this one is for release feature.
    - this model will store 1 row per released item. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
        releaseAdminSupplyId:       { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:                     { type: DataTypes.INTEGER,  allowNull: false },
        adminSupplyInventoryId:     { type: DataTypes.INTEGER,  allowNull:  false },
        releasedBy:                 { type: DataTypes.STRING,   allowNull:  false },
        claimedBy:                  { type: DataTypes.STRING,   allowNull:  false },
        releaseAdminSupplyQuantity: { type: DataTypes.INTEGER,  allowNull:  false },
        releasedAt:                 { type: DataTypes.DATE,     allowNull:  false, defaultValue: DataTypes.NOW },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('ReleaseAdminSupply', attributes);
};

================================================================================
File: _models\apparel\apparel.model.js
Size: 972 B
================================================================================

/* 
    - this model will store all the received bathes of apprel items into rows
    - ex.: if db.ReceiveApprel received 5 quantitys of one specific item and will store as one row.
    - this model will store the 5 quantities into 5 rows. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {

    const attributes = {
        apparelId:          { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:             { type: DataTypes.INTEGER,  allowNull: false },
        receiveApparelId:   { type: DataTypes.INTEGER,  allowNull: false },
        status:      { type: DataTypes.ENUM(
                                'released','damaged',
                                'lost','good'
                                ), defaultValue: 'good'
                            }
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('Apparel', attributes);
};

================================================================================
File: _models\apparel\apparelInventory.model.js
Size: 2.2 kB
================================================================================

/* 
    - this model will be the innventory of apparel.
    - it will store all the received bathes of apprel items but if the received item is the same to the existing item, only the total quantity will be change
    - ex.: if db.ReceiveApprel received 5 quantities of one specific item and received again that kind of item but only 3 quantities, 
        the total quantity of that item will change by adding the new quantity into the existing.
    - this model will not store duplicate items but the total quantity will update. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
    apparelInventoryId: { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
    roomId:             { type: DataTypes.INTEGER,  allowNull: false },
    apparelName:        { type: DataTypes.STRING,   allowNull: false },
    apparelLevel:       { type: DataTypes.ENUM(
                            'pre','elem',
                            '7','8','9','10',
                            'sh','it','hs','educ',
                            'teachers'
                            ), 
                            allowNull: false },
    apparelType:        { type: DataTypes.ENUM('uniform','pe'), allowNull: false },
    apparelFor:         { type: DataTypes.ENUM('boys','girls'), allowNull: false },
    apparelSize:        { type: DataTypes.ENUM(
                            '2', '4', '6', '8', '10', 
                            '12', '14', '16', '18', '20', 
                            'xs', 's', 'm', 'l', 'xl', 
                            '2xl', '3xl'
                            ), 
                            allowNull: false  
                        },
    totalQuantity:      { type: DataTypes.INTEGER, allowNull: false, defaultValue: 0 },
    status:             { type: DataTypes.ENUM('out_of_stock','low_stock','high_stock'), allowNull: false, defaultValue: 'out_of_stock' },
    qrStatus:            { type: DataTypes.BOOLEAN, allowNull: false, defaultValue: false }
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('ApparelInventory', attributes);
};

================================================================================
File: _models\apparel\receiveApparel.model.js
Size: 2.37 kB
================================================================================

/* 
    - this model will store all the received bathes of apprel one row per batch.
    - ex.: if db.ReceiveApprel received 5 quantitys of one specific item and will store as one row, 
    - this model will store the 5 quantities into 1 row. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
        receiveApparelId:   { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:             { type: DataTypes.INTEGER,  allowNull: false },
        receivedFrom:       { type: DataTypes.STRING,   allowNull: false },
        receivedBy:         { type: DataTypes.INTEGER,  allowNull: false },
        apparelName:        { type: DataTypes.STRING,   allowNull: false },
        apparelLevel:       { type: DataTypes.ENUM(
                                'pre', 'elem', 
                                '7', '8', '9', '10', 
                                'sh', 'it', 'hs', 'educ', 
                                'teachers'
                                ), 
                                allowNull: false 
                            },
        apparelType:        { type: DataTypes.ENUM(
                                'uniform', 'pe'
                                ), 
                                allowNull: false 
                            },
        apparelFor:         { type: DataTypes.ENUM(
                                'boys', 'girls'
                                ), 
                                allowNull: false 
                            },
        apparelSize:        { type: DataTypes.ENUM(
                                '2', '4', '6', '8', '10', 
                                '12', '14', '16', '18', '20', 
                                'xs', 's', 'm', 'l', 'xl', 
                                '2xl', '3xl'
                                ), 
                                allowNull: false  
                            },
        apparelQuantity:    { type: DataTypes.INTEGER,  allowNull: false },
        receivedAt:         { type: DataTypes.DATE,     allowNull: false, defaultValue: DataTypes.NOW },
        updated:            { type: DataTypes.DATE },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('ReceiveApparel', attributes);
};

================================================================================
File: _models\apparel\releaseApparel.model.js
Size: 1.09 kB
================================================================================

/* 
    - this model will store all the released of apprels.
    - its like as receave but this one is for release feature.
    - this model will store 1 row per released item. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
        releaseApparelId:           { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:                     { type: DataTypes.INTEGER,  allowNull: false },
        apparelInventoryId:         { type: DataTypes.INTEGER,  allowNull:  false },
        releasedBy:                 { type: DataTypes.STRING,   allowNull:  false },
        claimedBy:                  { type: DataTypes.STRING,   allowNull:  false },
        releaseApparelQuantity:     { type: DataTypes.INTEGER,  allowNull:  false },
        releasedAt:                 { type: DataTypes.DATE,     allowNull:  false, defaultValue: DataTypes.NOW },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('ReleaseApparel', attributes, options);
};

================================================================================
File: _models\genItem\genItem.model.js
Size: 832 B
================================================================================

/* 
    - this model will store all the received bathes of apprel items into rows
    - ex.: if db.ReceiveApprel received 5 quantitys of one specific item and will store as one row.
    - this model will store the 5 quantities into 5 rows. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {

    const attributes = {
        genItemId:          { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:          { type: DataTypes.INTEGER,  allowNull: false },
        receiveGenItemId:   { type: DataTypes.INTEGER,  allowNull: false },
        status:          { type: DataTypes.STRING,   allowNull: false, defaultValue: 'in_stock' }
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('GenItem', attributes);
};

================================================================================
File: _models\genItem\genItemInventory.model.js
Size: 1.41 kB
================================================================================

/* 
    - this model will be the innventory of apparel.
    - it will store all the received bathes of apprel items but if the received item is the same to the existing item, only the total quantity will be change
    - ex.: if db.ReceiveApprel received 5 quantities of one specific item and received again that kind of item but only 3 quantities, 
        the total quantity of that item will change by adding the new quantity into the existing.
    - this model will not store duplicate items but the total quantity will update. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
    genItemInventoryId: { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
    roomId:             { type: DataTypes.INTEGER,  allowNull: false },
    genItemName:        { type: DataTypes.STRING,   allowNull: false },
    genItemSize:        { type: DataTypes.STRING,   allowNull: true },
    genItemType:        { type: DataTypes.ENUM(
                            'it', 'maintenance', 'unknownType'
                            ), 
                            allowNull: false 
                        },
    totalQuantity:      { type: DataTypes.INTEGER,  allowNull: false, defaultValue: 0 },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('GenItemInventory', attributes);
};

================================================================================
File: _models\genItem\receiveGenItem.model.js
Size: 1.45 kB
================================================================================

/* 
    - this model will store all the received bathes of apprel one row per batch.
    - ex.: if db.ReceiveApprel received 5 quantitys of one specific item and will store as one row, 
    - this model will store the 5 quantities into 1 row. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
        receiveGenItemId:   { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:             { type: DataTypes.INTEGER,  allowNull: false },
        receivedFrom:       { type: DataTypes.STRING,   allowNull: false },
        receivedBy:         { type: DataTypes.INTEGER,  allowNull: false },
        genItemName:        { type: DataTypes.STRING,   allowNull: false },
        genItemSize:        { type: DataTypes.STRING,   allowNull: true },
        genItemQuantity:    { type: DataTypes.INTEGER,  allowNull: false },
        genItemType:        { type: DataTypes.ENUM(
                                'it', 'maintenance', 'unknownType'
                                ), 
                                allowNull: false 
                            },
        receivedAt:         { type: DataTypes.DATE,     allowNull: false, defaultValue: DataTypes.NOW },
        updated:            { type: DataTypes.DATE },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('ReceiveGenItem', attributes);
};

================================================================================
File: _models\genItem\releaseGenItem.model.js
Size: 1.32 kB
================================================================================

/* 
    - this model will store all the released of apprels.
    - its like as receave but this one is for release feature.
    - this model will store 1 row per released item. 
*/
const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
        releaseGenItemId:       { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        roomId:                 { type: DataTypes.INTEGER,  allowNull: false },
        genItemInventoryId:     { type: DataTypes.INTEGER,  allowNull:  false },
        releasedBy:             { type: DataTypes.STRING,   allowNull:  false },
        claimedBy:              { type: DataTypes.STRING,   allowNull:  false },
        releaseItemQuantity:    { type: DataTypes.INTEGER,  allowNull:  false },
        genItemType:            { type: DataTypes.ENUM(
                                    'it', 'maintenance', 'unknownType'
                                    ), 
                                    allowNull: false 
                                },
        releasedAt:             { type: DataTypes.DATE,     allowNull:  false, defaultValue: DataTypes.NOW },
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('ReleaseGenItem', attributes, options);
};

================================================================================
File: _models\qr.model.js
Size: 723 B
================================================================================

const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const attributes = {
    qrId:         { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true }, 
    itemType:     { type: DataTypes.STRING,   allowNull: false },
    batchId:      { type: DataTypes.INTEGER,  allowNull: true },
    unitId:       { type: DataTypes.INTEGER,  allowNull: true },
    qrFilePath:   { type: DataTypes.TEXT,     allowNull: false },
    qrCodePath:   { type: DataTypes.STRING,   allowNull: true },
    createdAt:    { type: DataTypes.DATE,     defaultValue: DataTypes.NOW }
  };

  const options = {
    timestamps: false
  };

  return sequelize.define('Qr', attributes, options);
};


================================================================================
File: _models\refresh-token.model.js
Size: 1.23 kB
================================================================================

const { DataTypes } = require('sequelize');

module.exports = model;

function model(sequelize) {
    const attributes = {
        refreshTokenId:     { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
        token:              { type: DataTypes.STRING },
        expires:            { type: DataTypes.DATE },
        created:            { type: DataTypes.DATE,     allowNull: false, defaultValue: DataTypes.NOW }, 
        createdByIp:        { type: DataTypes.STRING },
        revoked:            { type: DataTypes.DATE },
        revokedByIp:        { type: DataTypes.STRING },
        replacedByToken:    { type: DataTypes.STRING }, 
        accountId:          { type: DataTypes.INTEGER,  allowNull: false },
        isExpired:          { type: DataTypes.VIRTUAL,
                                get() { return Date.now() >= this.expires; }
                            },
        isActive:           { type: DataTypes.VIRTUAL, 
                                get() { return !this.revoked && !this.isExpired; }
                            }
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('RefreshToken', attributes, options);
}

================================================================================
File: _models\request\item.request.model.js
Size: 1.18 kB
================================================================================

const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const attributes = {
    itemRequestId: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
    accountId:     { type: DataTypes.INTEGER, allowNull: false },
    requesterRoomId:{ type: DataTypes.INTEGER, allowNull: true },
    itemId:        { type: DataTypes.INTEGER, allowNull: true },
    itemType:      { type: DataTypes.ENUM('apparel','supply','genItem'), allowNull: false, defaultValue: 'apparel' },
    quantity:      { type: DataTypes.INTEGER, defaultValue: 1 },
    status:        {
      type: DataTypes.ENUM('pending','accepted','released','declined','out_of_stock','fulfilled'),
      defaultValue: 'pending'
    },
    note:          { type: DataTypes.STRING(500), allowNull: true },
    acceptedBy:    { type: DataTypes.INTEGER, allowNull: true },
    acceptedAt:    { type: DataTypes.DATE, allowNull: true },
    fulfilledBy:   { type: DataTypes.INTEGER, allowNull: true },
    fulfilledAt:   { type: DataTypes.DATE, allowNull: true }
  }

  const options = {
    timestamps: false
  };

  return sequelize.define('ItemRequest', attributes);
};

================================================================================
File: _models\request\stock.request.model.js
Size: 890 B
================================================================================

const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const attributes = {
    stockRequestId: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
    accountId: { type: DataTypes.INTEGER, allowNull: false },
    requesterRoomId: { type: DataTypes.INTEGER, allowNull: true },
    itemId: { type: DataTypes.INTEGER, allowNull: true },
    itemType: { type: DataTypes.ENUM('apparel','supply','genItem'), allowNull: false, defaultValue: 'apparel' },
    quantity: { type: DataTypes.INTEGER, defaultValue: 1 },
    status: { 
      type: DataTypes.ENUM('pending','approved','failed_request','disapproved','fulfilled'),
      defaultValue: 'pending'
    },
    note: { type: DataTypes.STRING(500), allowNull: true },
  };  

  const options = {
    timestamps: false
  };

  return sequelize.define('StockRequest', attributes);
};

================================================================================
File: _models\room.model.js
Size: 890 B
================================================================================

const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const attributes = {
    roomId:         { type: DataTypes.INTEGER,  primaryKey: true, autoIncrement: true },
    roomName:       { type: DataTypes.STRING,   allowNull: false },
    roomFloor:      { type: DataTypes.STRING,   allowNull: false },
    roomType:       { type: DataTypes.ENUM(
                        'stockroom', 'subStockroom', 
                        'office', 'classroom', 'openarea'
                        ), 
                      allowNull: false, defaultValue: 'classroom' },
    stockroomType:  { type: DataTypes.ENUM(
                        'apparel', 'supply', 'general'
                        ), 
                      allowNull: true },
    roomInCharge:   { type: DataTypes.INTEGER,  allowNull: false }
  };

  return sequelize.define('Room', attributes);
};

================================================================================
File: _models\transfer.model.js
Size: 1.29 kB
================================================================================

const { DataTypes } = require('sequelize');

module.exports = model;

function model(sequelize) {
    const attributes = {
        transferId:      { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
    fromRoomId:      { type: DataTypes.INTEGER, allowNull: false },
    toRoomId:        { type: DataTypes.INTEGER, allowNull: false },
    createdBy:       { type: DataTypes.INTEGER, allowNull: false },
    itemType:        { type: DataTypes.STRING, allowNull: false },
    itemId:          { type: DataTypes.INTEGER, allowNull: true },
    quantity:        { type: DataTypes.INTEGER, allowNull: false, defaultValue: 1 },

    status:          { type: DataTypes.STRING, allowNull: false, defaultValue: 'in_transfer' },
    acceptedBy:      { type: DataTypes.INTEGER, allowNull: true },
    acceptedAt:      { type: DataTypes.DATE, allowNull: true },

    returningBy:     { type: DataTypes.INTEGER, allowNull: true },
    returnedAt:      { type: DataTypes.DATE, allowNull: true },

    note:            { type: DataTypes.TEXT, allowNull: true },

    updatedAt:       { type: DataTypes.DATE, allowNull: true }
    };

    const options = { 
        timestamps: false
    };

    return sequelize.define('Transfer', attributes, options);
    
}

================================================================================
File: _services\account.service.js
Size: 15.55 kB
================================================================================

const config    = require('config.json'); 
const jwt       = require('jsonwebtoken'); 
const bcrypt    = require('bcryptjs'); 
const crypto    = require("crypto"); 
const { Op}     = require('sequelize');

const sendEmail   = require('_helpers/send-email'); 
const db          = require('_helpers/db-handler');
const Role        = require('_helpers/role');

module.exports = { 
    authenticate,
    refreshToken,
    revokeToken,
    register,
    verifyEmail,
    forgotPassword,
    validateResetToken,
    resetPassword, 
    getAll,
    getById,
    create,
    logActivity,
    getAccountActivities,
    getAllActivityLogs,
    update,
    delete: _delete,
};

async function authenticate({ email, password, ipAddress, browserInfo }) {
    const account = await db.Account.scope('withHash').findOne({ where: { email } });
  
    if (!account || !account.isVerified || !(await bcrypt.compare(password, account.passwordHash))) {
      throw 'Email or password is incorrect';
    }

    // if (!user.isActive) {
    //   return res.status(401).json({ message: 'Account is deactivated. Please contact an administrator.' });
    // }
  
    const jwtToken = generateJwtToken(account);
    const refreshToken = generateRefreshToken(account, ipAddress);
  
    await refreshToken.save();
  
    try {
      await logActivity(account.accountId, 'login', ipAddress, browserInfo);
    } catch (error) {
      console.error('Error logging activity:', error);
    }
  
    return {
      ...basicDetails(account),
      jwtToken,
      refreshToken: refreshToken.token
    };
}
async function logActivity(accountId, actionType, ipAddress, browserInfo, updateDetails = '') {
    try {
      // Create a new log entry in the 'activity_log' table
      await db.ActivityLog.create({
        accountId,
        actionType,
        actionDetails: `IP Address: ${ipAddress}, Browser Info: ${browserInfo}, Details: ${updateDetails}`,
        timestamp: new Date()
      });
  
      // Count the number of logs for the user
      const logCount = await db.ActivityLog.count({ where: { accountId } });
  
      if (logCount > 10) {
        // Find and delete the oldest logs
        const logsToDelete = await db.ActivityLog.findAll({
          where: { accountId },
          order: [['timestamp', 'ASC']],
          limit: logCount - 10
        });
  
        if (logsToDelete.length > 0) {
          const logIdsToDelete = logsToDelete.map(log => log.activityLogId);
  
          await db.ActivityLog.destroy({
            where: {
              activityLogId: {
                [Op.in]: logIdsToDelete
              }
            }
          });
          console.log(`Deleted ${logIdsToDelete.length} oldest log(s) for user ${accountId}.`);
        }
      }
    } catch (error) {
      console.error('Error logging activity:', error);
      throw error;
    }
}
async function getAllActivityLogs(filters = {}) {
  try {
      let whereClause = {};
      
      // Apply filters
      if (filters.actionType) {
          whereClause.actionType = { [Op.like]: `%${filters.actionType}%` };
      }
      
      if (filters.userId) {
          whereClause.accountId = filters.userId;
      }
      
      if (filters.startDate || filters.endDate) {
          const startDate = filters.startDate ? new Date(filters.startDate) : new Date(0);
          const endDate = filters.endDate ? new Date(filters.endDate) : new Date();
          whereClause.timestamp = { [Op.between]: [startDate, endDate] };
      }

      // Get all activity logs with user details
      const logs = await db.ActivityLog.findAll({
          where: whereClause,
          include: [{
              model: db.Account,
              attributes: ['email', 'firstName', 'lastName', 'role'],
              required: true
          }],
          order: [['timestamp', 'DESC']]
      });

      // Format the response
      return logs.map(log => {
          const formattedDate = new Intl.DateTimeFormat('en-US', {
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              hour12: true
          }).format(new Date(log.timestamp));

          return {
              activityLogId: log.activityLogId,
              userId: log.accountId,
              userEmail: log.Account.email,
              userRole: log.Account.role,
              userName: `${log.Account.firstName} ${log.Account.lastName}`,
              actionType: log.actionType,
              actionDetails: log.actionDetails,
              timestamp: formattedDate
          };
      });
  } catch (error) {
      console.error('Error retrieving all activity logs:', error);
      throw new Error('Error retrieving activity logs');
  }
}
async function getAccountActivities(accountId, filters = {}) {
  const account = await getAccount(accountId);
  if (!account) throw new Error('User not found');

  let whereClause = { accountId };

  // Apply optional filters such as action type and timestamp range
  if (filters.actionType) {
    whereClause.actionType = { [Op.like]: `%${filters.actionType}%` };
  }
  if (filters.startDate || filters.endDate) {
    const startDate = filters.startDate ? new Date(filters.startDate) : new Date(0);
    const endDate = filters.endDate ? new Date(filters.endDate) : new Date();
    whereClause.timestamp = { [Op.between]: [startDate, endDate] };
  }

  try {
    const activities = await db.ActivityLog.findAll({ where: whereClause });
    return activities.map(activity => {
      const formattedDate = new Intl.DateTimeFormat('en-US', {
          year: '2-digit',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          hour12: true
      }).format(new Date(activity.timestamp));

      return {
          activityLogId: activity.activityLogId,
          accountId: activity.accountId,
          actionType: activity.actionType,
          actionDetails: activity.actionDetails,
          timestamp: formattedDate
      };
  });
  } catch (error) {
    console.error('Error retrieving activities:', error);
    throw new Error('Error retrieving activities');
  }
}
async function refreshToken({ token, ipAddress }) { 
    const refreshToken = await getRefreshToken(token); 
    const account = await refreshToken.getAccount();

    const newRefreshToken = generateRefreshToken (account, ipAddress); 
    refreshToken.revoked = Date.now();
    refreshToken.revokedByIp = ipAddress;
    refreshToken.replacedByToken = newRefreshToken.token;
    await refreshToken.save();
    await newRefreshToken.save();
    
    const jwtToken = generateJwtToken(account);
    
    return {
        ...basicDetails (account),
        jwtToken,
        refreshToken: newRefreshToken.token
    };
}
async function revokeToken({ token, ipAddress }) { 
    const refreshToken = await getRefreshToken (token);
    
    refreshToken.revoked = Date.now();
    refreshToken.revokedByIp = ipAddress; 
    await refreshToken.save();
}
async function register(params, origin) {
    if (await db.Account.findOne({ where: { email: params.email } })) {
        return await sendAlreadyRegisteredEmail (params.email, origin);
    }
    
    const account = new db.Account (params);

    const isFirstAccount = (await db.Account.count()) === 0; 
    account.role = isFirstAccount? Role.SuperAdmin: Role.Admin; 
    account.verificationToken = randomTokenString();
    
    account.passwordHash = await hash (params.password);
    
    await account.save();
    await sendVerificationEmail (account, origin);
}
async function verifyEmail({token}) {
    const account = await db.Account.findOne({ where: { verificationToken: token} });

    if (!account) throw 'Verification failed';

    account.verified = Date.now();
    account.verificationToken = null; 
    await account.save();
}
async function forgotPassword({ email }, origin) {
    const account = await db.Account.findOne({ where: { email } });

    if (!account) return;
    
    account.resetToken = randomTokenString();
    account.resetTokenExpires= new Date(Date.now() + 24*60*60*1000);
    await account.save();

    await sendPasswordResetEmail (account, origin);
}
async function validateResetToken({token}) { 
    const account = await db.Account.findOne({ 
        where: {
            resetToken: token,
            resetTokenExpires: { [Op.gt]: Date.now() }
        }
    });

    if (!account) throw 'Invalid token';

    return account;
}
async function resetPassword({ token, password }, ipAddress, browserInfo) {
    const account = await validateResetToken({ token });
  
     // Add password validation if needed
     if (password.length < 6) {
      throw 'Password must be at least 6 characters';
  }
    account.passwordHash = await hash(password);
    account.passwordReset = Date.now();
    account.resetToken = null;
    account.resetTokenExpires = null; // Clear the expiry
    await account.save();
  
    try {
      await logActivity(account.accountId, 'password_reset', ipAddress, browserInfo);
    } catch (error) {
      console.error('Error logging activity:', error);
    }
  
    return;
}
async function getAll() {

    const account =  await db.Account.findAll({
      attributes: ['accountId', 'title', 'email', 'firstName', 'lastName', 'email', 'role', 'status']
    });

    return account;
}
async function getById(accountId) {
    const account = await db.Account.findByPk(accountId);
    return account;
}
async function create(params) {
  // Check if the email is already registered
  const existingAccount = await db.Account.findOne({ where: { email: params.email } });
  if (existingAccount) {
      throw `Email "${params.email}" is already registered`;
  }

  const account = new db.Account(params);
  account.verified = Date.now();
  account.passwordHash = await hash(params.password);

  // Save the account
  await account.save();
  return account;
}
async function update(accountId, params, ipAddress, browserInfo) {
  const account = await getAccount(accountId);
  const oldData = account.toJSON();
  const updatedFields = [];
  const nonUserFields = ['ipAddress', 'browserInfo'];

  // Check if any meaningful changes are being made
  const hasChanges = Object.keys(params).some(key => 
    !nonUserFields.includes(key) && 
    params[key] !== undefined && 
    params[key] !== oldData[key]
  );

  if (!hasChanges) {
    return basicDetails(account);
  }

  if (params.email && account.email !== params.email && await db.Account.findOne({ where: { email: params.email } })) { 
      throw 'Email "' + params.email + '" is already taken';
  }

  if (params.password) {
      params.passwordHash = await hash(params.password);
  }

  for (const key in params) {
    if (params.hasOwnProperty(key) && !nonUserFields.includes(key)) {
        if (oldData[key] !== params[key]) {
            updatedFields.push(`${key}: ${oldData[key]} -> ${params[key]}`);
        }
    }
  }

  Object.assign(account, params); 
  account.updated = Date.now(); 

  try {
      await account.save();

      // Log activity with updated fields
      const updateDetails = updatedFields.length > 0 
          ? `Updated fields: ${updatedFields.join(', ')}` 
          : 'No fields changed';

      await logActivity(account.accountId, 'profile update', ipAddress || 'Unknown IP', browserInfo || 'Unknown Browser', updateDetails);
  } catch (error) {
      console.error('Error logging activity:', error);
  }

  return basicDetails(account);
}
async function _delete(accountId) {
    const account = await getAccount(accountId);
    await account.status === 'deactivated';
}
async function getAccount (accountId) {
    const account = await db.Account.findByPk(accountId); 
    if (!account) throw 'Account not found';
    return account;
}
async function getRefreshToken(token) {
    const refreshToken = await db.RefreshToken.findOne({ where: {token} });
    if (!refreshToken || !refreshToken.isActive) throw 'Invalid token'; 
    return refreshToken;
}
async function hash (password) {
    return await bcrypt.hash (password, 10);
}
function generateJwtToken(account) {
    return jwt.sign({ sub: account.accountId, accountId: account.accountId}, config.secret, { expiresIn: '1h' });
}
function generateRefreshToken(account, ipAddress) {
    return new db.RefreshToken({
        accountId: account.accountId,
        token: randomTokenString(),
        expires: new Date(Date.now() + 7*24*60*60*1000), 
        createdByIp: ipAddress
    });
}
function randomTokenString() {
    return crypto.randomBytes (40).toString('hex');
}
function basicDetails(account) {
    const { accountId, title, firstName, lastName, email, phoneNumber, role, created, updated, isVerified } = account; 
    return { accountId, title, firstName, lastName, email, phoneNumber, role, created, updated, isVerified };
}
async function sendVerificationEmail(account, origin) {
    let message;
    if (origin) {
        const verifyUrl = `${origin}/account/verify-email?token=${account.verificationToken}`; 
        message = `<p>Please click the below link to verify your email address:</p>;
                   <p><a href="${verifyUrl}">${verifyUrl}</a></p>`;
    } else {
        message = `<p>Please use the below token to verify your email address with the <code>/account/verify-email</code> api route:</p> 
                   <p><code>${account.verificationToken}</code></p>`;
    }
    
    await sendEmail({
    to: account.email,
    subject: 'Sign-up Verification API - Verify Email',
    html: `<h4>Verify Email</h4>
          <p>Thanks for registering!</p> 
          ${message}`
    });
}
async function sendAlreadyRegisteredEmail(email, origin) {
    let message; 
    if (origin) {
        message = `
        <p>If you don't know your password please visit the <a href="${origin}/account/forgot-password">forgot password</a> page.</p>`; 
    } else { message = `
        <p>If you don't know your password you can reset it via the <code>/account/forgot-password</code> api route.</p>`;
    }

    await sendEmail({
        to: email,
        subject: 'Sign-up Verification API - Email Already Registered',
        html: `<h4>Email Already Registered</h4>
        <p>Your email <strong>${email}</strong> is already registered.</p> ${message}`
    });
}
async function sendPasswordResetEmail (account, origin) {
    let message;
    if (origin) {
        const resetUrl = `${origin}/account/reset-password?token=${account.resetToken}`;
        message = `<p>Please click the below link to reset your password, the link will be valid for 1 day:</p>
                   <p><a href="${resetUrl}">${resetUrl}</a></p>`;
    } else {
        message = `<p>Please use the below token to reset your password with the <code>/account/reset-password</code> api route:</p> 
                   <p><code>${account.resetToken}</code></p>`;
    }
    
    await sendEmail({
    to: account.email,
    subject: 'Sign-up Verification API - Reset Password',
    html: `<h4>Reset Password Email</h4>
          ${message}`
    });
}

================================================================================
File: _services\qr.service.js
Size: 12.58 kB
================================================================================

const fs      = require('fs');
const path    = require('path');
const crypto  = require('crypto');
const QRCode  = require('qrcode');
const db      = require('_helpers/db-handler');

const UPLOADS_DIR = path.join(__dirname, '../uploads');
if (!fs.existsSync(UPLOADS_DIR)) fs.mkdirSync(UPLOADS_DIR, { recursive: true });

function filenameFromPayload(stockroomType, payload) {
  const hash = crypto.createHash('sha256').update(payload).digest('hex').slice(0, 20);
  return `qr-${stockroomType}-${hash}.png`;
}

module.exports = {
  generateBatchQR,
  generateUnitQR,

  scanItem,
  updateItemStatus,

  markInventoryQrGenerated
};

function pickFirst(obj, ...keys) {
  if (!obj) return null;
  for (const k of keys) {
    if (obj[k] !== undefined && obj[k] !== null) return obj[k];
    if (obj.dataValues && obj.dataValues[k] !== undefined && obj.dataValues[k] !== null) return obj.dataValues[k];
  }
  return null;
}
async function loadBatchRecord(stockroomType, id) {
  if (!stockroomType || !id) return null;

  stockroomType = String(stockroomType).toLowerCase();

  // apparel
  if (stockroomType === 'apparel') {
    // try apparelInventory by PK
    if (db.ApparelInventory) {
      const inv = await db.ApparelInventory.findByPk(id);
      if (inv) return inv;
    }
    // then try receive apparel batch by PK
    if (db.ReceiveApparel) {
      const recv = await db.ReceiveApparel.findByPk(id);
      if (recv) return recv;
    }
    return null;
  }

  // adminSupply
  if (stockroomType === 'supply') {
    if (db.AdminSupplyInventory) {
      const inv = await db.AdminSupplyInventory.findByPk(id);
      if (inv) return inv;
    }
    if (db.ReceiveAdminSupply) {
      const recv = await db.ReceiveAdminSupply.findByPk(id);
      if (recv) return recv;
    }
    return null;
  }

  // generalitem
  if (stockroomType === 'it' || stockroomType === 'maintenance') {
    if (db.GenItemInventory) {
      const inv = await db.GenItemInventory.findByPk(id);
      if (inv) return inv;
    }
    if (db.ReceiveGenItem) {
      const recv = await db.ReceiveGenItem.findByPk(id);
      if (recv) return recv;
    }
    return null;
  }

  // generic pattern: try <type>Inventory then <type> table
  const inventoryModel = db[stockroomType + 'Inventory'] || db[stockroomType + '_inventory'];
  if (inventoryModel) {
    const inv = await inventoryModel.findByPk(id);
    if (inv) return inv;
  }
  if (db[stockroomType]) {
    const row = await db[stockroomType].findByPk(id);
    if (row) return row;
  }
  return null;
}
async function loadUnitRecord(stockroomType, id) {
  if (!stockroomType || !id) return null;

  stockroomType = String(stockroomType).toLowerCase();

  if (stockroomType === 'apparel') {
    if (db.Apparel) {
      const u = await db.Apparel.findByPk(id);
      if (u) return u;
    }
    // older naming possibilities
    if (db.ApparelUnit) {
      const u2 = await db.ApparelUnit.findByPk(id);
      if (u2) return u2;
    }
    return null;
  }

  if (stockroomType === 'supply') {
    if (db.AdminSupply) {
      const u = await db.AdminSupply.findByPk(id);
      if (u) return u;
    }
    return null;
  }

  if (db[stockroomType]) {
    const u = await db[stockroomType].findByPk(id);
    if (u) return u;
  }
  return null;
}
function buildBatchPayloadObject(stockroomType, batch) {
  if (!batch) return { stockroomType };

  // Common fields we want in every QR
  const id = pickFirst(batch,
    // inventory primary keys in different patterns
    'id', 'apparelInventoryId', 'adminSupplyInventoryId', 'genItemInventoryId',
    'receiveApparelId', 'receiveAdminSupplyId', 'receiveGenItemId'
  );

  const name = pickFirst(batch,
    'sku', 'code', 'itemCode', 'apparelSku', 'adminSupplyCode', 'genItemSku',
    'name', 'title', 'apparelName', 'supplyName', 'genItemName', 'itemName', 'description'
  );

  // Status (inventory-level)
  const status = pickFirst(batch, 'status', 'itemStatus', 'apparelStatus', 'adminSupplyStatus');

  // totalQuantity fallbacks
  const totalQuantity = pickFirst(batch,
    'totalQuantity', 'quantity', 'qty',
    'apparelQuantity', 'supplyQuantity', 'genItemQuantity',
    'remainingQuantity', 'availableQuantity'
  );

  const roomId = pickFirst(batch, 'roomId', 'room_id');

  return {
    stockroomType: stockroomType || null,
    inventoryId: id ?? null,
    name: name ?? null,
    status: status ?? null,
    totalQuantity: (totalQuantity !== null && totalQuantity !== undefined) ? Number(totalQuantity) : null,
    roomId: roomId ?? null
  };
}
function buildUnitPayloadObject(stockroomType, unit) {
  if (stockroomType === 'apparel') {
    return {
      unitId:     unit.apparelId          ?? null,
      batchId:    unit.receiveApparelId   ?? unit.apparelInventoryId ?? null,
      status:     unit.apparelStatus      ?? null,
      roomId:     unit.roomId             ?? null,
      createdAt:  unit.createdAt          ?? null,
    };
  }

  if (stockroomType === 'supply') {
    return {
      unitId:     unit.adminSupplyId          ?? null,
      batchId:    unit.receiveAdminSupplyId   ?? unit.adminSupplyInventoryId ?? null,
      status:     unit.status                 ?? null,
      roomId:     unit.roomId                 ?? null,
      createdAt:  unit.createdAt              ?? null
    };
  }

  return {
    unitId: unit.id   ?? null,
    name:   unit.name ?? null
  };
}

async function writePngFromPayload(stockroomType, payload) {
  const filename = filenameFromPayload(stockroomType, payload);
  const absolutePath = path.join(UPLOADS_DIR, filename);
  await QRCode.toFile(absolutePath, payload, {
    errorCorrectionLevel: 'H',
    margin: 1,
    scale: 4
  });
  const publicPath = `/uploads/qrcodes/${filename}`;
  return { filename, absolutePath, publicPath };
}

async function generateBatchQR(argsOrStockroom) {
  // normalize arguments (keeps backwards compatibility)
  let stockroomType, inventoryId;
  if (typeof argsOrStockroom === 'object' && argsOrStockroom !== null && !Array.isArray(argsOrStockroom)) {
    ({ stockroomType, inventoryId } = argsOrStockroom);
  } else {
    stockroomType = arguments[0];
    inventoryId = arguments[1];
  }

  if (!stockroomType || !inventoryId) 
    throw new Error('stockroomType and inventoryId required');

  // load batch record (reuse your existing loader)
  const batch = await loadBatchRecord(stockroomType, inventoryId);
  if (!batch) throw new Error(`Batch not found for ${stockroomType} id=${inventoryId}`);

  // build payload object (use your existing builder)
  const payloadObj = buildBatchPayloadObject(stockroomType, batch);
  const payload = JSON.stringify(payloadObj);

  // compute deterministic filename & absolute path BEFORE writing
  const filename = filenameFromPayload(stockroomType, payload);
  const absolutePath = path.join(UPLOADS_DIR, filename);
  const publicPath = `/uploads/qrcodes/${filename}`;

  // if file already exists, return info immediately (idempotent)
  if (fs.existsSync(absolutePath)) {
    return { filename, absolutePath, publicPath, payload, batch };
  }

  const { filename: writtenFilename, absolutePath: writtenAbs, publicPath: writtenPublic } =
    await writePngFromPayload(stockroomType, payload, { filenameOverride: filename, outputDir: UPLOADS_DIR });

  // optional: update DB rows with qr path info (if you do that elsewhere)
  try { if (typeof batch.update === 'function') await batch.update({ qrFilePath: payload, qrCodePath: writtenPublic }); } catch (e) {}

  return { filename: writtenFilename || filename, absolutePath: writtenAbs || absolutePath, publicPath: writtenPublic || publicPath, payload, batch };
}
async function generateUnitQR(argsOrStockroom) {
  let stockroomType, unitId;
  if (typeof argsOrStockroom === 'object' && argsOrStockroom !== null && !Array.isArray(argsOrStockroom)) {
    ({ stockroomType, unitId } = argsOrStockroom);
  } else {
    stockroomType = arguments[0];
    unitId = arguments[1];
  }

  if (!stockroomType || !unitId) 
    throw new Error('stockroomType and unitId required');

  const unit = await loadUnitRecord(stockroomType, unitId);
  if (!unit) throw new Error(`Unit not found for ${stockroomType} id=${unitId}`);

  const payloadObj = buildUnitPayloadObject(stockroomType, unit);
  const payload = JSON.stringify(payloadObj);

  const filename = filenameFromPayload(stockroomType, payload);
  const absolutePath = path.join(UPLOADS_DIR, filename);
  const publicPath = `/uploads/qrcodes/${filename}`;

  if (fs.existsSync(absolutePath)) {
    return { filename, absolutePath, publicPath, payload, unit };
  }

  // otherwise create file
  const { filename: writtenFilename, absolutePath: writtenAbs, publicPath: writtenPublic } =
    await writePngFromPayload(stockroomType, payload, { filenameOverride: filename, outputDir: UPLOADS_DIR });

  try { if (typeof unit.update === 'function') await unit.update({ qrFilePath: payload, qrCodePath: writtenPublic }); } catch (e) {}

  return { filename: writtenFilename || filename, absolutePath: writtenAbs || absolutePath, publicPath: writtenPublic || publicPath, payload, unit };
}

async function scanItem(qrPayloadText) {
  if (!qrPayloadText) throw { status: 400, message: 'qr payload required' };

  // Try exact match (if you stored payload or file path in a Qr table)
  if (db.Qr) {
    const record = await db.Qr.findOne({ where: { qrFilePath: qrPayloadText } });
    if (record) return { qrRecord: record };
  }

  // Try JSON decode (most of our generated QRs are JSON payloads)
  try {
    const parsed = JSON.parse(qrPayloadText);

    // If parsed contains inventoryId -> try to load inventory row
    if (parsed.inventoryId || parsed.id) {
      const itemType = (parsed.stockroomType || parsed.itemType || parsed.type || 'apparel').toString().toLowerCase();
      const inventoryId = parsed.inventoryId || parsed.id;

      const inv = await loadBatchRecord(itemType, Number(inventoryId));
      if (inv) {
        // build a clean response: include parsed payload and the loaded inventory row (for frontend usage)
        return { payload: parsed, inventory: inv };
      }
    }

    // If parsed contains unitId -> try to load unit row
    if (parsed.unitId) {
      const itemType = (parsed.stockroomType || parsed.itemType || parsed.type || 'apparel').toString().toLowerCase();
      const unit = await loadUnitRecord(itemType, Number(parsed.unitId));
      if (unit) return { payload: parsed, unit };
    }

    // otherwise return the parsed payload for the frontend to handle (no db row found)
    return { payload: parsed };
  } catch (e) {
    // not JSON — the payload is a plain string (maybe an old style code)
    // Try match on QR table again by code fields (if you have them), else 404
    throw { status: 404, message: 'QR code not found' };
  }
}

async function updateItemStatus(stockroomType, id) {
  if (!stockroomType || !id) return null;

  if (stockroomType === 'apparel') {
    const updated = await db.Apparel.update(
      { itemStatus: updated.apparelStatus },
      { where: { id } }
    );
    if (!updated) throw new Error('Status update failed');

    return null;
  }
}
async function markInventoryQrGenerated(stockroomType, inventoryId) {
  try {
    if (!inventoryId) return;

    stockroomType = String(stockroomType || '').toLowerCase();

    if (stockroomType === 'apparel' && db.ApparelInventory) {
      await db.ApparelInventory.update({ qrStatus: true }, { where: { id: inventoryId } });
      return;
    }
    if (stockroomType === 'supply' && db.AdminSupplyInventory) {
      await db.AdminSupplyInventory.update({ qrStatus: true }, { where: { id: inventoryId } });
      return;
    }
    if ((stockroomType === 'general' || stockroomType === 'it' || stockroomType === 'maintenance') && db.GenItemInventory) {
      await db.GenItemInventory.update({ qrStatus: true }, { where: { id: inventoryId } });
      return;
    }

    const modelName = `${stockroomType.charAt(0).toUpperCase()}${stockroomType.slice(1)}Inventory`;
    if (db[modelName]) {
      await db[modelName].update({ qrStatus: true }, { where: { id: inventoryId } });
    }
  } catch (err) {
    console.warn('markInventoryQrGenerated warning:', err && err.message ? err.message : err);
  }
}

================================================================================
File: _services\request.item.service.js
Size: 9.38 kB
================================================================================

// _services/itemRequest.service.js
const db = require('_helpers/db-handler');
const Role = require('_helpers/role');

module.exports = {
  createItemRequest,
  listItemRequests,
  getItemRequestById,
  acceptItemRequest,
  declineItemRequest,
  releaseItemRequest,
  fulfillItemRequest
};

async function createItemRequest({ accountId, requesterRoomId = null, itemId = null, itemType = 'apparel', quantity = 1, note = null }) {
  if (!accountId) throw { status: 400, message: 'accountId required' };
  if (!['apparel','supply','genItem'].includes(itemType)) throw { status: 400, message: 'invalid itemType' };
  if (!Number.isInteger(quantity) || quantity <= 0) throw { status: 400, message: 'quantity must be positive' };

  const req = await db.ItemRequest.create({
    accountId, requesterRoomId, itemId, itemType, quantity, note, status: 'pending'
  });

  return req;
}
async function listItemRequests({ where = {}, limit = 100, offset = 0 } = {}) {
  return await db.ItemRequest.findAll({ where, order: [['itemRequestId','DESC']], limit, offset });
}
async function getItemRequestById(id) {
  const r = await db.ItemRequest.findByPk(id);
  if (!r) throw { status: 404, message: 'ItemRequest not found' };
  return r;
}
async function acceptItemRequest(id, acceptorAccountId) {
  const req = await getItemRequestById(id);
  if (req.status !== 'pending') throw { status: 400, message: 'Only pending requests can be accepted' };

  req.status = 'accepted';
  req.acceptedBy = acceptorAccountId || null;
  req.acceptedAt = new Date();
  await req.save();
  return req;
}
async function declineItemRequest(id, declinerAccountId, reason = null) {
  const req = await getItemRequestById(id);
  if (req.status !== 'pending') throw { status: 400, message: 'Only pending requests can be declined' };
  req.status = 'declined';
  if (reason) req.note = (req.note ? req.note + ' | ' : '') + `Declined: ${reason}`;
  await req.save();
  return req;
}
async function releaseItemRequest(id, releaserAccountId) {
  const req = await getItemRequestById(id);
  if (req.status !== 'accepted') throw { status: 400, message: 'Only accepted requests can be released' };

  const qty = parseInt(req.quantity || 0, 10);
  if (!Number.isInteger(qty) || qty <= 0) throw { status: 400, message: 'Invalid quantity' };

  const sequelize = db.sequelize || null;
  const t = sequelize ? await sequelize.transaction() : null;

  try {
    // resolve inventory aggregate (or unit -> inventory)
    const inv = await resolveInventory(req, { transaction: t });
    if (!inv) {
      // mark out_of_stock and commit so caller sees state change
      req.status = 'out_of_stock';
      await req.save({ transaction: t });
      if (t) await t.commit();
      throw { status: 404, message: 'Inventory item not found; request marked out_of_stock' };
    }

    const available = inv.totalQuantity || 0;
    if (available < qty) {
      req.status = 'out_of_stock';
      await req.save({ transaction: t });
      if (t) await t.commit();
      throw { status: 400, message: `Not enough stock to release (${available} available); request marked out_of_stock` };
    }

    // fetch requester name for claimedBy
    const requester = await db.Account.findByPk(req.accountId || req.acccountId, { transaction: t });
    const requesterName = requester ? `${requester.firstName || ''} ${requester.lastName || ''}`.trim() : String(req.accountId || req.acccountId);

    // create release record (type-specific) and update inventory + units
    const releaseBatch = await createReleaseForType(req, inv, qty, requesterName, releaserAccountId, { transaction: t });

    // mark request released
    req.status = 'released';
    req.releasedBy = releaserAccountId || null;
    req.releasedAt = new Date();
    await req.save({ transaction: t });

    if (t) await t.commit();
    return { request: req, releaseBatch };
  } catch (err) {
    if (t) {
      try { await t.rollback(); } catch (e) { /* ignore rollback error */ }
    }
    // best-effort: if request still accepted, mark out_of_stock to avoid dangling accepted requests
    try {
      const fresh = await db.ItemRequest.findByPk(id);
      if (fresh && fresh.status === 'accepted') {
        fresh.status = 'out_of_stock';
        await fresh.save();
      }
    } catch (e) { /* ignore */ }
    throw err;
  }
}

/* ---------------- Helpers ---------------- */

async function resolveInventory(req, opts = {}) {
  // Prefer inventory aggregates; otherwise attempt unit -> inventory.
  const txOpt = opts.transaction ? { transaction: opts.transaction } : {};
  if (req.itemType === 'apparel') {
    let inv = await db.ApparelInventory.findByPk(req.itemId, txOpt);
    if (inv) return inv;
    const unit = await db.Apparel.findByPk(req.itemId, txOpt);
    if (unit?.apparelInventoryId) return await db.ApparelInventory.findByPk(unit.apparelInventoryId, txOpt);
    return null;
  }

  if (req.itemType === 'supply') {
    let inv = await db.AdminSupplyInventory.findByPk(req.itemId, txOpt);
    if (inv) return inv;
    const unit = await db.AdminSupply.findByPk(req.itemId, txOpt);
    if (unit?.adminSupplyInventoryId) return await db.AdminSupplyInventory.findByPk(unit.adminSupplyInventoryId, txOpt);
    return null;
  }

  if (req.itemType === 'genItem') {
    let inv = await db.GenItemInventory.findByPk(req.itemId, txOpt);
    if (inv) return inv;
    const unit = await db.GenItem.findByPk(req.itemId, txOpt);
    if (unit?.genItemInventoryId) return await db.GenItemInventory.findByPk(unit.genItemInventoryId, txOpt);
    return null;
  }

  return null;
}
async function createReleaseForType(req, inv, qty, requesterName, releaserAccountId, opts = {}) {
  // opts can contain { transaction }
  const tx = opts.transaction ? { transaction: opts.transaction } : {};
  const releaserLabel = releaserAccountId ? String(releaserAccountId) : 'Stockroom';

  if (req.itemType === 'apparel') {
    const release = await db.ReleaseApparel.create({
      roomId:                 inv.roomId,
      apparelInventoryId:     inv.apparelInventoryId ?? inv.id,
      releasedBy:             releaserLabel,
      claimedBy:              requesterName,
      releaseApparelQuantity: qty
    }, tx);

    // deduct inventory aggregate
    inv.totalQuantity = (inv.totalQuantity || 0) - qty;
    await inv.save(tx);

    // mark per-unit Apparel rows as released (best-effort)
    if (db.Apparel && qty > 0) {
      const units = await db.Apparel.findAll({
        where: { apparelInventoryId: inv.apparelInventoryId ?? inv.id, status: 'good' }, // 'good' is your in-stock apparel enum
        limit: qty,
        order: [['apparelId', 'ASC']],
        ...tx
      });
      await Promise.all(units.map(u => { u.status = 'released'; return u.save(tx); }));
    }

    return release;
  }

  if (req.itemType === 'supply') {
    let release = null;
    if (db.ReleaseAdminSupply) {
      release = await db.ReleaseAdminSupply.create({
        roomId:                     inv.roomId,
        adminSupplyInventoryId:     inv.adminSupplyInventoryId ?? inv.id,
        releasedBy:                 releaserLabel,
        claimedBy:                  requesterName,
        releaseAdminSupplyQuantity: qty
      }, tx);
    } else {
      release = { note: 'AdminSupply released (no ReleaseAdminSupply model)', inventoryId: inv.adminSupplyInventoryId ?? inv.id, qty };
    }

    inv.totalQuantity = (inv.totalQuantity || 0) - qty;
    await inv.save(tx);

    if (db.AdminSupply && qty > 0) {
      const units = await db.AdminSupply.findAll({
        where: { adminSupplyInventoryId: inv.adminSupplyInventoryId ?? inv.id, status: 'in_stock' },
        limit: qty,
        order: [['adminSupplyId', 'ASC']],
        ...tx
      });
      await Promise.all(units.map(u => { u.status = 'released'; return u.save(tx); }));
    }

    return release;
  }

  if (req.itemType === 'genItem') {
    const release = await db.ReleaseGenItem.create({
      roomId:                inv.roomId,
      genItemInventoryId:    inv.genItemInventoryId ?? inv.id,
      releasedBy:            releaserLabel,
      claimedBy:             requesterName,
      releaseItemQuantity:   qty,
      genItemType:           inv.genItemType
    }, tx);

    inv.totalQuantity = (inv.totalQuantity || 0) - qty;
    await inv.save(tx);

    if (db.GenItem && qty > 0) {
      const units = await db.GenItem.findAll({
        where: { genItemInventoryId: inv.genItemInventoryId ?? inv.id, status: 'in_stock' },
        limit: qty,
        order: [['genItemId', 'ASC']],
        ...tx
      });
      await Promise.all(units.map(u => { u.status = 'released'; return u.save(tx); }));
    }

    return release;
  }

  throw { status: 500, message: 'Unsupported itemType for release' };
}
async function fulfillItemRequest(id, fulfillerAccountId) {
  const req = await getItemRequestById(id);
  if (req.status !== 'released') throw { status: 400, message: 'Only released requests can be fulfilled by the requester' };

  req.status = 'fulfilled';
  req.fulfilledBy = fulfillerAccountId || null;
  req.fulfilledAt = new Date();
  await req.save();
  return req;
}

================================================================================
File: _services\request.stock.service.js
Size: 13.4 kB
================================================================================

const db = require('_helpers/db-handler');

module.exports = {
  createStockRequest,
  listStockRequests,
  getStockRequestById,
  approveStockRequest,
  disapproveStockRequest,
  fulfillStockRequest
};

async function createStockRequest({ accountId, requesterRoomId = null, itemId = null, itemType = 'apparel', quantity = 1, note = null }) {
  if (!accountId) throw { status: 400, message: 'acccountId is required' };
  if (!['apparel','supply','genItem'].includes(itemType)) throw { status: 400, message: 'invalid itemType' };
  if (!Number.isInteger(quantity) || quantity <= 0) throw { status: 400, message: 'quantity must be a positive integer' };

  if (itemId) {
    const model = getInventoryModel(itemType);
    if (model) {
      const found = await model.findByPk(itemId);
      if (!found) throw { status: 400, message: `${itemType} id ${itemId} not found` };
    }
  }

  const req = await db.StockRequest.create({
    accountId, requesterRoomId, itemId, itemType, quantity, note, status: 'pending'
  });

  return req;
}
async function listStockRequests({ where = {}, limit = 100, offset = 0 } = {}) {
  return await db.StockRequest.findAll({
    where,
    order: [['stockRequestId','DESC']],
    limit,
    offset
  });
}
async function getStockRequestById(stockRequestId) {
  const r = await db.StockRequest.findByPk(stockRequestId);
  if (!r) throw { status: 404, message: 'StockRequest not found' };

  try {
    const requestedItem = await _loadRequestedItem(r.itemId, r.itemType);
    if (typeof r.setDataValue === 'function') r.setDataValue('requestedItem', requestedItem);
    else r.requestedItem = requestedItem;
  } catch (err) {
    // don't fail the whole request when item lookup fails; log for debugging.
    console.error('getStockRequestById - requested item load failed:', err);
    if (typeof r.setDataValue === 'function') r.setDataValue('requestedItem', null);
    else r.requestedItem = null;
  }

  return r;
}
async function approveStockRequest(id, approverAccountId = null) {
  const req = await getStockRequestById(id);
  if (req.status !== 'pending') throw { status: 400, message: 'Only pending requests can be approved' };
  req.status = 'approved';
  // optionally: req.approvedBy = approverAccountId; req.approvedAt = new Date(); (add columns if desired)
  await req.save();
  return req;
}
async function disapproveStockRequest(id, adminAccountId = null, reason = null) {
  const req = await getStockRequestById(id);
  if (req.status !== 'pending') throw { status: 400, message: 'Only pending requests can be disapproved' };
  req.status = 'disapproved';
  if (reason) req.note = (req.note ? req.note + ' | ' : '') + `Disapproved: ${reason}`;
  await req.save();
  return req;
}
async function fulfillStockRequest(stockRequestId, fulfillerAccountId) {
  const req = await db.StockRequest.findByPk(stockRequestId);
  if (!req) throw { status: 404, message: 'StockRequest not found' };
  if (req.status !== 'approved') throw { status: 400, message: 'Only approved requests can be fulfilled' };

  const found = await findInventoryAndType(req.itemId);
  if (!found || (!found.inv && !found.unit)) {
    req.status = 'failed_request';
    await req.save();
    throw { status: 404, message: 'Could not locate inventory item to fulfill request; marked as failed' };
  }

  const qty = parseInt(req.quantity || 0, 10);
  if (!Number.isInteger(qty) || qty <= 0) throw { status: 400, message: 'Invalid request quantity' };

  try {
    // create the Receive batch and the per-unit rows
    const createdBatch = await createReceiveAndUnits(found, qty, fulfillerAccountId || req.acccountId || 0);

    // update inventory aggregate (increase by qty)
    if (found.inv) await updateInventory(found.inv, qty);
    else {
      // attempt to resolve inventory if we only had a unit
      if (found.unit) {
        const inv = await resolveInventoryFromUnit(found);
        if (inv) await updateInventory(inv, qty);
      }
    }

    req.status = 'fulfilled';
    await req.save();

    return { request: req, createdBatch };
  } catch (err) {
    // ensure request is marked failed if something went wrong during fulfillment
    if (req.status !== 'failed_request' && req.status !== 'fulfilled') {
      req.status = 'failed_request';
      await req.save();
    }
    throw err;
  }
}

/* ---------- Helpers (kept local for drop-in) ---------- */

async function findInventoryAndType(id) {
  if (!id) return null;

  // try inventory aggregates first
  if (db.ApparelInventory) {
    const inv = await db.ApparelInventory.findByPk(id);
    if (inv) return { type: 'apparel', inv };
  }
  if (db.AdminSupplyInventory) {
    const inv = await db.AdminSupplyInventory.findByPk(id);
    if (inv) return { type: 'supply', inv };
  }
  if (db.GenItemInventory) {
    const inv = await db.GenItemInventory.findByPk(id);
    if (inv) return { type: 'genitem', inv };
  }

  // fallback: maybe it's a unit id (Apparel/AdminSupply/GenItem)
  if (db.Apparel) {
    const u = await db.Apparel.findByPk(id);
    if (u) return { type: 'apparel', unit: u };
  }
  if (db.AdminSupply) {
    const u = await db.AdminSupply.findByPk(id);
    if (u) return { type: 'supply', unit: u };
  }
  if (db.GenItem) {
    const u = await db.GenItem.findByPk(id);
    if (u) return { type: 'genitem', unit: u };
  }

  return null;
}
async function resolveInventoryFromUnit(found) {
  try {
    if (found.type === 'apparel' && found.unit.apparelInventoryId) {
      return await db.ApparelInventory.findByPk(found.unit.apparelInventoryId);
    }
    if (found.type === 'supply' && found.unit.adminSupplyInventoryId) {
      return await db.AdminSupplyInventory.findByPk(found.unit.adminSupplyInventoryId);
    }
    if (found.type === 'genitem' && found.unit.genItemInventoryId) {
      return await db.GenItemInventory.findByPk(found.unit.genItemInventoryId);
    }
  } catch (e) {
    return null;
  }
  return null;
}
function getUnitStatusForType(type) {
  if (type === 'apparel') return 'good';
  if (type === 'supply') return 'in_stock';
  if (type === 'genitem') return 'in_stock';
  return 'in_stock';
}
async function createReceiveAndUnits(found, qty, fulfillerAccountId) {
  // Returns created batch row. Creates per-unit rows if unit model exists.
  if (found.type === 'apparel') {
    const inv = found.inv || (found.unit ? await resolveInventoryFromUnit(found) : null);
    if (!inv) throw { status: 404, message: 'Apparel inventory record not found' };

    const batch = await db.ReceiveApparel.create({
      roomId:          inv.roomId,
      receivedFrom:    'Administration',
      receivedBy:      fulfillerAccountId,
      apparelName:     inv.apparelName,
      apparelLevel:    inv.apparelLevel,
      apparelType:     inv.apparelType,
      apparelFor:      inv.apparelFor,
      apparelSize:     inv.apparelSize,
      apparelQuantity: qty
    });

    const unitStatus = getUnitStatusForType(found.type);

// apparel units example
if (db.Apparel && qty > 0) {
  const apparelUnits = Array(qty).fill().map(() => ({
    receiveApparelId: batch.receiveApparelId,
    apparelInventoryId: inv.apparelInventoryId ?? inv.id,
    roomId: inv.roomId,
    status: unitStatus   // <-- use mapping
  }));
  await db.Apparel.bulkCreate(apparelUnits);
}

    return batch;
  }

  if (found.type === 'supply') {
    const inv = found.inv || (found.unit ? await resolveInventoryFromUnit(found) : null);
    if (!inv) throw { status: 404, message: 'AdminSupply inventory record not found' };

    const batch = await db.ReceiveAdminSupply.create({
      roomId:        inv.roomId,
      receivedFrom:  'Administration',
      receivedBy:    fulfillerAccountId,
      supplyName:    inv.supplyName,
      supplyQuantity: qty,
      supplyMeasure: inv.supplyMeasure
    });

    if (db.AdminSupply && qty > 0) {
      const units = Array(qty).fill().map(() => ({
        receiveAdminSupplyId: batch.receiveAdminSupplyId,
        adminSupplyInventoryId: inv.adminSupplyInventoryId ?? inv.id,
        roomId: inv.roomId,
        status: 'in_stock'
      }));
      await db.AdminSupply.bulkCreate(units);
    }

    return batch;
  }

  if (found.type === 'genitem') {
    const inv = found.inv || (found.unit ? await resolveInventoryFromUnit(found) : null);
    if (!inv) throw { status: 404, message: 'GenItem inventory record not found' };

    const batch = await db.ReceiveGenItem.create({
      roomId:         inv.roomId,
      receivedFrom:   'Administration',
      receivedBy:     fulfillerAccountId,
      genItemName:    inv.genItemName,
      genItemSize:    inv.genItemSize ?? null,
      genItemQuantity: qty,
      genItemType:    inv.genItemType
    });

    if (db.GenItem && qty > 0) {
      const units = Array(qty).fill().map(() => ({
        receiveGenItemId: batch.receiveGenItemId,
        roomId: inv.roomId,
        status: 'in_stock'
      }));
      await db.GenItem.bulkCreate(units);
    }

    return batch;
  }

  throw { status: 500, message: 'Unsupported inventory type' };
}
async function updateInventory(inv, qty) {
  // update the aggregate totalQuantity field (safe against different column names)
  if (!inv) return;
  if (typeof inv.totalQuantity !== 'undefined') {
    inv.totalQuantity = (inv.totalQuantity || 0) + qty;
    await inv.save();
    return;
  }
  if (typeof inv.supplyQuantity !== 'undefined') {
    inv.supplyQuantity = (inv.supplyQuantity || 0) + qty;
    await inv.save();
    return;
  }
  if (typeof inv.quantity !== 'undefined') {
    inv.quantity = (inv.quantity || 0) + qty;
    await inv.save();
    return;
  }

  // If none of the expected fields are present, throw so caller can mark failed_request.
  throw { status: 500, message: 'Inventory does not have known quantity field' };
}
function getInventoryModel(itemType) {
  // your models use: ApparelInventory, AdminSupplyInventory, GenItemInventory (see _models)
  if (itemType === 'apparel') return db.ApparelInventory || null;
  if (itemType === 'supply') return db.AdminSupplyInventory || null;
  if (itemType === 'genItem') return db.GenItemInventory || null;
  return null;
}

async function _loadRequestedItem(itemId, itemTypeRaw) {
  if (!itemId) return null;

  // normalize label for 'type' only (for returned object)
  const typeNorm = String(itemTypeRaw || '').toLowerCase();

  // 1) prefer inventory aggregate (uses your existing helper)
  const invModel = getInventoryModel(itemTypeRaw);
  if (invModel) {
    const inv = await invModel.findByPk(itemId);
    if (inv) return { kind: 'inventory', type: typeNorm || 'unknown', inventory: inv, unit: null };
  }

  // 2) try unit model by type
  const unitResult = await _tryLoadUnitByType(itemId, typeNorm);
  if (unitResult) return unitResult;

  // 3) fallback: try all unit models (best-effort)
  return await _tryLoadAnyUnit(itemId);
}
async function _tryLoadUnitByType(itemId, typeNorm) {
  try {
    if (typeNorm.includes('apparel')) {
      if (db.Apparel) {
        const unit = await db.Apparel.findByPk(itemId);
        if (unit) {
          const inv = await resolveInventoryFromUnit({ type: 'apparel', unit }).catch(() => null);
          return { kind: 'unit', type: 'apparel', unit, inventory: inv || null };
        }
      }
    } else if (typeNorm.includes('supply') || typeNorm === 'supply') {
      if (db.AdminSupply) {
        const unit = await db.AdminSupply.findByPk(itemId);
        if (unit) {
          const inv = await resolveInventoryFromUnit({ type: 'supply', unit }).catch(() => null);
          return { kind: 'unit', type: 'supply', unit, inventory: inv || null };
        }
      }
    } else if (typeNorm.includes('gen') || typeNorm === 'genitem' || typeNorm === 'gen-item') {
      if (db.GenItem) {
        const unit = await db.GenItem.findByPk(itemId);
        if (unit) {
          const inv = await resolveInventoryFromUnit({ type: 'genitem', unit }).catch(() => null);
          return { kind: 'unit', type: 'genitem', unit, inventory: inv || null };
        }
      }
    }
  } catch (e) {
    // bubble up (will be caught by caller)
    throw e;
  }
  return null;
}
async function _tryLoadAnyUnit(itemId) {
  // Apparel
  if (db.Apparel) {
    const unit = await db.Apparel.findByPk(itemId);
    if (unit) {
      const inv = await resolveInventoryFromUnit({ type: 'apparel', unit }).catch(() => null);
      return { kind: 'unit', type: 'apparel', unit, inventory: inv || null };
    }
  }

  // AdminSupply
  if (db.AdminSupply) {
    const unit = await db.AdminSupply.findByPk(itemId);
    if (unit) {
      const inv = await resolveInventoryFromUnit({ type: 'supply', unit }).catch(() => null);
      return { kind: 'unit', type: 'supply', unit, inventory: inv || null };
    }
  }

  // GenItem
  if (db.GenItem) {
    const unit = await db.GenItem.findByPk(itemId);
    if (unit) {
      const inv = await resolveInventoryFromUnit({ type: 'genitem', unit }).catch(() => null);
      return { kind: 'unit', type: 'genitem', unit, inventory: inv || null };
    }
  }

  return null;
}

================================================================================
File: _services\room.service.js
Size: 26.01 kB
================================================================================

const db        = require('_helpers/db-handler');
const qrService = require('_services/qr.service');

module.exports = {
  // POST -------------------------------------------------------------------------------------
  createRoomHandler,                  // create new room.
  ensureIsStockroomHandler,           // will check if the type of a room is stockroom or sub stockroom

  receiveInStockroomHandler,          // recieve in stockroom and it will route to the specific recieve functions depends on its payload.
  receiveApparelInRoomHandler,        // receive apparel function with its payload.
  receiveAdminSupplyInRoomHandler,    // receive admin supply function and its payload.
  receiveGenItemInRoomHandler,        // receive general item function and its payload.

  releaseInStockroomHandler,          // release in stockroom and it will route to the specific recieve functions depends on its payload.
  releaseApparelInRoomHandler,        // release apparel function with its payload.
  releaseAdminSupplyInRoomHandler,
  releaseGenItemInRoomHandler,

  // POST & GET --------------------------------------------------------------------------------
  generateApparelBatchForRoom,
  generateAdminSupplyBatchForRoom,
  generateGenItemBatchForRoom,

  generateApparelUnitForRoom,
  generateAdminSupplyUnitForRoom,
  generateGenItemUnitForRoom,

  // GET -------------------------------------------------------------------------------------
  getRoomsHandler,                    // display all rooms.
  getRoomByIdHandler,                 // display a specific room.

  getReceiveApparelsByRoomHandler,
  getReceiveAdminSupplyByRoomHandler,
  getReceiveGenItemByRoomHandler,
  
  getApparelInventoryByRoomHandler,
  getAdminSupplyInventoryByRoomHandler,
  getGenItemInventoryByRoomHandler,
  
  getApparelUnitsByRoomHandler,
  getAdminSupplyUnitsByRoomHandler,
  getGenItemUnitsByRoomHandler,
  
  getReleaseApparelsByRoomHandler,
  getReleasedBatchAdminSupplyByRoomHandler,
  getReleasedGenItemByRoomHandler,

  // PUT -------------------------------------------------------------------------------------
  updateRoomHandler,                  // update a specific room.
};

// Room's CRUD Handler
async function getRoomsHandler() {
  return await db.Room.findAll({
    include: [{
      model: db.Account,
      attributes: ['firstName', 'lastName']
    }]
  });
}
async function createRoomHandler(params) {
  let rooms = await db.Room.findOne({ where: {roomName: params.roomName} });

  if (rooms) {
    return { 
      message: 'Room already exists'
    }
  } else {
    rooms = await db.Room.create({
      roomName: params.roomName,
      roomFloor: params.roomFloor,
      roomType: params.roomType,
      stockroomType: params.stockroomType,
      roomInCharge: params.roomInCharge
    });
    return { 
      message: 'New room created.', 
      rooms 
  };
  }
}
async function getRoomByIdHandler(roomId) {
  const rooms = await db.Room.findByPk(roomId);
  if (!rooms) {
      throw new Error('Invalid room ID');
  }
  return rooms;
}
async function updateRoomHandler(roomId, params) {
  const room = await db.Room.findByPk(roomId);
  if (!room) {
    const err = new Error('Room not found');
    err.status = 404;
    throw err;
  }

  // allowed fields to update
  const allowed = ['roomName', 'roomFloor', 'roomType', 'stockroomType', 'roomInCharge'];
  allowed.forEach(k => { if (params[k] !== undefined) room[k] = params[k]; });

  await room.save();
  return room;
}

// Stockroom/Substockroom identifier
async function ensureIsStockroomHandler(roomId) {
  const room = await db.Room.findByPk(roomId);
  if (!room) throw new Error(`Room ${roomId} not found`);

  const rt = (room.roomType).toString().toLowerCase();
  if (rt !== 'stockroom' && rt !== 'substockroom') {
    const err = new Error(`Room ${roomId} is not a stockroom/substockroom`);
    err.status = 400;
    throw err;
  }
  //const srt = (room.stockroomType).toString().toLowerCase();
  if (!room.stockroomType) {
    const err = new Error(`Can't receive these items in this room.`);
    err.status = 400;
    throw err;
  }
  return room;
}

// Receive Handler
async function receiveInStockroomHandler(roomId, payload) {
  // ensure room is stockroom/substockroom
  await ensureIsStockroomHandler(roomId);

  // normalize numeric fields
  if (payload.apparelQuantity != null) payload.apparelQuantity  = parseInt(payload.apparelQuantity, 10);
  if (payload.supplyQuantity  != null) payload.supplyQuantity   = parseInt(payload.supplyQuantity,  10);
  if (payload.genItemQuantity != null) payload.genItemQuantity  = parseInt(payload.genItemQuantity, 10);

  // apparel path
  if (payload.apparelName && Number.isInteger(payload.apparelQuantity) && payload.apparelQuantity > 0) {
    return await receiveApparelInRoomHandler(roomId, payload);
  }

  // admin supply path
  if (payload.supplyName && Number.isInteger(payload.supplyQuantity) && payload.supplyQuantity > 0) {
    return await receiveAdminSupplyInRoomHandler(roomId, payload);
  }

  // general item path
  if (payload.genItemName && Number.isInteger(payload.genItemQuantity) && payload.genItemQuantity > 0) {
    return await receiveGenItemInRoomHandler(roomId, payload);
  }

  const err = new Error('Bad payload: must include either apparelName+apparelQuantity or supplyName+supplyQuantity');
  err.status = 400;
  throw err;
}
async function receiveApparelInRoomHandler(roomId, payload) {
  // ensure room is stockroom (will throw if not)
  await ensureIsStockroomHandler(roomId);

  // 1) create the ReceiveApparel batch row (one row per batch)
  const batch = await db.ReceiveApparel.create({
    roomId,
    receivedFrom:     payload.receivedFrom,
    receivedBy:       payload.receivedBy,
    apparelName:      payload.apparelName,
    apparelLevel:     payload.apparelLevel,
    apparelType:      payload.apparelType,
    apparelFor:       payload.apparelFor,
    apparelSize:      payload.apparelSize,
    apparelQuantity:  payload.apparelQuantity,
    notes:            payload.notes || null
  });

  // 2) create or find the aggregate ApparelInventory BEFORE creating units
  const [inv] = await db.ApparelInventory.findOrCreate({
    where: {
      roomId,
      apparelName:  payload.apparelName,
      apparelLevel: payload.apparelLevel,
      apparelType:  payload.apparelType,
      apparelFor:   payload.apparelFor,
      apparelSize:  payload.apparelSize
    },
    defaults: { totalQuantity: 0 }
  });

  // 3) increment inventory total and save
  inv.totalQuantity = (inv.totalQuantity || 0) + payload.apparelQuantity;
  await inv.save();

  // 4) create per-unit rows and set apparelInventoryId so unit-level QR refers to inventory/batch aggregate
  let createdUnits = [];
  if (db.Apparel) {
    const apparelUnits = Array(payload.apparelQuantity).fill().map(() => ({
      receiveApparelId: batch.receiveApparelId,            // keep batch FK
      apparelInventoryId: inv.apparelInventoryId ?? inv.id, // also point to aggregate inventory row
      roomId: roomId,
      status: 'good'
    }));
    createdUnits = await db.Apparel.bulkCreate(apparelUnits);
  }

  // 7) return the batch (with units if you want)
  return db.ReceiveApparel.findByPk(batch.receiveApparelId, {
    include: [{ model: db.Apparel }]
  });
}
async function receiveAdminSupplyInRoomHandler(roomId, payload) {
  await ensureIsStockroomHandler(roomId);

  const batch = await db.ReceiveAdminSupply.create({
    roomId,
    receivedFrom: payload.receivedFrom,
    receivedBy: payload.receivedBy,
    supplyName: payload.supplyName,
    supplyQuantity: payload.supplyQuantity,
    supplyMeasure: payload.supplyMeasure,
    notes: payload.notes || null
  });

  const [inv] = await db.AdminSupplyInventory.findOrCreate({
    where: {
      roomId,
      supplyName: payload.supplyName,
      supplyMeasure: payload.supplyMeasure
    },
    defaults: { totalQuantity: 0 }
  });

  inv.totalQuantity = (inv.totalQuantity || 0) + payload.supplyQuantity;
  await inv.save();

  // 4) create per-unit rows and set apparelInventoryId so unit-level QR refers to inventory/batch aggregate
  let createdUnits = [];
  if (db.AdminSupply) {
    const adminSupplyUnits = Array(payload.supplyQuantity).fill().map(() => ({
      receiveAdminSupplyId: batch.receiveAdminSupplyId,            // keep batch FK
      adminSupplyInventoryId: inv.adminSupplyInventoryId ?? inv.id, // also point to aggregate inventory row
      roomId: roomId,
      status: 'in_stock'
    }));
    createdUnits = await db.AdminSupply.bulkCreate(adminSupplyUnits);
  }

  return db.ReceiveAdminSupply.findByPk(batch.receiveAdminSupplyId, {
    include: [{ model: db.AdminSupply}]
  });
}
async function receiveGenItemInRoomHandler(roomId, payload) {
  // will throw if not stockroom
  await ensureIsStockroomHandler(roomId);

  // create batch
  const batch = await db.ReceiveGenItem.create({
    roomId,
    receivedFrom:     payload.receivedFrom,
    receivedBy:       payload.receivedBy,
    genItemName:      payload.genItemName,
    genItemSize:      payload.genItemSize || null,
    genItemQuantity:  payload.genItemQuantity,
    genItemType:      payload.genItemType,
    notes:            payload.notes || null
  });

  // create per-unit apparel rows (Apparel table): one row per unit received
  // Only create if you keep per-unit tracking (Apparel model exists)
  if (db.GenItem) {
    const genItemUnits = Array(payload.genItemQuantity).fill().map(() => ({
      receiveGenItemId: batch.receiveGenItemId,
      roomId: roomId,
      status: 'in_stock'
      // optionally add itemId if you create Item rows
    }));
    //await db.Apparel.bulkCreate(apparelUnits);
    const createdUnits = await db.GenItem.bulkCreate(genItemUnits);
  }

  // update/create aggregate inventory (ApparelInventory)
  const [inv] = await db.GenItemInventory.findOrCreate({
    where: {
      roomId,
      genItemName:      payload.genItemName,
      genItemSize:      payload.genItemSize || null,
      genItemType:      payload.genItemType,
    },
    defaults: { totalQuantity: 0 }
  });

  inv.totalQuantity = (inv.totalQuantity || 0) + payload.genItemQuantity;
  await inv.save();

  // return the batch (include apparel units if you like)
  return db.ReceiveGenItem.findByPk(batch.receiveGenItemId, {
    include: [{ model: db.GenItem }]
  });
}

// Get Received Handler
async function getReceiveApparelsByRoomHandler(roomId) {
  await ensureIsStockroomHandler(roomId);

  const batches = await db.ReceiveApparel.findAll({
    where: { roomId: roomId },
    include: [
      { model: db.Account, attributes: ['accountId','firstName','lastName'], required: false },
      { model: db.Apparel, required: false }
    ],
    order: [['receivedAt', 'DESC']]
  });

  return batches;
}
async function getApparelUnitsByRoomHandler(roomId) {

  await ensureIsStockroomHandler(roomId);

  const units = await db.Apparel.findAll({
    where: { roomId: roomId },
    order: [['apparelId', 'ASC']]
  });

  return units;
}
async function getApparelInventoryByRoomHandler(roomId) {

  await ensureIsStockroomHandler(roomId);

  const inventory = await db.ApparelInventory.findAll({
    where: { roomId: roomId },
    order: [['apparelName', 'ASC'], ['apparelLevel', 'ASC']]
  });

  return inventory;
}

async function getReceiveAdminSupplyByRoomHandler(roomId) {
  await ensureIsStockroomHandler(roomId);

  const batches = await db.ReceiveAdminSupply.findAll({
    where: { roomId: roomId },
    include: [
      { model: db.Account, attributes: ['accountId','firstName','lastName'], required: false },
      { model: db.AdminSupply, required: false }
    ],
    order: [['receivedAt', 'DESC']]
  });

  return batches;
}
async function getAdminSupplyUnitsByRoomHandler(roomId) {

  await ensureIsStockroomHandler(roomId);

  const units = await db.AdminSupply.findAll({
    where: { roomId: roomId },
    order: [['adminSupplyId', 'ASC']]
  });

  return units;
}
async function getAdminSupplyInventoryByRoomHandler(roomId) {

  await ensureIsStockroomHandler(roomId);

  const inventory = await db.AdminSupplyInventory.findAll({
    where: { roomId: roomId },
    order: [['supplyName', 'ASC'], ['supplyMeasure', 'ASC']]
  });

  return inventory;
}

async function getReceiveGenItemByRoomHandler(roomId) {
  await ensureIsStockroomHandler(roomId);

  const batches = await db.ReceiveGenItem.findAll({
    where: { roomId: roomId },
    include: [
      { model: db.Account, attributes: ['accountId','firstName','lastName'], required: false },
      { model: db.GenItem, required: false }
    ],
    order: [['receivedAt', 'DESC'], ['genItemType', 'DESC']]
  });

  return batches;
}
async function getGenItemUnitsByRoomHandler(roomId) {

  await ensureIsStockroomHandler(roomId);

  const units = await db.GenItem.findAll({
    where: { roomId: roomId },
    order: [['genItemId', 'ASC']]
  });

  return units;
}
async function getGenItemInventoryByRoomHandler(roomId) {

  await ensureIsStockroomHandler(roomId);

  const inventory = await db.GenItemInventory.findAll({
    where: { roomId: roomId },
    order: [['genItemName', 'ASC'], ['genItemType', 'ASC']]
  });

  return inventory;
}

// Release Handler
async function releaseInStockroomHandler(roomId, payload) {
  // ensure room is stockroom/substockroom
  await ensureIsStockroomHandler(roomId);

  // normalize numeric fields
  if (payload.releaseApparelQuantity != null) payload.releaseApparelQuantity = parseInt(payload.releaseApparelQuantity, 10);
  //if (payload.supplyQuantity != null) payload.supplyQuantity = parseInt(payload.supplyQuantity, 10);

  // apparel path
  if (payload.apparelInventoryId && Number.isInteger(payload.releaseApparelQuantity) && payload.releaseApparelQuantity > 0) {
    return await releaseApparelInRoomHandler(roomId, payload);
  }

  // admin supply path
  if (payload.adminSupplyInventoryId && Number.isInteger(payload.releaseAdminSupplyQuantity) && payload.releaseAdminSupplyQuantity > 0) {
    return await releaseAdminSupplyInRoomHandler(roomId, payload);
  }

  // general item path
  if (payload.genItemInventoryId && Number.isInteger(payload.releaseItemQuantity) && payload.releaseItemQuantity > 0) {
    return await releaseGenItemInRoomHandler(roomId, payload);
  }

  const err = new Error('Bad payload: must include either name or quantity');
  err.status = 400;
  throw err;
}
async function releaseApparelInRoomHandler(roomId, payload) {
  await ensureIsStockroomHandler(roomId);

  // require numeric quantity
  const qty = Number(payload.releaseApparelQuantity || 0);
  if (!Number.isInteger(qty) || qty <= 0) throw { status: 400, message: 'Invalid release quantity' };

  const sequelize = db.sequelize || null;
  const t = sequelize ? await sequelize.transaction() : null;

  try {
    // find or create the aggregate inventory within transaction
    const [inv] = await db.ApparelInventory.findOrCreate({
      where: {
        roomId,
        apparelInventoryId: payload.apparelInventoryId,
      },
      defaults: { totalQuantity: 0, status: 'out_of_stock' },
      transaction: t
    });

    const available = inv.totalQuantity || 0;
    if (available < qty) {
      // not enough stock -> do not create release, signal error
      if (t) await t.rollback();
      throw { status: 400, message: `Not enough stock to release (${available} available)` };
    }

    // create batch
    const batch = await db.ReleaseApparel.create({
      roomId,
      apparelInventoryId: payload.apparelInventoryId,
      releasedBy: payload.releasedBy,
      claimedBy: payload.claimedBy,
      releaseApparelQuantity: qty,
      notes: payload.notes || null
    }, { transaction: t });

    // deduct and update status using helper
    await updateInventory(inv, -qty, { transaction: t });

    if (t) await t.commit();

    return db.ReleaseApparel.findByPk(batch.releaseApparelId);
  } catch (e) {
    if (t) await t.rollback();
    throw e;
  }
}
async function releaseAdminSupplyInRoomHandler(roomId, payload) {
  await ensureIsStockroomHandler(roomId);

  const qty = Number(payload.releaseAdminSupplyQuantity || 0);
  if (!Number.isInteger(qty) || qty <= 0) throw { status: 400, message: 'Invalid release quantity' };

  const sequelize = db.sequelize || null;
  const t = sequelize ? await sequelize.transaction() : null;

  try {
    const [inv] = await db.AdminSupplyInventory.findOrCreate({
      where: {
        roomId,
        adminSupplyInventoryId: payload.adminSupplyInventoryId,
      },
      defaults: { totalQuantity: 0, status: 'out_of_stock' },
      transaction: t
    });

    const available = inv.totalQuantity || 0;
    if (available < qty) {
      if (t) await t.rollback();
      throw { status: 400, message: `Not enough stock to release (${available} available)` };
    }

    const batch = await db.ReleaseAdminSupply.create({
      roomId,
      adminSupplyInventoryId: payload.adminSupplyInventoryId,
      releasedBy: payload.releasedBy,
      claimedBy: payload.claimedBy,
      releaseAdminSupplyQuantity: qty,
      notes: payload.notes || null
    }, { transaction: t });

    await updateInventory(inv, -qty, { transaction: t });

    if (t) await t.commit();
    return db.ReleaseAdminSupply.findByPk(batch.releaseAdminSupplyId);
  } catch (e) {
    if (t) await t.rollback();
    throw e;
  }
}
async function releaseGenItemInRoomHandler(roomId, payload) {
  await ensureIsStockroomHandler(roomId);

  const qty = Number(payload.releaseItemQuantity || 0);
  if (!Number.isInteger(qty) || qty <= 0) throw { status: 400, message: 'Invalid release quantity' };

  const sequelize = db.sequelize || null;
  const t = sequelize ? await sequelize.transaction() : null;

  try {
    const [inv] = await db.GenItemInventory.findOrCreate({
      where: {
        roomId,
        genItemInventoryId: payload.genItemInventoryId,
      },
      defaults: { totalQuantity: 0, status: 'out_of_stock' },
      transaction: t
    });

    const available = inv.totalQuantity || 0;
    if (available < qty) {
      if (t) await t.rollback();
      throw { status: 400, message: `Not enough stock to release (${available} available)` };
    }

    const batch = await db.ReleaseGenItem.create({
      roomId,
      genItemInventoryId: payload.genItemInventoryId,
      releasedBy: payload.releasedBy,
      claimedBy: payload.claimedBy,
      releaseItemQuantity: qty,
      genItemType: payload.genItemType,
      notes: payload.notes || null
    }, { transaction: t });

    await updateInventory(inv, -qty, { transaction: t });

    if (t) await t.commit();
    return db.ReleaseGenItem.findByPk(batch.releaseGenItemId);
  } catch (e) {
    if (t) await t.rollback();
    throw e;
  }
}

// Get Released Apparels Handler
async function getReleaseApparelsByRoomHandler(roomId) {
  await ensureIsStockroomHandler(roomId);

  const batches = await db.ReleaseApparel.findAll({
    where: { roomId: roomId },
    include: [
      { model: db.Account, attributes: ['accountId','firstName','lastName'], required: false },
    ],
    order: [['releasedAt', 'DESC']]
  });

  return batches;
}
async function getReleasedBatchAdminSupplyByRoomHandler(roomId) {
  await ensureIsStockroomHandler(roomId);

  if (db.ReleaseAdminSupply) {
    return await db.ReleaseAdminSupply.findAll({
      where: { roomId },
      order: [['releasedAt', 'DESC']]
    });
  }

  // fallback: return empty array
  return [];
}
async function getReleasedGenItemByRoomHandler(roomId) {
  await ensureIsStockroomHandler(roomId);

  if (db.ReleaseGenItem) {
    return await db.ReleaseGenItem.findAll({
      where: { roomId },
      order: [['releasedAt', 'DESC']]
    });
  }
  return [];
}

// Generate QR Code Handler
async function generateApparelBatchForRoom(roomId, inventoryId) {
  if (!roomId) throw { status: 400, message: 'roomId required' };
  if (!inventoryId) throw { status: 400, message: 'inventoryId required' };

  // ensure room is stockroom/substockroom (will throw if not)
  await ensureIsStockroomHandler(roomId);

  const inv = await db.ApparelInventory.findByPk(inventoryId);
  if (!inv) throw { status: 404, message: 'ApparelInventory not found' };
  if (String(inv.roomId) !== String(roomId)) throw { status: 403, message: 'Inventory does not belong to this room' };

  // Use apparel as stockroomType
  const result = await qrService.generateBatchQR({ stockroomType: 'apparel', inventoryId });
  return { inventoryId, ...result };
}
async function generateAdminSupplyBatchForRoom(roomId, inventoryId) {
  if (!roomId) throw { status: 400, message: 'roomId required' };
  if (!inventoryId) throw { status: 400, message: 'inventoryId required' };

  // ensure room is stockroom/substockroom (will throw if not)
  await ensureIsStockroomHandler(roomId);

  const inv = await db.AdminSupplyInventory.findByPk(inventoryId);
  if (!inv) throw { status: 404, message: 'AdminSupplyInventory not found' };
  if (String(inv.roomId) !== String(roomId)) throw { status: 403, message: 'Inventory does not belong to this room' };

  // Use apparel as stockroomType
  const result = await qrService.generateBatchQR({ stockroomType: 'supply', inventoryId });
  return { inventoryId, ...result };
}
async function generateGenItemBatchForRoom(roomId, inventoryId) {
  if (!roomId) throw { status: 400, message: 'roomId required' };
  if (!inventoryId) throw { status: 400, message: 'inventoryId required' };

  // ensure room is stockroom/substockroom (will throw if not)
  await ensureIsStockroomHandler(roomId);

  const inv = await db.GenItemInventory.findByPk(inventoryId);
  if (!inv) throw { status: 404, message: 'GenItemInventory not found' };
  if (String(inv.roomId) !== String(roomId)) throw { status: 403, message: 'Inventory does not belong to this room' };

  // Use apparel as stockroomType
  const result = await qrService.generateBatchQR({ stockroomType: 'it' || 'maintenance', inventoryId });
  return { inventoryId, ...result };
}

async function generateApparelUnitForRoom(roomId, unitId) {
  if (!roomId) throw { status: 400, message: 'roomId required' };
  if (!unitId) throw { status: 400, message: 'unitId required' };

  await ensureIsStockroomHandler(roomId);

  const unit = await db.Apparel.findByPk(unitId);
  if (!unit) throw { status: 404, message: 'Apparel unit not found' };
  if (String(unit.roomId) !== String(roomId)) throw { status: 403, message: 'Unit does not belong to this room' };

  const result = await qrService.generateUnitQR({ stockroomType: 'apparel', unitId });
  return { unitId, ...result };
}
async function generateAdminSupplyUnitForRoom(roomId, unitId) {
  if (!roomId) throw { status: 400, message: 'roomId required' };
  if (!unitId) throw { status: 400, message: 'unitId required' };

  await ensureIsStockroomHandler(roomId);

  const unit = await db.AdminSupply.findByPk(unitId);
  if (!unit) throw { status: 404, message: 'AdminSupply unit not found' };
  if (String(unit.roomId) !== String(roomId)) throw { status: 403, message: 'Unit does not belong to this room' };

  const result = await qrService.generateUnitQR({ stockroomType: 'supply', unitId });
  return { unitId, ...result };
}
async function generateGenItemUnitForRoom(roomId, unitId) {
  if (!roomId) throw { status: 400, message: 'roomId required' };
  if (!unitId) throw { status: 400, message: 'unitId required' };

  await ensureIsStockroomHandler(roomId);

  const unit = await db.GenItem.findByPk(unitId);
  if (!unit) throw { status: 404, message: 'GenItem unit not found' };
  if (String(unit.roomId) !== String(roomId)) throw { status: 403, message: 'Unit does not belong to this room' };

  const result = await qrService.generateUnitQR({ stockroomType: 'it' || 'maintenance', unitId });
  return { unitId, ...result };
}

function computeInventoryStatus(remaining) {
  if (remaining <= 1) return 'out_of_stock';
  if (remaining < 10) return 'low_stock';
  return 'high_stock';
}
async function updateInventory(inv, qtyChang, opts = {}) {
  if (!inv) return;
  const transaction = opts.transaction;

  // support different quantity column names across your models
  if (typeof inv.totalQuantity !== 'undefined') {
    inv.totalQuantity = (inv.totalQuantity || 0) + qtyChange;
    // ensure not negative
    if (inv.totalQuantity < 0) inv.totalQuantity = 0;
    // set status if model has the column
    if (typeof inv.status !== 'undefined') {
      inv.status = computeInventoryStatus(inv.totalQuantity);
    }
    await inv.save({ transaction });
    return;
  }

  // fallbacks if you used different names (supplyQuantity / quantity)
  if (typeof inv.supplyQuantity !== 'undefined') {
    inv.supplyQuantity = (inv.supplyQuantity || 0) + qtyChange;
    if (inv.supplyQuantity < 0) inv.supplyQuantity = 0;
    if (typeof inv.status !== 'undefined') inv.status = computeInventoryStatus(inv.supplyQuantity);
    await inv.save({ transaction });
    return;
  }
  if (typeof inv.quantity !== 'undefined') {
    inv.quantity = (inv.quantity || 0) + qtyChange;
    if (inv.quantity < 0) inv.quantity = 0;
    if (typeof inv.status !== 'undefined') inv.status = computeInventoryStatus(inv.quantity);
    await inv.save({ transaction });
    return;
  }

  throw { status: 500, message: 'Inventory does not have known quantity field' };
}

================================================================================
File: _services\transfer.service.js
Size: 3.81 kB
================================================================================

// _services/transfer.service.js
const db = require('_helpers/db-handler');
const { Transaction }     = require('sequelize');

module.exports = {
  createTransfer,
  acceptTransfer,
  returnTransfer,
  acceptReturned,
  getById,
  listTransfers
};

async function createTransfer({ fromRoomId, toRoomId, createdBy, itemType, itemId = null, quantity = 1, note = null }) {
  if (!fromRoomId || !toRoomId || !createdBy) throw { status: 400, message: 'Missing required fields' };
  if (!['apparel','supply','genItem'].includes(itemType)) throw { status: 400, message: 'invalid itemType' };
  quantity = parseInt(quantity, 10);
  if (!Number.isInteger(quantity) || quantity <= 0) throw { status: 400, message: 'quantity must be positive' };

  const transfer = await db.Transfer.create({
    fromRoomId, toRoomId, createdBy, itemType, itemId, quantity, note, status: 'in_transfer'
  });

  return transfer;
}
async function acceptTransfer(transferId, accepterId) {
  const transfer = await db.Transfer.findByPk(transferId);
  await transfer.update({ status: 'transfer_accepted', acceptedBy: accepterId });

  return transfer;
}
async function returnTransfer(transferId, returnerAccountId) {
  const tr = await db.Transfer.findByPk(transferId);
  if (!tr) throw { status: 404, message: 'Transfer not found' };
  if (tr.status !== 'transfer_accepted') throw { status: 400, message: 'Only accepted transfers can be returned' };

  tr.status = 'returning';
  tr.returningBy = returnerAccountId || null;
  tr.returnedAt = null;
  await tr.save();
  return tr;
}
async function acceptReturned(transferId, accepterId) {
  const transfer = await db.Transfer.findByPk(transferId);
  await transfer.update({ status: 'return_accepted', acceptedBy: accepterId });

  return transfer;
}
function inventoryModelFor(itemType) {
  if (itemType === 'apparel') return db.ApparelInventory;
  if (itemType === 'supply') return db.AdminSupplyInventory;
  if (itemType === 'genItem') return db.GenItemInventory;
  return null;
}
async function findOrCreateMatchingInventory(model, exampleInv, roomId, opts = {}) {
  const transaction = opts.transaction;
  // apparel
  if (model === db.ApparelInventory) {
    const where = {
      roomId,
      apparelName: exampleInv.apparelName,
      apparelLevel: exampleInv.apparelLevel,
      apparelType: exampleInv.apparelType,
      apparelFor: exampleInv.apparelFor,
      apparelSize: exampleInv.apparelSize
    };
    const [inv] = await db.ApparelInventory.findOrCreate({ where, defaults: Object.assign({ totalQuantity: 0 }, where), transaction });
    return inv;
  }
  // admin supply
  if (model === db.AdminSupplyInventory) {
    const where = { roomId, supplyName: exampleInv.supplyName, supplyMeasure: exampleInv.supplyMeasure };
    const [inv] = await db.AdminSupplyInventory.findOrCreate({ where, defaults: Object.assign({ totalQuantity: 0 }, where), transaction });
    return inv;
  }
  // gen item
  if (model === db.GenItemInventory) {
    const where = { roomId, genItemName: exampleInv.genItemName, genItemType: exampleInv.genItemType, genItemSize: exampleInv.genItemSize };
    const [inv] = await db.GenItemInventory.findOrCreate({ where, defaults: Object.assign({ totalQuantity: 0 }, where), transaction });
    return inv;
  }

  // fallback: try primary key copy
  const [fallback] = await model.findOrCreate({ where: { roomId }, defaults: { totalQuantity: 0, roomId }, transaction });
  return fallback;
}

/* small helpers to fetch transfers */
async function getById(id) {
  return db.Transfer.findByPk(id);
}
async function listTransfers({ where = {}, limit = 200, offset = 0 } = {}) {
  return db.Transfer.findAll({ where, order: [['transferId','DESC']], limit, offset });
}

