
================================================================================
File: config.json
Size: 558 B
================================================================================

{
    "database": {
        "host": "localhost",
        "port": 3306,
        "user": "root",
        "password": "root",
        "database": "IMP_db"
    },
    "secret": "THIS IS USED TO SIGN AND VERIFY JWT TOKENS, REPLACE IT WITH YOUR OWN SECRET, IT CAN BE ANY STRING", 
    "emailFrom": "info@node-mysql-signup-verification-api.com",
    "smtpOptions": {
        "host": "smtp.ethereal.email", 
        "port": 587,
        "auth": {
            "user":"fern34@ethereal.email",
            "pass":"K283jn7kdcbq4tMXUn"
        }
    }
}

================================================================================
File: notes.md
Size: 513 B
================================================================================

<!-- items should have this status: -->
    every room scanning status:
        used - in used item
        damage - damaged item
        misplaced item - item that is not belong to that room
    
    rooms status
        missing - missing item

    stockroom status:
        active - working item but not used
        inactive - out of stock/

<!-- roles should have -->
    super admin
    admin
    user

<!-- item category should have -->
    IT assets
    apparel assets
    admin assets

================================================================================
File: package.json
Size: 903 B
================================================================================

{
  "name": "imp",
  "version": "1.0.0",
  "description": "Inventory Management Project",
  "main": "server.js",
  "scripts": {
    "start": "node ./server.js",
    "start:dev": "nodemon ./server.js",
    "export:all": "folder2txt --include-all --output allFiles.txt C:/Users/Administrator/Desktop/Inventory Monitoring/IMP"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcryptjs": "^3.0.2",
    "body-parser": "^1.20.3",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "crypto": "^1.0.1",
    "express": "^4.21.2",
    "express-jwt": "^8.5.1",
    "joi": "^17.13.3",
    "jsonwebtoken": "^9.0.2",
    "multer": "^2.0.0",
    "mysql2": "^3.12.0",
    "nodemailer": "^6.10.0",
    "rootpath": "^0.1.2",
    "sequelize": "^6.37.5",
    "swagger-ui-express": "^5.0.1",
    "yamljs": "^0.3.0"
  },
  "devDependencies": {
    "folder2txt": "^1.0.2",
    "nodemon": "^3.1.9"
  }
}


================================================================================
File: README.md
Size: 37 B
================================================================================

# IMP
Inventory Management Project


================================================================================
File: server.js
Size: 3.31 kB
================================================================================

require('rootpath')();
const express = require('express');
const app = express();
const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');
const cors = require('cors');
const errorHandler = require('_middlewares/error-handler');
const fileUpload = require('multer')();
const path = require('path');
const multer  = require('multer');

// ─── JSON / URL-ENCODED PARSING ───────────────────────────────────────────────
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// ─── MULTER DISK STORAGE ─────────────────────────────────────────────────────
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, path.join(__dirname, '..', 'uploads'));
  },
  filename: (req, file, cb) => {
    cb(null, `${Date.now()}-${file.originalname}`);
  }
});
const upload = multer({ storage });

// ─── BODY-PARSER & COOKIE ───────────────────────────────────────────────────
app.use(bodyParser.urlencoded({extended: false }));
app.use(bodyParser.json()); 
app.use(cookieParser());

// ─── FRONTEND PORT ───────────────────────────────────────────────────
app.use(
  cors({
    origin: [
      'http://localhost:3000',
      'http://192.168.1.14:3000'
    ],
    credentials: true,
  })
);

// ─── SERVE UPLOADS DIRECTORY ────────────────────────────────────────────────
app.use('/uploads', express.static(path.join(__dirname, '..', 'uploads')));

// ─── API ROUTES ────────────────────────────────────────────────
app.use('/room', require('./_controllers/room.controller'));
app.use('/accounts', require('./_controllers/account.controller'));
app.use('/items', require('./_controllers/item.controller'));

// ─── SWAGGER DOCS ROUTES ────────────────────────────────────────────────
app.use('/api-docs', require('./_helpers/swagger'));

// ─── GLOBAL ERROR HANDLER ────────────────────────────────────────────────
app.use(errorHandler);

// ─── START SERVER ────────────────────────────────────────────────
const port = process.env.NODE_ENV === 'production' ? (process.env.PORT || 80): 5000;
app.listen(port, () => console.log('Server listening on port' + port));
// const port = process.env.NODE_ENV === 'production' ? (process.env.PORT || 80) : 5000;
// app.listen(port, '0.0.0.0', () => console.log(`Server listening on 0.0.0.0:${port}`));

================================================================================
File: swagger.yaml
Size: 23.7 kB
================================================================================

openapi: 3.0.0
info:
  title: Node.js Sign-up and Verification API
  description: Node.js and MySQL - API with email sign-up, verification, authentication and forgot password
  version: 1.0.0

servers:
  - url: http://localhost:5000
    description: Local development server

paths:
  /accounts/authenticate:
    post:
      summary: Authenticate account credentials and return a JWT token and a cookie with a refresh token
      description: Accounts must be verified before authenticating.
      operationId: authenticate
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                email:
                  type: string
                  example: "jason@example.com"
                password:
                  type: string
                  example: "pass123"
              required:
                - email
                - password
      responses:
        "200":
          description: Account details, a JWT access token and a refresh token cookie
          headers:
            Set-Cookie:
              description: "`refreshToken`"
              schema:
                type: string
                example: refreshToken=51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550; Path=/; Expires=Tue, 16 Jun 2020 09:14:17 GMT; HttpOnly
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
                  isVerified:
                    type: boolean
                    example: true
                  jwtToken:
                    type: string
                    example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1ZWIxMmUxOTdlMDZhNzZjY2RlZmMxMjEiLCJpZCI6IjVlYjEyZTE5N2UwNmE3NmNjZGVmYzEyMSIsImlhdCI6MTU4ODc1ODE1N30.xR9H0STbFOpSkuGA9jHNZOJ6eS7umHHqKRhI807YT1Y"
        "400":
          description: The email or password is incorrect
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Email or password is incorrect"
  /accounts/refresh-token:
    post:
      summary: Use a refresh token to generate a new JWT token and a new refresh token
      description: The refresh token is sent and returned via cookies.
      operationId: refreshToken
      parameters:
        - in: cookie
          name: refreshToken
          description: The `refreshToken` cookie
          schema:
            type: string
            example: 51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550
      responses:
        "200":
          description: Account details, a JWT access token and a new refresh token cookie
          headers:
            Set-Cookie:
              description: "`refreshToken`"
              schema:
                type: string
                example: refreshToken=51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550; Path=/; Expires=Tue, 16 Jun 2020 09:14:17 GMT; HttpOnly
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
                  isVerified:
                    type: boolean
                    example: true
                  jwtToken:
                    type: string
                    example: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1ZWIxMmUxOTdlMDZhNzZjY2RlZmMxMjEiLCJpZCI6IjVlYjEyZTE5N2UwNmE3NmNjZGVmYzEyMSIsImlhdCI6MTU4ODc1ODE1N30.xR9H0STbFOpSkuGA9jHNZOJ6eS7umHHqKRhI807YT1Y"
        "400":
          description: The refresh token is invalid, revoked or expired
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Invalid token"
  /accounts/revoke-token:
    post:
      summary: Revoke a refresh token
      description: Admin users can revoke the tokens of any account, regular users can only revoke their own tokens.
      operationId: revokeToken
      security:
        - bearerAuth: []
      parameters:
        - in: cookie
          name: refreshToken
          description: The refresh token can be sent in a cookie or the post body, if both are sent the token in the body is used.
          schema:
            type: string
            example: 51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                token:
                  type: string
                  example: "51872eca5efedcf424db4cf5afd16a9d00ad25b743a034c9c221afc85d18dcd5e4ad6e3f08607550"
      responses:
        "200":
          description: The refresh token was successfully revoked
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Token revoked"
        "400":
          description: The refresh token is invalid
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Invalid token"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
  /accounts/register:
    post:
      summary: Register a new user account and send a verification email
      description: The first account registered in the system is assigned the `Admin` role, other accounts are assigned the `User` role.
      operationId: register
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                title:
                  type: string
                  example: "Mr"
                firstName:
                  type: string
                  example: "Jason"
                lastName:
                  type: string
                  example: "Watmore"
                email:
                  type: string
                  example: "jason@example.com"
                password:
                  type: string
                  example: "pass123"
                confirmPassword:
                  type: string
                  example: "pass123"
                acceptTerms:
                  type: boolean
              required:
                - title
                - firstName
                - lastName
                - email
                - password
                - confirmPassword
                - acceptTerms
      responses:
        "200":
          description: The registration request was successful and a verification email has been sent to the specified email address
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Registration successful, please check your email for verification instructions"
  /accounts/verify-email:
    post:
      summary: Verify a new account with a verification token received by email after registration
      operationId: verifyEmail
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                token:
                  type: string
                  example: "3c7f8d9c4cb348ff95a0b74a1452aa24fc9611bb76768bb9eafeeb826ddae2935f1880bc7713318f"
              required:
                - token
      responses:
        "200":
          description: Verification was successful so you can now login to the account
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Verification successful, you can now login"
        "400":
          description: Verification failed due to an invalid token
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Verification failed"
  /accounts/forgot-password:
    post:
      summary: Submit email address to reset the password on an account
      operationId: forgotPassword
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                email:
                  type: string
                  example: "jason@example.com"
              required:
                - email
      responses:
        "200":
          description: The request was received and an email has been sent to the specified address with password reset instructions (if the email address is associated with an account)
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Please check your email for password reset instructions"
  /accounts/validate-reset-token:
    post:
      summary: Validate the reset password token received by email after submitting to the /accounts/forgot-password route
      operationId: validateResetToken
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                token:
                  type: string
                  example: "3c7f8d9c4cb348ff95a0b74a1452aa24fc9611bb76768bb9eafeeb826ddae2935f1880bc7713318f"
              required:
                - token
      responses:
        "200":
          description: Token is valid
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Token is valid"
        "400":
          description: Token is invalid
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Invalid token"
  /accounts/reset-password:
    post:
      summary: Reset the password for an account
      operationId: resetPassword
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                token:
                  type: string
                  example: "3c7f8d9c4cb348ff95a0b74a1452aa24fc9611bb76768bb9eafeeb826ddae2935f1880bc7713318f"
                password:
                  type: string
                  example: "newPass123"
                confirmPassword:
                  type: string
                  example: "newPass123"
              required:
                - token
                - password
                - confirmPassword
      responses:
        "200":
          description: Password reset was successful so you can now login to the account with the new password
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Password reset successful, you can now login"
        "400":
          description: Password reset failed due to an invalid token
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Invalid token"
  /accounts:
    get:
      summary: Get a list of all accounts
      description: Restricted to admin users.
      operationId: getAllAccounts
      security:
        - bearerAuth: []
      responses:
        "200":
          description: An array of all accounts
          content:
            application/json:
              schema:
                type: array
                items:
                  type: object
                  properties:
                    id:
                      type: string
                      example: "5eb12e197e06a76ccdefc121"
                    title:
                      type: string
                      example: "Mr"
                    firstName:
                      type: string
                      example: "Jason"
                    lastName:
                      type: string
                      example: "Watmore"
                    email:
                      type: string
                      example: "jason@example.com"
                    role:
                      type: string
                      example: "Admin"
                    created:
                      type: string
                      example: "2020-05-05T09:12:57.848Z"
                    updated:
                      type: string
                      example: "2020-05-08T03:11:21.553Z"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
    post:
      summary: Create a new account
      description: Restricted to admin users.
      operationId: createAccount
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                title:
                  type: string
                  example: "Mr"
                firstName:
                  type: string
                  example: "Jason"
                lastName:
                  type: string
                  example: "Watmore"
                email:
                  type: string
                  example: "jason@example.com"
                password:
                  type: string
                  example: "pass123"
                confirmPassword:
                  type: string
                  example: "pass123"
                role:
                  type: string
                  enum: [Admin, User]
              required:
                - title
                - firstName
                - lastName
                - email
                - password
                - confirmPassword
                - role
      responses:
        "200":
          description: Account created successfully, verification is not required for accounts created with this endpoint. The details of the new account are returned.
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
        "400":
          description: Email is already registered
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Email 'jason@example.com' is already registered"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
  /accounts/{id}:
    parameters:
      - in: path
        name: id
        description: Account id
        required: true
        example: "5eb12e197e06a76ccdefc121"
        schema:
          type: string
    get:
      summary: Get a single account by id
      description: Admin users can access any account, regular users are restricted to their own account.
      operationId: getAccountById
      security:
        - bearerAuth: []
      responses:
        "200":
          description: Details of the specified account
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
                  updated:
                    type: string
                    example: "2020-05-08T03:11:21.553Z"
        "404":
          $ref: "#/components/responses/NotFoundError"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
    put:
      summary: Update an account
      description: Admin users can update any account including role, regular users are restricted to their own account and cannot update role.
      operationId: updateAccount
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                title:
                  type: string
                  example: "Mr"
                firstName:
                  type: string
                  example: "Jason"
                lastName:
                  type: string
                  example: "Watmore"
                email:
                  type: string
                  example: "jason@example.com"
                password:
                  type: string
                  example: "pass123"
                confirmPassword:
                  type: string
                  example: "pass123"
                role:
                  type: string
                  enum: [Admin, User]
      responses:
        "200":
          description: Account updated successfully. The details of the updated account are returned.
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                    example: "5eb12e197e06a76ccdefc121"
                  title:
                    type: string
                    example: "Mr"
                  firstName:
                    type: string
                    example: "Jason"
                  lastName:
                    type: string
                    example: "Watmore"
                  email:
                    type: string
                    example: "jason@example.com"
                  role:
                    type: string
                    example: "Admin"
                  created:
                    type: string
                    example: "2020-05-05T09:12:57.848Z"
                  updated:
                    type: string
                    example: "2020-05-08T03:11:21.553Z"
        "404":
          $ref: "#/components/responses/NotFoundError"
        "401":
          $ref: "#/components/responses/UnauthorizedError"
    delete:
      summary: Delete an account
      description: Admin users can delete any account, regular users are restricted to their own account.
      operationId: deleteAccount
      security:
        - bearerAuth: []
      responses:
        "200":
          description: Account deleted successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  message:
                    type: string
                    example: "Account deleted successfully"
        "404":
          $ref: "#/components/responses/NotFoundError"
        "401":
          $ref: "#/components/responses/UnauthorizedError"

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  responses:
    UnauthorizedError:
      description: Access token is missing or invalid, or the user does not have access to perform the action
      content:
        application/json:
          schema:
            type: object
            properties:
              message:
                type: string
                example: "Unauthorized"
    NotFoundError:
      description: Not Found
      content:
        application/json:
          schema:
            type: object
            properties:
              message:
                type: string
                example: "Not Found"

================================================================================
File: _controllers\account.controller.js
Size: 11.19 kB
================================================================================

const express = require('express');
const router = express. Router(); 
const Joi = require('joi');
const validateRequest = require('_middlewares/validate-request'); 
const authorize = require('_middlewares/authorize');
const Role = require('_helpers/role');
const accountService = require('_services/account.service');

router.post('/authenticate', authenticateSchema, authenticate);
router.post('/refresh-token', refreshToken);
router.post('/revoke-token', authorize(), revokeTokenSchema, revokeToken); 
router.post('/register', authorize(Role.SuperAdmin), registerSchema, register);
router.post('/verify-email', verifyEmailSchema, verifyEmail);
router.post('/forgot-password', forgotPasswordSchema, forgotPassword);
router.post('/validate-reset-token', validateResetTokenSchema, validateResetToken);
router.post('/reset-password', resetPasswordSchema, resetPassword);

router.get('/:id/preferences',authorize(), getPreferences);
router.put('/:id/preferences',authorize(), updatePreferences);

router.post('/:id/activity', authorize(), getActivities);
router.get('/activity-logs', authorize(Role.SuperAdmin), getAllActivityLogs);

router.get('/', authorize (Role.SuperAdmin), getAll);
router.get('/:id', authorize(), getById);
router.post('/create-user', authorize (Role.SuperAdmin), createSchema, create);
router.put('/:id', authorize(), updateSchema, update);
router.delete('/:id', authorize(Role.SuperAdmin), _delete);

module.exports = router;

function authenticateSchema(req, res, next) { 
    const schema = Joi.object({
        email: Joi.string().required(),
        password: Joi.string().required()
    });

    validateRequest(req, next, schema);
}
async function authenticate(req, res, next) {
    try {
    const { email, password } = req.body;
    const ipAddress = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
    const browserInfo = req.headers['user-agent'] || 'Unknown Browser';

    const { jwtToken, refreshToken, user } = await accountService.authenticate({ email, password, ipAddress, browserInfo });
    res
    .cookie('token', jwtToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 1000, // 1h
    });
    //.json({ success: true });

    setTokenCookie(res, refreshToken);

    return res.json({ success: true, user });
  } catch (err) {
    // Only call next(err) on errors
    next(err);
  }
  
    // accountService.authenticate({ email, password, ipAddress, browserInfo })
    //   .then(({ refreshToken, ...account }) => {
    //     setTokenCookie(res, refreshToken);
    //     res.json(account);
    //   })
    //   .catch(next);
  }
//===================Logging Function=======================================
function getActivities(req, res, next) {
    const filters = {
        actionType: req.query.actionType,
        startDate: req.query.startDate,
        endDate: req.query.endDate
    };
    accountService.getAccountActivities(req.params.id, filters)
        .then(activities => res.json(activities))
        .catch(next);
}
function getAllActivityLogs(req, res, next) {
    const filters = {
        actionType: req.query.actionType,
        startDate: req.query.startDate,
        endDate: req.query.endDate,
        userId: req.query.userId
    };
    
    accountService.getAllActivityLogs(filters)
        .then(logs => res.json({
            success: true,
            data: logs
        }))
        .catch(next);
}
//====================Preferences Router Function=========================
function getPreferences(req, res, next) {
    accountService.getPreferences(req.params.id)
        .then(preferences => res.json(preferences))
        .catch(next);
}
function updatePreferences(req, res, next) {
    accountService.updatePreferences(req.params.id, req.body)
        .then(() => res.json({ message: 'Preferences updated successfully' }))
        .catch(next);
}
function refreshToken (req, res, next) {
    const token = req.cookies.refreshToken;
    const ipAddress = req.ip;
    accountService.refreshToken({ token, ipAddress })
        .then(({refreshToken, ...account }) => {
            setTokenCookie(res, refreshToken);
            res.json(account);
        })
        .catch(next);
}
function revokeTokenSchema(req, res, next) { 
    const schema = Joi.object({
        token: Joi.string().empty('')
    });
    validateRequest(req, next, schema);
}
function revokeToken (req, res, next) {
    const token = req.body.token || req.cookies.refreshToken; 
    const ipAddress = req.ip;

    if (!token) return res.status(400).json({ message: 'Token is required' });
    
    if (!req.user.ownsToken (token) && req.user.role !== Role.SuperAdmin) {
        return res.status(401).json({ message: 'Unauthorized' });
    }

    accountService.revokeToken({token, ipAddress })
        .then(() =>res.json({ message: 'Token revoked' }))
        .catch(next);
}
function registerSchema(req, res, next) {
    const schema = Joi.object({
        title: Joi.string().required(),
        firstName: Joi.string().required(), 
        lastName: Joi.string().required(),
        email: Joi.string().email().required(),
        phoneNumber: Joi.string().length(11).pattern(/^(09|\+639)\d{9}$/).required(),
        password: Joi.string().min(6).required(),
        confirmPassword: Joi.string().valid(Joi.ref('password')).required(), 
        //acceptTerms: Joi.boolean().valid(true).required()
    });
    validateRequest(req, next, schema);
}
function register(req, res, next) {
    accountService.register(req.body, req.get('origin'))
        .then(() => res.json({ message: 'Registration successful, please check your email for verification instructions' })) 
        .catch(next);
}
function verifyEmailSchema(req, res, next) {
    const schema = Joi.object({
        token: Joi.string().required()
    });
    validateRequest(req, next, schema);
}
function verifyEmail(req, res, next) {
    accountService.verifyEmail(req.body)
        .then(() => res.json({ message: 'Verification successful, you can now login' })) 
        .catch(next);
}
function forgotPasswordSchema(req, res, next) {
    const schema = Joi.object({
        email: Joi.string().email().required()
    });
    validateRequest(req, next, schema);
}
function forgotPassword(req, res, next) {
    accountService.forgotPassword(req.body, req.get('origin'))
        .then(() => res.json({ message: 'Please check your email for password reset instructions' })) 
        .catch(next);
}
function validateResetTokenSchema(req, res, next) {
    const schema = Joi.object({
        token: Joi.string().required()
    });
    validateRequest(req, next, schema);
}
function validateResetToken(req, res, next) {
    accountService.validateResetToken(req.body)
        .then(() => res.json({ message: 'Token is valid' }))
        .catch(next);
}
function resetPasswordSchema(req, res, next) {
    const schema = Joi.object({
        token: Joi.string().required(),
        password: Joi.string().min(6).required(),
        confirmPassword: Joi.string().valid(Joi.ref('password')).required()
    });
    validateRequest(req, next, schema);
}
function resetPassword(req, res, next) {
    const { token, password } = req.body;
    const ipAddress = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
    const browserInfo = req.headers['user-agent'] || 'Unknown Browser';
  
    accountService.resetPassword({ token, password }, ipAddress, browserInfo)
      .then(() => {
        res.json({ message: 'Password reset successful, you can now login' });
      })
      .catch(next);
  }
function getAll(req, res, next) {
    accountService.getAll()
        .then (accounts => res.json (accounts))
        .catch(next);
}
function getById(req, res, next) {
    //Check if the user is trying to access their own account or is anSuperadmin
    if (Number(req.params.id) !== req.user.id && req.user.role !== Role.Admin) {
        return res.status(403).json({ message: 'Access to other user\'s data is forbidden' });
    }
    
    accountService.getById(req.params.id)
        .then(account => account ? res.json(account) : res.sendStatus(404)) 
        .catch(next);
}
function createSchema (req, res, next) {
    const schema = Joi.object({
        title: Joi.string().required(), 
        firstName: Joi.string().required(), 
        lastName: Joi.string().required(), 
        email: Joi.string().email().required(),
        phoneNumber: Joi.string().length(11).pattern(/^(09|\+639)\d{9}$/).required(),  
        password: Joi.string().min(6).required(), 
        confirmPassword: Joi.string().valid(Joi.ref('password')).required(),
        role: Joi.string().valid(Role. SuperAdmin, Role.Admin, Role.User).required()
    });
    validateRequest(req, next, schema);
}
function create(req, res, next) {
    accountService.create(req.body) 
    .then (account => res.json (account)) 
    .catch(next);
}
function updateSchema(req, res, next) { const schemaRules = {
    title: Joi.string().empty(''), 
    firstName: Joi.string().empty(''), 
    lastName: Joi.string().empty(''),
    email: Joi.string().email().empty(''),
    phoneNumber: Joi.string().length(11).pattern(/^(09|\+639)\d{9}$/).empty(''),
    password: Joi.string().min(6).empty(''),
    confirmPassword: Joi.string().valid(Joi.ref('password')).empty('')
}

if (req.user.role === Role.SuperAdmin) {
    schemaRules.role = Joi.string().valid (Role.SuperAdmin, Role.User, Role.Staff).empty('');
}

    const schema = Joi.object(schemaRules).with('password', 'confirmPassword'); 
    validateRequest(req, next, schema);
}
function update(req, res, next) {
    //Check authorization
    if (Number(req.params.id) !== req.user.id && req.user.role !== Role.Admin) {
      return res.status(401).json({
        success: false,
        message: 'Unauthorized - You can only update your own account unless you are anSuperadmin'
      });
    }
  
    const ipAddress = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
    const browserInfo = req.headers['user-agent'] || 'Unknown Browser';
  
    accountService.update(req.params.id, req.body, ipAddress, browserInfo)
      .then(account => {
        res.json({
          success: true,
          message: 'Account updated successfully',
          account: account
        });
      })
      .catch(next);
  }
function _delete(req, res, next) {
    if (Number(req.params.id) !== req.user.id && req.user.role !== Role.Admin) {
        return res.status(401).json({ message: 'Unauthorized' });
    }
    
    accountService.delete(req.params.id)
        .then(() =>res.json({ message: 'Account deleted successfully' })) 
        .catch(next);
}  
function setTokenCookie(res, token) {
    const cookieOptions = {
        httpOnly: true,
        expires: new Date(Date.now() + 7*24*60*60*1000)
    };
    res.cookie('refreshToken', token, cookieOptions);
}

================================================================================
File: _controllers\item.controller.js
Size: 3.6 kB
================================================================================

const express = require('express');
const router = express.Router();
const Joi = require('joi');
const itemService = require('_services/item.service');
const validateRequest = require('_middlewares/validate-request');
const { Router } = require('express');
const multer = require('multer');
const fs = require('fs');
const path = require('path');
const authorize = require('_middlewares/authorize');
const Role = require('_helpers/role');

const UPLOAD_DIR = path.resolve(__dirname, '..', 'uploads');
if (!fs.existsSync(UPLOAD_DIR)) {
  fs.mkdirSync(UPLOAD_DIR, { recursive: true });
}

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    fs.mkdirSync(UPLOAD_DIR, { recursive: true });
    cb(null, UPLOAD_DIR);
  },
  filename: (req, file, cb) => {
    const uniqueName = `${Date.now()}-${file.originalname}`;
    cb(null, uniqueName);
  }
});

const upload = multer({ storage }).single('itemQrCode');

router.post('/create-item', authorize(Role.SuperAdmin, Role.Admin), upload, createItemSchema, createItem);
router.get('/', getItems);
router.get('/:id', getItemById);
router.post('/assign-item', authorize(Role.SuperAdmin), createAssignment);
//router.post('/scan-item', authorize(Role.SuperAdmin, Role.Admin), scanItemHandler);
router.put('/:id/activation', authorize(Role.SuperAdmin), itemActivation);

module.exports = router;

async function createItem(req, res, next) {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'QR code file is required.' });
    }

    const { itemName, itemCategory } = req.body;
    const qrFilename = req.file.filename;
    const qrPath = `/uploads/${qrFilename}`;

    const newItem = await itemService.createItem({
      itemName,
      itemCategory,
      itemQrCode: qrPath
    });

    return res.status(201).json(newItem);
  } catch (error) {
    next(error);
  }
}
function createItemSchema(req, res, next) {
  const schema = Joi.object({
      itemName: Joi.string().required().min(1).max(10),
      itemCategory: Joi.string().valid('it', 'apparel', 'academic', 'unknown').required(),
      roomId: Joi.number().optional()
  });
  validateRequest(req, next, schema);
}
function getItems(req, res, next) {
  itemService.getItems()
      .then(items => res.json(items))
      .catch(next);
}
function getItemById(req, res, next) {
  itemService.getItemById(req.params.id)
      .then(items => res.json(items))
      .catch(next);
}
async function createAssignment(req, res, next) {
  try {
    const { params } = req.body;
    const assignment = await itemService.assignItem({ params });
    res.status(201).json(assignment);
  } catch (err) {
    next(err);
  }
}
function itemActivation(req, res, next) {
  const { id } = req.params;

  itemService
    .itemActivation(id)
    .then((newStatus) =>
      res.json({ message: `Product ${newStatus} successfully` })
    )
    .catch(next);
}

================================================================================
File: _controllers\room.controller.js
Size: 3.28 kB
================================================================================

const express = require('express');
const router = express.Router();
const Joi = require('joi');
const roomService = require('_services/room.service');
const validateRequest = require('_middlewares/validate-request');
const authorize = require('_middlewares/authorize');
const Role = require('_helpers/role');

router.post('/create-room', authorize(Role.SuperAdmin), createRoomschema, createRoom);
router.get('/', getRooms);
router.get('/:id', getRoomById);
router.post('/:roomId/register-item', authorize(Role.SuperAdmin), registerItemSchema, registerItemHandler );
router.get('/in-charge-options', getInChargeOptions);
router.get('/:roomId/items', getRoomItems);
//router.get('/:roomId/scannable-items', getScannableItems);
router.post('/:roomId/scan', scanItem);
router.put('/:roomId/scan/items/:itemQrCode/status', updateItemStatus);

module.exports = router;

function createRoom(req, res, next) {
  roomService.createRoom(req.body)
      .then(() => res.json({ message: 'Room created' }))
      .catch(next);
}
function createRoomschema(req, res, next) {
  const schema = Joi.object({
      roomName: Joi.string().required().min(1).max(10),
      roomFloor: Joi.string().required().min(1).max(5),
      roomInCharge: Joi.number().integer().min(0)
  });
  validateRequest(req, next, schema);
}
function getRooms(req, res, next) {
  roomService.getRooms()
      .then(room => res.json(room))
      .catch(next);
}
function getRoomById(req, res, next) {
  roomService.getRoomById(req.params.id)
      .then(rooms => res.json(rooms))
      .catch(next);
}
async function getInChargeOptions(req, res, next) {
  try {
    const users = await roomService.getUsersForDropdown();
    res.json(users);
  } catch (err) {
    next(err);
  }
}
function registerItemSchema(req, res, next) {
  const schema = Joi.object({
    itemId:   Joi.number().integer().required(),
  });
  validateRequest(req, next, schema);
}
async function registerItemHandler(req, res, next) {
  try {
    const { itemId } = req.body;
    const inventory = await roomService.registerItem(req.params.roomId, itemId);
    res.status(201).json(inventory);
  } catch (err) {
    next(err);
  }
}
async function getRoomItems(req, res, next) {
  try {
    const items = await roomService.getRoomItems(req.params.roomId);
    res.json(items);
  } catch (err) {
    next(err);
  }
}
// async function getScannableItems(req, res, next) {
//   try {
//     const items = await roomService.getScannableItems(req.params.roomId);
//     res.json(items);
//   } catch (err) {
//     next(err);
//   }
// }
async function scanItem(req, res, next) {
  try {
    const { roomId } = req.params;
    const { itemQrCode } = req.body;
    const item = await roomService.scanItem(roomId, itemQrCode);
    return res.json({ item });
  } catch (err) {
    next(err);
  }
}
async function updateItemStatus(req, res, next) {
  try {
    const { roomId, itemQrCode } = req.params;
    const { newStatus } = req.body;
    const updatedInventory = await roomService.updateInventoryStatus(
      roomId,
      itemQrCode,
      newStatus
    );
    return res.json({ inventory: updatedInventory });
  } catch (err) {
    next(err);
  }
}

================================================================================
File: _helpers\db-handler.js
Size: 1.88 kB
================================================================================

const config = require('config.json');
const mysql = require('mysql2/promise');
const { Sequelize } = require('sequelize');

module.exports = db = {};

initialize();
async function initialize() { 
    const { host, port, user, password, database } = config.database;
    const connection = await mysql.createConnection({ host, port, user, password });
    await connection.query(`CREATE DATABASE IF NOT EXISTS \`${database}\`;`);
    
    await connection.end();

    const sequelize = new Sequelize(database, user, password, { host: 'localhost', dialect: 'mysql' });

// Initialize models and add them to the exported `db` object
db.Room = require('../_models/room.model')(sequelize);
db.RoomInventory = require('../_models/roomInventory.model')(sequelize);
db.Account = require('../_models/account.model')(sequelize);
db.ActivityLog = require('../_models/activitylog.model')(sequelize);
db.RefreshToken = require('../_models/refresh-token.model')(sequelize);
db.Item = require('../_models/item.model')(sequelize);

dbAssociations();

    await sequelize.sync({ alter: true }); 
}  

function dbAssociations() {
    // Account-Room owner relation
    db.Account.hasMany(db.Room, { foreignKey: 'roomInCharge', as: 'managedRooms' });
    db.Room.belongsTo(db.Account, { foreignKey: 'roomInCharge', as: 'ownerss' });

    // Room-Item many-to-many via RoomInventory
    db.Room.belongsTo(db.Item, { through: db.RoomInventory, foreignKey: 'roomId', otherKey: 'itemId' });
    
    db.Item.belongsTo(db.Room, { through: db.RoomInventory, foreignKey: 'itemId', otherKey: 'roomId' });

    // Direct join-model relations
    db.RoomInventory.belongsTo(db.Room, { foreignKey: 'roomId' });
    db.RoomInventory.belongsTo(db.Item, { foreignKey: 'itemId', as: 'Item' });

    db.Item.hasMany(db.RoomInventory, { foreignKey: 'itemId' });
    
}

================================================================================
File: _helpers\role.js
Size: 91 B
================================================================================

module.exports = {
    SuperAdmin: 'superAdmin',
    Admin: 'admin',
    User: 'user'
}

================================================================================
File: _helpers\send-email.js
Size: 327 B
================================================================================

const nodemailer = require('nodemailer');
const config = require('config.json');

module.exports = sendEmail;

async function sendEmail({ to, subject, html, from = config.emailFrom }) {
    const transporter = nodemailer.createTransport(config.smtpOptions);
    await transporter.sendMail({ from, to, subject, html});
}

================================================================================
File: _helpers\swagger.js
Size: 305 B
================================================================================

const express = require('express');
const router = express.Router();
const swaggerUi = require('swagger-ui-express');
const YAML = require('yamljs');
const swaggerDocument = YAML.load('./swagger.yaml');

router.use('/', swaggerUi.serve, swaggerUi.setup(swaggerDocument));

module.exports = router;

================================================================================
File: _middlewares\authorize.js
Size: 4.43 kB
================================================================================

// const { expressjwt: jwt } = require('express-jwt');
// const { secret } = require('config.json');
// const db = require('_helpers/db-handler');
// const Role = require('_helpers/role');

// module.exports = authorize;

// function authorize(roles = []) {
//     // Convert single role to array if string is provided
//     if (typeof roles === 'string') {
//         roles = [roles];
//     }

//     return [
//         // Authenticate JWT token and attach decoded token to request as req.auth
//         jwt({ 
//             secret, /* process.env.JWT_SECRET */
//             algorithms: ['HS256'],
//             requestProperty: 'auth'
//         }),

//         // Authorize based on user role
//         async (req, res, next) => {
//             try {
//                 const account = await db.Account.findByPk(req.auth.id);
//                 if (!account) {
//                     return res.status(401).json({ message: 'Account no longer exists' });
//                 }
//                 if (roles.length && !roles.includes(account.role)) {
//                     return res.status(401).json({ message: 'Unauthorized - Insufficient role permissions' });
//                 }

//                 // Attach user details to req.user
//                 req.user = {
//                     id: account.id,
//                     email: account.email,
//                     role: account.role,
//                     ownsToken: token => account.getRefreshTokens().then(tokens =>
//                         tokens.some(x => x.token === token)
//                     )
//                 };

//                 // // authentication and authorization successful
//                 // // attach user and role to request object
//                 // req.user = {
//                 //     ...req.auth,
//                 //     role: account.role,
//                 //     BranchId: account.BranchId  // Make sure this is being set correctly
//                 // };
                
//                 // // Add method to check if user owns a refresh token
//                 // const refreshTokens = await account.getRefreshTokens();
//                 // req.user.ownsToken = token => !!refreshTokens.find(x => x.token === token);

//                 // Log authorization attempt
//                 console.log(`Authorization successful for user ${account.email} with role ${account.role}`);

//                 next();
//             } catch (error) {
//                 console.error('Authorization error:', error);
//                 return res.status(500).json({
//                     success: false,
//                     message: 'Internal server error during authorization'
//                 });
//             }
//         }
//     ];
// }

const { expressjwt: jwt } = require('express-jwt');
const { secret } = require('config.json');
const db = require('_helpers/db-handler');
const Role = require('_helpers/role');

module.exports = authorize;

/**
 * Protect routes based on JWT and user role.
 * @param {string|string[]} roles - allowed roles for this route
 */
function authorize(roles = []) {
    if (typeof roles === 'string') {
        roles = [roles];
    }

    return [
        // 1) Authenticate JWT token and attach decoded token to request as req.auth
        jwt({ secret, algorithms: ['HS256'], requestProperty: 'auth' }),

        // 2) Authorize based on user role
        async (req, res, next) => {
            try {
                const account = await db.Account.findByPk(req.auth.id);
                if (!account) {
                    return res.status(401).json({ message: 'Account no longer exists' });
                }

                // Disallow if role not in allowed list
                if (roles.length && !roles.includes(account.role)) {
                    return res.status(403).json({ message: 'Forbidden: insufficient permissions' });
                }

                // Attach essential user details to req.user
                req.user = { id: account.id, email: account.email, role: account.role };
                next();
            } catch (error) {
                console.error('Authorization error:', error);
                res.status(500).json({ message: 'Internal server error during authorization' });
            }
        }
    ];
}

================================================================================
File: _middlewares\error-handler.js
Size: 711 B
================================================================================

module.exports = errorHandler;

function errorHandler(err, req, res, next) {
    switch (true) {
        case typeof err === 'string':
            const is404 = err.toLowerCase().endsWith('not found');
            const statusCode = is404 ? 404 : 400;
            return res.status(statusCode).json({ message: err });
        // case err.message && err.message.toLowerCase().includes('deactivated'):
        //     return res.status(403).json({ message: 'deactivated' });
        case err.name === 'UnauthorizedError':
            return res.status(401).json({ message: 'Unauthorized error-handler' });
        default:
            return res.status(500).json({ message: err.message });
    }
}


================================================================================
File: _middlewares\validate-request.js
Size: 436 B
================================================================================

module.exports = validateRequest;

function validateRequest(req, next, schema) {
    const options = {
        abortEarly: false,
        allowUnknown: true,
        stripUnknown: true
    };
    const { error, value } = schema.validate(req.body, options);
    if (error) {
        next(`Validation error: ${error.details.map(x => x.message).join(', ')}`);
    } else {
        req.body = value;
        next();
    }
}


================================================================================
File: _models\account.model.js
Size: 1.47 kB
================================================================================

const { DataTypes } = require('sequelize');

module.exports = model;

function model(sequelize) {
    const attributes = {
        email: { type: DataTypes.STRING, allowNull: false }, 
        phoneNumber: { type: DataTypes.STRING, allowNull: false },
        passwordHash: { type: DataTypes.STRING, allowNull: false }, 
        title: { type: DataTypes.STRING, allowNull: false }, 
        firstName: { type: DataTypes.STRING, allowNull: false }, 
        lastName: { type: DataTypes.STRING, allowNull: false }, 
        //acceptTerms: { type: DataTypes.BOOLEAN },
        role: { type: DataTypes.STRING, allowNull: true }, 
        verificationToken: { type: DataTypes.STRING },
        verified: {type: DataTypes.DATE },
        resetToken: {type: DataTypes.STRING },
        resetTokenExpires: { type: DataTypes.DATE },
        passwordReset: { type: DataTypes.DATE},
        created: {type: DataTypes.DATE, allowNull: false, defaultValue: DataTypes.NOW }, 
        updated: { type: DataTypes.DATE },
        isVerified: {
            type: DataTypes.VIRTUAL,
            get() { return !!(this.verified || this.passwordReset); }
        }
    };

    const options = {
        timestamps: false,
        defaultScope: {
            attributes: {exclude: ['passwordHash'] }
        },
        scopes: {
            withHash: { attributes: {}, }
        }
    };

    return sequelize.define('Account', attributes, options);
    
}

================================================================================
File: _models\activitylog.model.js
Size: 686 B
================================================================================

const { DataTypes } = require('sequelize');

module.exports = model;

function model(sequelize) {
    const attributes = {
        AccountId: { type: DataTypes.INTEGER, allowNull: false },
        // entity: { type: DataTypes.STRING, allowNull: true },
        // entityId: { type: DataTypes.INTEGER, allowNull: true },
        actionType: { type: DataTypes.STRING, allowNull: false },
        actionDetails: { type: DataTypes.TEXT, allowNull: true },
        timestamp: { type: DataTypes.DATE, defaultValue: DataTypes.NOW },
    };

    const options = {
        timestamps: false 
        
    };

    return sequelize.define('ActivityLog', attributes, options);
}

================================================================================
File: _models\item.model.js
Size: 556 B
================================================================================

const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
    const attributes = {
        itemName: { type: DataTypes.STRING, allowNull: false },
        itemCategory: { type: DataTypes.ENUM('it', 'apparel', 'academic', 'unknown'), allowNull: false, defaultValue: 'unknown' },
        itemQrCode: { type: DataTypes.STRING, allowNull: false },
        itemStatus: { type: DataTypes.ENUM('deactivated', 'reactivated'), allowNull: false, defaultValue: 'reactivated'}
    };

    return sequelize.define('Item', attributes);
};

================================================================================
File: _models\refresh-token.model.js
Size: 978 B
================================================================================

const { DataTypes } = require('sequelize');

module.exports = model;

function model(sequelize) {
    const attributes = {
        token: { type: DataTypes.STRING },
        expires: { type: DataTypes.DATE },
        created: { type: DataTypes.DATE, allowNull: false, defaultValue: DataTypes.NOW }, 
        createdByIp: { type: DataTypes.STRING },
        revoked: { type: DataTypes.DATE },
        revokedByIp: { type: DataTypes.STRING },
        replacedByToken: { type: DataTypes.STRING }, 
        AccountId: { type: DataTypes.INTEGER, allowNull: false },
        isExpired: {
            type: DataTypes.VIRTUAL,
            get() { return Date.now() >= this.expires; }
        },
        isActive: {
            type: DataTypes.VIRTUAL, 
            get() { return !this.revoked && !this.isExpired; }
        }
    };

    const options = {
        timestamps: false
    };

    return sequelize.define('RefreshToken', attributes, options);
}

================================================================================
File: _models\room.model.js
Size: 352 B
================================================================================

const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const attributes = {
    roomName: { type: DataTypes.STRING, allowNull: false },
    roomFloor: { type: DataTypes.STRING, allowNull: false },
    roomInCharge: { type: DataTypes.INTEGER, allowNull: false }
  };

  return sequelize.define('Room', attributes);
};

================================================================================
File: _models\roomInventory.model.js
Size: 557 B
================================================================================

const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const attributes = {
    id: { type: DataTypes.INTEGER,primaryKey: true, autoIncrement: true}, 
    roomId: { type: DataTypes.INTEGER, allowNull: false },
    itemId: { type: DataTypes.INTEGER, allowNull: false },
    registeredAt: { type: DataTypes.DATE, defaultValue: DataTypes.NOW },
    newStatus: { type: DataTypes.ENUM('active', 'damage', 'missing'), allowNull: false, defaultValue: 'active'}
  }
  
  return sequelize.define('RoomInventory', attributes);
};

================================================================================
File: _services\account.service.js
Size: 15.39 kB
================================================================================

const config = require('config.json'); 
const jwt = require('jsonwebtoken'); 
const bcrypt = require('bcryptjs'); 
const crypto= require("crypto"); 
const { Op} = require('sequelize');
const sendEmail = require('_helpers/send-email'); 
const db = require('_helpers/db-handler');
const Role = require('_helpers/role');

module.exports = { 
    authenticate,
 
    refreshToken,
    revokeToken,
    register,
    verifyEmail,
    forgotPassword,
    validateResetToken,
    resetPassword, 

    getAll,
    getById,
    create,
    update,
    delete: _delete,

    logActivity,
    getAccountActivities,
    getAllActivityLogs,

    updatePreferences,
    getPreferences
    
};


async function create(params) {
  const existingAccount = await db.Account.findOne({ where: { email: params.email } });
  if (existingAccount) {
      throw `Email "${params.email}" is already registered`;
  }
  const existingAccountNumber = await db.Account.findOne({ where: { phoneNumber: params.phoneNumber } });
  if (existingAccountNumber) {
      throw `PhoneNumber "${params.phoneNumber}" is already registered`;
  }
  
  const account = new db.Account(params);
  account.verified = Date.now();
  account.passwordHash = await hash(params.password);
  
  await account.save();
  
  return basicDetails(account);
}
async function update(id, params, ipAddress, browserInfo) {
  const account = await getAccount(id);
  const oldData = account.toJSON(); 
  const updatedFields = []; 
  const nonUserFields = ['ipAddress', 'browserInfo'];
  
  const hasChanges = Object.keys(params).some(key => 
    !nonUserFields.includes(key) && 
    params[key] !== undefined && 
    params[key] !== oldData[key]
  );
  
  if (!hasChanges) {
    return basicDetails(account);
  }
  
  if (params.email && account.email !== params.email && await db.Account.findOne({ where: { email: params.email } })) { 
      throw 'Email "' + params.email + '" is already taken';
  }
  
  if (params.password) {
      params.passwordHash = await hash(params.password);
  }
  
  for (const key in params) {
    if (params.hasOwnProperty(key) && !nonUserFields.includes(key)) {
        if (oldData[key] !== params[key]) {
            updatedFields.push(`${key}: ${oldData[key]} -> ${params[key]}`);
        }
    }
  }
  
  Object.assign(account, params); 
  account.updated = Date.now(); 
  
  try {
      await account.save();
  
      const updateDetails = updatedFields.length > 0 
          ? `Updated fields: ${updatedFields.join(', ')}` 
          : 'No fields changed';
  
      await logActivity(account.id, 'profile update', ipAddress || 'Unknown IP', browserInfo || 'Unknown Browser', updateDetails);
  } catch (error) {
      console.error('Error logging activity:', error);
  }
  
  return basicDetails(account);
}
async function _delete(id) {
  const account = await getAccount(id);
  await account.destroy();
}
async function getAll() {
  const accounts = await db.Account.findAll(); 
  return accounts.map(x => basicDetails(x));
}
async function getById(id) {
  const account = await getAccount(id); 
  return basicDetails (account);
}
async function register(params, origin) {
  if (await db.Account.findOne({ where: { email: params.email } })) {
      return await sendAlreadyRegisteredEmail (params.email, origin);
  }
  
  const account = new db.Account (params);

  const isFirstAccount = (await db.Account.count()) === 0; 
  account.role = isFirstAccount? Role.Admin: Role.User; 
  account.verificationToken = randomTokenString();
  
  account.passwordHash = await hash (params.password);
  
  await account.save();
  
  await db.Preferences.create(preferencesData);

  await sendVerificationEmail (account, origin);
}
async function authenticate({ email, password, ipAddress, browserInfo }) {
    const account = await db.Account.scope('withHash').findOne({ where: { email } });
  
    if (!(await bcrypt.compare(password, account.passwordHash))) {
      throw 'Email or password is incorrect';
    }
  
    const jwtToken = generateJwtToken(account);
    const refreshToken = generateRefreshToken(account, ipAddress);
  
    await refreshToken.save();
  
    try {
      await logActivity(account.id, 'login', ipAddress, browserInfo);
    } catch (error) {
      console.error('Error logging activity:', error);
    }
  
    return {
      ...basicDetails(account),
      jwtToken,
      refreshToken: refreshToken.token
    };
}
async function logActivity(AccountId, actionType, ipAddress, browserInfo, updateDetails = '') {
    try {
      await db.ActivityLog.create({
        AccountId,
        actionType,
        actionDetails: `IP Address: ${ipAddress}, Browser Info: ${browserInfo}, Details: ${updateDetails}`,
        timestamp: new Date()
      });
  
      const logCount = await db.ActivityLog.count({ where: { AccountId } });
  
      if (logCount > 10) {
        const logsToDelete = await db.ActivityLog.findAll({
          where: { AccountId },
          order: [['timestamp', 'ASC']],
          limit: logCount - 10
        });
  
        if (logsToDelete.length > 0) {
          const logIdsToDelete = logsToDelete.map(log => log.id);
  
          await db.ActivityLog.destroy({
            where: {
              id: {
                [Op.in]: logIdsToDelete
              }
            }
          });
          console.log(`Deleted ${logIdsToDelete.length} oldest log(s) for user ${AccountId}.`);
        }
      }
    } catch (error) {
      console.error('Error logging activity:', error);
      throw error;
    }
}
async function getAllActivityLogs(filters = {}) {
  try {
      let whereClause = {};
      
      if (filters.actionType) {
          whereClause.actionType = { [Op.like]: `%${filters.actionType}%` };
      }
      
      if (filters.userId) {
          whereClause.AccountId = filters.userId;
      }
      
      if (filters.startDate || filters.endDate) {
          const startDate = filters.startDate ? new Date(filters.startDate) : new Date(0);
          const endDate = filters.endDate ? new Date(filters.endDate) : new Date();
          whereClause.timestamp = { [Op.between]: [startDate, endDate] };
      }

      const logs = await db.ActivityLog.findAll({
          where: whereClause,
          include: [{
              model: db.Account,
              attributes: ['email', 'firstName', 'lastName', 'role'],
              required: true
          }],
          order: [['timestamp', 'DESC']]
      });

      return logs.map(log => {
          const formattedDate = new Intl.DateTimeFormat('en-US', {
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              hour12: true
          }).format(new Date(log.timestamp));

          return {
              id: log.id,
              userId: log.AccountId,
              userEmail: log.Account.email,
              userRole: log.Account.role,
              userName: `${log.Account.firstName} ${log.Account.lastName}`,
              actionType: log.actionType,
              actionDetails: log.actionDetails,
              timestamp: formattedDate
          };
      });
  } catch (error) {
      console.error('Error retrieving all activity logs:', error);
      throw new Error('Error retrieving activity logs');
  }
}
async function getAccountActivities(AccountId, filters = {}) {
  const account = await getAccount(AccountId);
  if (!account) throw new Error('User not found');

  let whereClause = { AccountId };

  if (filters.actionType) {
    whereClause.actionType = { [Op.like]: `%${filters.actionType}%` };
  }
  if (filters.startDate || filters.endDate) {
    const startDate = filters.startDate ? new Date(filters.startDate) : new Date(0);
    const endDate = filters.endDate ? new Date(filters.endDate) : new Date();
    whereClause.timestamp = { [Op.between]: [startDate, endDate] };
  }

  try {
    const activities = await db.ActivityLog.findAll({ where: whereClause });
    return activities.map(activity => {
      const formattedDate = new Intl.DateTimeFormat('en-US', {
          year: '2-digit',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          hour12: true
      }).format(new Date(activity.timestamp));

      return {
          id: activity.id,
          AccountId: activity.AccountId,
          actionType: activity.actionType,
          actionDetails: activity.actionDetails,
          timestamp: formattedDate 
      };
  });
  } catch (error) {
    console.error('Error retrieving activities:', error);
    throw new Error('Error retrieving activities');
  }
}
async function forgotPassword({ email }, origin) {
  const account = await db.Account.findOne({ where: { email } });

  if (!account) return;
  
  account.resetToken = randomTokenString();
  account.resetTokenExpires= new Date(Date.now() + 24*60*60*1000);
  await account.save();

  await sendPasswordResetEmail (account, origin);
}
async function resetPassword({ token, password }, ipAddress, browserInfo) {
  const account = await validateResetToken({ token });

   if (password.length < 6) {
    throw 'Password must be at least 6 characters';
}
  account.passwordHash = await hash(password);
  account.passwordReset = Date.now();
  account.resetToken = null;
  account.resetTokenExpires = null; // Clear the expiry
  await account.save();

  try {
    await logActivity(account.id, 'password_reset', ipAddress, browserInfo);
  } catch (error) {
    console.error('Error logging activity:', error);
  }

  return;
}
async function refreshToken({ token, ipAddress }) { 
    const refreshToken = await getRefreshToken(token); 
    const account = await refreshToken.getAccount();

    const newRefreshToken = generateRefreshToken (account, ipAddress); 
    refreshToken.revoked = Date.now();
    refreshToken.revokedByIp = ipAddress;
    refreshToken.replacedByToken = newRefreshToken.token;
    await refreshToken.save();
    await newRefreshToken.save();
    
    const jwtToken = generateJwtToken(account);
    
    return {
        ...basicDetails (account),
        jwtToken,
        refreshToken: newRefreshToken.token
    };
}
async function revokeToken({ token, ipAddress }) { 
    const refreshToken = await getRefreshToken (token);
    
    refreshToken.revoked = Date.now();
    refreshToken.revokedByIp = ipAddress; 
    await refreshToken.save();
}
async function verifyEmail({token}) {
    const account = await db.Account.findOne({ where: { verificationToken: token} });

    if (!account) throw 'Verification failed';

    account.verified = Date.now();
    account.verificationToken = null; 
    await account.save();
}
async function validateResetToken({token}) { 
    const account = await db.Account.findOne({ 
        where: {
            resetToken: token,
            resetTokenExpires: { [Op.gt]: Date.now() }
        }
    });

    if (!account) throw 'Invalid token';

    return account;
}
async function getAccount (id) {
  const account = await db.Account.findByPk(id); 
  if (!account) throw 'Account not found';
  return account;
}
async function getRefreshToken(token) {
  const refreshToken = await db.RefreshToken.findOne({ where: {token} });
  if (!refreshToken || !refreshToken.isActive) throw 'Invalid token'; 
  return refreshToken;
}
async function hash (password) {
  return await bcrypt.hash (password, 10);
}
function generateJwtToken(account) {
  return jwt.sign({ sub: account.id, id: account.id}, config.secret, { expiresIn: '1h' });
}
function generateRefreshToken(account, ipAddress) {
  return new db.RefreshToken({
      AccountId: account.id, // Set the AccountId field
      token: randomTokenString(),
      expires: new Date(Date.now() + 7*24*60*60*1000), 
      createdByIp: ipAddress
  });
}
function randomTokenString() {
  return crypto.randomBytes (40).toString('hex');
}
function basicDetails(account) {
  const { id, title, firstName, lastName, email, phoneNumber, role, created, updated, isVerified, BranchId } = account; 
  return { id, title, firstName, lastName, email, phoneNumber, role, created, updated, isVerified, BranchId };
}
async function sendVerificationEmail(account, origin) {
  let message;
  if (origin) {
      const verifyUrl = `${origin}/account/verify-email?token=${account.verificationToken}`; 
      message = `<p>Please click the below link to verify your email address:</p>;
                 <p><a href="${verifyUrl}">${verifyUrl}</a></p>`;
  } else {
      message = `<p>Please use the below token to verify your email address with the <code>/account/verify-email</code> api route:</p> 
                 <p><code>${account.verificationToken}</code></p>`;
  }
  
  await sendEmail({
  to: account.email,
  subject: 'Sign-up Verification API - Verify Email',
  html: `<h4>Verify Email</h4>
        <p>Thanks for registering!</p> 
        ${message}`
  });
}
async function sendAlreadyRegisteredEmail(email, origin) {
  let message; 
  if (origin) {
      message = `
      <p>If you don't know your password please visit the <a href="${origin}/account/forgot-password">forgot password</a> page.</p>`; 
  } else { message = `
      <p>If you don't know your password you can reset it via the <code>/account/forgot-password</code> api route.</p>`;
  }

  await sendEmail({
      to: email,
      subject: 'Sign-up Verification API - Email Already Registered',
      html: `<h4>Email Already Registered</h4>
      <p>Your email <strong>${email}</strong> is already registered.</p> ${message}`
  });
}
async function sendPasswordResetEmail (account, origin) {
  let message;
  if (origin) {
      const resetUrl = `${origin}/account/reset-password?token=${account.resetToken}`;
      message = `<p>Please click the below link to reset your password, the link will be valid for 1 day:</p>
                 <p><a href="${resetUrl}">${resetUrl}</a></p>`;
  } else {
      message = `<p>Please use the below token to reset your password with the <code>/account/reset-password</code> api route:</p> 
                 <p><code>${account.resetToken}</code></p>`;
  }
  
  await sendEmail({
  to: account.email,
  subject: 'Sign-up Verification API - Reset Password',
  html: `<h4>Reset Password Email</h4>
        ${message}`
  });
}

//===================Preferences Get & Update Function===========================
async function getPreferences(id) {
  const preferences = await db.Preferences.findOne({
      where: { AccountId: id },
      attributes: ['id', 'userId','theme', 'notifications', 'language']
  });
  if (!preferences) throw new Error('User not found');
  return preferences;
}
async function updatePreferences(id, params) {
  const preferences = await db.Preferences.findOne({ where: { AccountId: id } });
  if (!preferences) throw new Error('User not found');

  // Update only the provided fields
  Object.assign(preferences, params);

  await preferences.save();
}

    

================================================================================
File: _services\item.service.js
Size: 1.51 kB
================================================================================

const db = require('_helpers/db-handler');

module.exports = {
  createItem,
  getItems,
  getItemById,
  assignItem,
  itemActivation,
};

async function getItems() {
  return await db.Item.findAll({
    where: { 
        itemStatus: 'reactivated' 
    }
});
}
async function createItem(body, file) {
const filename = file?.filename;
const payload = {
  itemName:     body.itemName,
  itemCategory: body.itemCategory,
  itemQrCode:   file
    ? `/uploads/${filename}`
    : body.itemQrCode,
};

const item = await db.Item.create(payload);
if (body.roomId) {
  await db.RoomInventory.create({
    roomId: parseInt(body.roomId, 10),
    itemId: item.id
  });
}
return item;
}
async function getItemById(id) {
  const items = await db.Item.findByPk(id);
  if (!items) {
      throw new Error('Invalid item ID');
  }
  return items;
}
async function assignItem({ params, itemId, roomId }) {
  const entry = await db.RoomInventory.create({
    addedAt: params.addedAt,
    roomStatus: params.roomStatus
  });
  return entry;
}
async function itemActivation(id) {
  const item = await getItemById(id);
  if (!item) throw new Error('Item not found');

  if (item.itemStatus === 'reactivated') {
    item.itemStatus = 'deactivated';
  }
  else if (item.itemStatus === 'deactivated') {
    item.itemStatus = 'reactivated';
  }
  else {
    throw new Error(`Unexpected status: ${item.itemStatus}`);
  }

  await item.save();
  return item.itemStatus;
}

================================================================================
File: _services\room.service.js
Size: 2.63 kB
================================================================================

const db = require('_helpers/db-handler');

module.exports = {
  createRoom,
  getRooms,
  getRoomById,
  getUsersForDropdown,
  registerItem,
  getRoomItems,
  scanItem,
  updateInventoryStatus
};

async function getRooms() {
  return await db.Room.findAll({
    include: [{
      model: db.Account,
      as: 'ownerss',
      attributes: ['firstName', 'lastName']
    }]
  });
}
async function createRoom(params) {
  let rooms = await db.Room.findOne({ where: {roomName: params.roomName} });

  if (rooms) {
    return { 
      message: 'Room already exists'
    }
  } else {
    rooms = await db.Room.create({
      roomName: params.roomName,
      roomFloor: params.roomFloor,
      roomInCharge: params.roomInCharge
    });
    return { 
      message: 'New room created.', 
      rooms 
  };
  }
}
async function getRoomById(id) {
  const rooms = await db.Room.findByPk(id);
  if (!rooms) {
      throw new Error('Invalid room ID');
  }
  return rooms;
}
async function getUsersForDropdown() {
  return db.Account.findAll({
    attributes: ['id', 'firstName', 'lastName']
  });
}
async function registerItem(roomId, itemId) {
  const room = await db.Room.findByPk(roomId);
  const item = await db.Item.findByPk(itemId);
  if (!room || !item) throw 'Invalid room or item';
  return db.RoomInventory.create({ roomId, itemId });
}
async function getRoomItems(roomId, params) {
  const inventories = await db.RoomInventory.findAll({
    where: { roomId },
    include: [{ model: db.Item, as: 'Item', attributes: ['id', 'itemName', 'itemQrCode']}]
  });
  return inventories.map(inv => inv.Item);
}
async function scanItem(roomId, itemQrCode) {
  const inventory = await db.RoomInventory.findOne({
    where: { roomId },
    include: [{
      model: db.Item,
      as: 'Item',
      where: { itemQrCode: itemQrCode },
      attributes: ['id', 'itemName', 'itemQrCode', 'itemStatus']
    }]
  });

  if (!inventory) {
    throw new Error(`QR code "${itemQrCode}" not found in room ${roomId}`);
  }

  return inventory.Item;
}
async function updateInventoryStatus(roomId, itemQrCode, newStatus) {
  const entry = await db.RoomInventory.findOne({
    where: { roomId },
    include: [{
      model: db.Item,
      as: 'Item',
      where: { itemQrCode }
    }]
  });

  if (!entry) {
    throw new Error(`Item with QR "${itemQrCode}" not found in room ${roomId}`);
  }

  entry.newStatus = newStatus;
  await entry.save();

  return db.RoomInventory.findByPk(entry.id, {
    include: [{ model: db.Item, as: 'Item' }]
  });
}
